<Publication>
  <id>TUW-140533</id>
  <title></title>
  <abstractText>Zusammenfassung Formale Spezifikation und Verifikation sind durch die durch kontinuierliche Weiterentwicklung in letzter Zeit an einem Punkt angelangt, wo Programme beinahe automatisch verifiziert werden können. Das Ziel dieser Magisterarbeit ist es, sowohl kommerzielle als auch für wissenschaftliche Zwecke entwickelte Verifikationsprogramme zu testen. Der Hauptaugenmerk liegt auf dem Nutzen dieser Werkzeuge in der Software-Entwicklung und in der Lehre. Hierzu wird diese Magisterarbeit die theo-retischen Grundlagen vorstellen und auf die verschiedenen Fähigkeiten und Eigenheiten der ausgewählten Werkzeuge eingehen. Die theoretischen Grundlagen behandeln einerseits Ansätze, die für die formale Verifikation gebraucht werden, andererseits wird die Funktionsweise der ausgewählten Werkzeuge erklärt. Die begutachteten Programme sind der Frege Program Prover, KeY, Perfect Developer und das Prototype Verification System. Die Beispiele, mit denen diese Werkzeuge getestet werden, sind typische Problemstellung der Informatik. Bei der Evaluation wird auf den ganzen Ablauf beim Einsatz dieser Werkzeuge eingegangen und nicht nur auf das Endergebnis. Abstract Formal specification and verification of software have made small but continuous advances throughout its long history, and have reached a point where commercial tools became available for verifying programs semi-automatically or automatically. The aim of the master thesis is to evaluate commercial and academic verification tools with respect to their usability in developing software and in teaching formal methods. The thesis will explain the theoretical foundation and compare the capabilities and characteristics of selected commercial and academic tools on concrete examples. The theoretical foundations deal on the one hand with the general ideas and principles of formal software verification, on the other hand present some internals of the selected tools to give a comprehensive understanding. The discussed tools are the Frege Program Prover, KeY, Perfect Developer , and the Prototype Verification System. The examples encompass simple standard computer science problems. The evaluation of these tools concentrates on the whole development process of specification and verification , not just on the verification results. Acknowledgements I would like to thank my family, especially my mother Inge, for supporting me. Gernot Salzer, my advisor, helped me whenever he could and invested a lot of time in discussing and investigating problems together with me. David Crocker gave excellent support on Perfect Developer, Andreas Roth and Steffen Schlager offered helpful instructions on KeY, Jürgen Winkler provided papers and references on FPP. Also the subscribers of the PVS mailing list came up with nice ideas. 1 Introduction Formal software verification has become a more and more important issue in developing security related software during the last decades. As a reaction, ISO-the International Organisation for Standardisation-issued the ISO 15408 Standard, defining exactly various quality levels for tested and verified software. This standard is represented in the Common Criteria Project, with members of security organisations around the globe. During the last years, formal specification and verification tools have been introduced, especially designed for standard development processes. The focus ranges from security related projects, over hardware circuit verification to software driver verification. In particular model checking has been very successful. Based on this evolution this thesis deals with four specification and verification tools that enable the user to build software complying with the most demanding restrictions of the ISO 15408 Standard. The aim is to construct software that meets the Evaluation Assurance Levels 6 and 7 (EAL 6, EAL 7) defined in the Common Criteria Project. In other words this means fully verified specification and code. For a long time users of these tools have been assumed to be experts in formal methods. With new target groups requirements changed. Therefore this thesis evaluates the tools with respect to two groups: software engineers with a good knowledge of computer science but without specific training in formal methods, and students of computer science and software engineering in the middle of their studies, being confronted with formal verification tools for the first time. The four tools that will be investigated are the Frege Program Prover, KeY, Perfect Developer, and the Prototype Verification System. In the first part of this work, the theoretical background-main calculi and ideas of formal verification-is presented. Then the internals of the tools are discussed , showing the different approaches and techniques from the theoretical side. Finally, by going through a set of simple standard computer science examples, the different characteristics and capabilities are presented in a practical form. By examining the tools from both sides, theory and practice, their usability in developing software and in teaching formal methods for the above defined target group is discussed.</abstractText>
  <keywords>
    <string>MAGISTERARBEIT Formal Program Verification: a Comparison of Selected Tools and Their Theoretical Foundations Ausgeführt am Institut für Computersprachen der Technischen Universität Wien unter der Anleitung von AoUnivProf DI Dr Gernot Salzer durch Ingo Feinerer</string>
    <string>Bakktechn Felixdorfer Gasse 11 A-2700 Wiener Neustadt Wien</string>
    <string>Jänner 2005 MASTER THESIS Formal Program Verification: a Comparison of Selected Tools and Their Theoretical Foundations Ingo Feinerer Theory and Logic Group Institute of Computer Languages Vienna University of Technology Advisor Gernot Salzer Vienna</string>
    <string>January 2005</string>
  </keywords>
  <authors/>
  <affiliations/>
  <sections>
    <Section>
      <title>Historical perspective</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>2</level>
      <title>Theoretical Foundations</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>2.1</level>
      <title>Propositional Logic</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Semantics</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>2.2</level>
      <title>Natural Deduction</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>2.3</level>
      <title>Sequent Calculus</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>2.4</level>
      <title>Hoare Calculus</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>v</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>2.5</level>
      <title>Weakest Preconditions</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>3</level>
      <title>Selected Tools</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>3.1</level>
      <title>Overview</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>3.2</level>
      <title>Frege Program Prover</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>3.3</level>
      <title>KeY System</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>3.4</level>
      <title>Perfect Developer</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>3.5</level>
      <title>PVS Specification and Verification System</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>x</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4</level>
      <title>Examples</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.1</level>
      <title>Criteria</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Installation</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>General support</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.2</level>
      <title>Methodology</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Weakest preconditions</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3</level>
      <title>Frege Program Prover</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3.2</level>
      <title>Division</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3.4</level>
      <title>Fibonacci numbers</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3.5</level>
      <title>Inconsistency test</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3.6</level>
      <title>Multiplication</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3.7</level>
      <title>False theorem test</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3.8</level>
      <title>Correct theorem test</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.3.9</level>
      <title>Conditional weakest precondition</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.4</level>
      <title>KeY System</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>} }</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.4.2</level>
      <title>Conditional</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.4.3</level>
      <title>Division</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>} }</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.4.4</level>
      <title>Factorial</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>} }</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.4.5</level>
      <title>List maximum</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>} }</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.4.6</level>
      <title>Multiplication</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.4.7</level>
      <title>Prime</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>} }</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5</level>
      <title>Perfect Developer</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5.2</level>
      <title>Factorial</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5.3</level>
      <title>Intersection</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5.4</level>
      <title>Inversions</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5.5</level>
      <title>List maximum</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5.6</level>
      <title>Multiplication</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5.7</level>
      <title>Prime</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.5.8</level>
      <title>Quicksort</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.6</level>
      <title>PVS Specification and Verification System</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>END fac</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.6.3</level>
      <title>Inversions</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.6.4</level>
      <title>Multiplication</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>4.6.5</level>
      <title>Quicksort</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <title>Analysis</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
    <Section>
      <level>5</level>
      <title>Summary</title>
      <referenceIds/>
      <referenceCitations/>
    </Section>
  </sections>
  <citationContexts/>
  <references>
    <Reference>
      <id>ref1</id>
      <referenceIdString>b0</referenceIdString>
      <title>Bernhard Beckert, Martin Giese, Elmar Habermalz, Reiner Hähnle, Andreas Roth, Philipp Rümmer, and Steffen Schlager. Taclets: A new paradigm for constructing interactive theorem provers</title>
      <source>Redmill and Anderson, editors, Proceedings of the Twelfth Safety-Critical Systems Symposium</source>
      <authors>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Baar</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Beckert</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Bubel</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Giese</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Hähnle</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Menzel</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Mostowski</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Roth</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Schlager</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Schmitt</lastName>
        </ReferenceAuthor>
      </authors>
      <note>Special Issue on Symbolic Computation in Logic and Artificial Intelligence. Alan Bundy. The Paradox of the Case Study. URL http://www-unix. mcs.anl.gov/AAR/issuesept04/index.html#paradox. Edmund Clarke and Xudong Zhao. Analytica-A Theorem Prover for Mathematica. The Mathematica Journal, 3:56-71, 1993. David Crocker. The Perfect Developer Language Reference Manual, September 2001. David Crocker. Developing Reliable Software using Object-Oriented Formal Specification and Refinement. Escher Technologies Ltd., 2003a. David Crocker. Perfect Developer: A tool for Object-Oriented Formal Specification and Refinement. Tools Exhibition Notes at Formal Methods Europe, 2003b. 83 David Crocker. Automated Reasoning in Perfect Developer. Escher Technologies Ltd.</note>
      <pageFrom>800</pageFrom>
      <pageTo>808</pageTo>
      <publicationDateString>1998</publicationDateString>
      <publicationYear>1998</publicationYear>
      <type>m</type>
      <publication reference="/Publication[1]"/>
    </Reference>
    <Reference>
      <id>ref2</id>
      <referenceIdString>b1</referenceIdString>
      <source>David Gries. The Science of Programming</source>
      <publisher>Springer-Verlag</publisher>
      <authors/>
      <note>Predicate Calculus and Program Semantics. Springer-Verlag, 1990. Melvin Fitting. First-order logic and automated theorem proving. SpringerVerlag, 1990. ISBN 0-387-97233-1. Carsten Freining, Stefan Kauer, and Jürgen Winkler. Ein Vergleich der Programmbeweiser FPP, NPPV und SPARK. Ada-Deutschland-Tagung 2002, pages 127-145, 2002. ISSN 1433-9986. URL http://psc.informatik. uni-jena.de/Fpp/fpp-intr.htm#references. Jean Gallier. Logic for Computer Science: Foundations of Automatic Theorem Proving. Wiley, 2003. URL http://www.cis.upenn.edu/ ∼ jean/ gbooks/logic.html. John Gannon, James Purtilo, and Marvin Zelkowitz. Software Specification: A Comparison of Formal Methods. International Specialized Book Service Inc., September 1993. Gerhard Gentzen. UntersuchungenüberUntersuchungen¨Untersuchungenüber das logische Schließen. Mathematische Zeitschrift, 39</note>
      <publicationDateString>1989</publicationDateString>
      <publicationYear>1989</publicationYear>
      <type>m</type>
      <publication reference="/Publication[1]"/>
    </Reference>
    <Reference>
      <id>ref3</id>
      <referenceIdString>b2</referenceIdString>
      <title>Springer-Verlag. Tony Hoare. An axiomatic basis for computer programming</title>
      <source>Higher Order Logics: 11th International Conference, TPHOLs &apos;98, volume 1479 of Lecture Notes in Computer Science, pages 123-142</source>
      <authors>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Isabelle</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Hol</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Newey</lastName>
        </ReferenceAuthor>
      </authors>
      <volume>12</volume>
      <note>Communications of the ACM. 576-580, 1969. ISSN 0001-0782. doi: http://doi.acm.org/10.1145/363235.363259. Tony Hoare. The verifying compiler: A grand challenge for computing research. J. ACM, 50(1):63-69, 2003. ISSN 0004-5411. doi: http: //doi.acm.org/10.1145/602382.602403. 84</note>
      <publicationDateString>1998</publicationDateString>
      <publicationYear>1998</publicationYear>
      <type>m</type>
      <publication reference="/Publication[1]"/>
    </Reference>
    <Reference>
      <id>ref4</id>
      <referenceIdString>b3</referenceIdString>
      <title>ISBN 0 521 54310X. Cliff Jones. The Early Search for Tractable Ways of Reasoning about Programs. IEEE Annals of the History of Computing</title>
      <source>ICSE &apos;03: Proceedings of the 25th International Conference on Software Engineering, pages 660-667</source>
      <authors/>
      <note>and Mark Ryan. Logic in Computer Science: Modelling and Reasoning about Systems</note>
      <publicationDateString>2003</publicationDateString>
      <publicationYear>2003</publicationYear>
      <type>m</type>
      <publication reference="/Publication[1]"/>
    </Reference>
    <Reference>
      <id>ref5</id>
      <referenceIdString>b4</referenceIdString>
      <source></source>
      <authors>
        <ReferenceAuthor>
          <firstNames>
            <string>Omg</string>
          </firstNames>
          <lastName>Www</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Org</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Docs</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Ptc</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>03</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>10</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames>
            <string>Pdf</string>
          </firstNames>
          <lastName>14</lastName>
        </ReferenceAuthor>
      </authors>
      <publication reference="/Publication[1]"/>
    </Reference>
    <Reference>
      <id>ref6</id>
      <referenceIdString>b5</referenceIdString>
      <title>Sam Owre and Natarajan Shankar</title>
      <source>11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial Intelligence, pages 748-752</source>
      <authors>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Specification</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>2003b</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Http</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames>
            <string>Uml</string>
          </firstNames>
          <lastName>Www</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Org</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames>
            <string>0</string>
          </firstNames>
          <lastName>#uml2</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Owre</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Rushby</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Shankar</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>Pvs</lastName>
        </ReferenceAuthor>
        <ReferenceAuthor>
          <firstNames/>
          <lastName>System</lastName>
        </ReferenceAuthor>
      </authors>
      <note>Gernot Salzer. Theoretische Informatik 1. Institute of Computer Languages</note>
      <publicationDateString>2002</publicationDateString>
      <publicationYear>2002</publicationYear>
      <type>m</type>
      <publication reference="/Publication[1]"/>
    </Reference>
    <Reference>
      <id>ref7</id>
      <referenceIdString>b6</referenceIdString>
      <source>Comparing Two Inductive Proof Systems. Institute of Computer Languages</source>
      <authors/>
      <publicationDateString>2004</publicationDateString>
      <publicationYear>2004</publicationYear>
      <type>m</type>
      <publication reference="/Publication[1]"/>
    </Reference>
  </references>
</Publication>