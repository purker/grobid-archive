<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">U</forename><surname>Wien</surname></persName>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Sections M. Anton Ertl *</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>A section is a contiguous region of memory, to which data or code can be appended (like the Forth dictionary). Assembly languages and linkers have supported multiple sections for a long time. This paper describes the benefits of supporting multiple sections in Forth, interfaces and implementation techniques. • You put B in allocated memory. Unfortunately , that usually means that B does not survive a savesystem, and it&apos;s also cumbersome if B is a growable structure. 1 Introduction A section is a contiguous memory area, to which new data can be appended at the end; the Forth dictionary is a section. Assemblers and linkers have supported multiple sections or segments for many decades [Lev00]. In contrast, Forth traditionally has had only one section; some systems have had separated headers (another section), and cross-compilers have uninitialized memory for buffer:, but by and large, Forth systems have made do with just one section: the dictionary. With multiple sections, each section has it&apos;s own start, dictionary pointer (what here reads), and end (used in unused, but otherwise not used much). This paper presents various uses of sections and why they are better than the current workarounds (Section 2), presents a programming interface (Sec-tion 3), and discusses various implementation approaches (Section 4).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Uses</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Nested structures</head><p>A particular instance of this problem is when A is a colon definition under construction, and B is the data for a string or floating-point literal. Forth compilers traditionally work around this by not re- quiring contiguity.</p><p>A typical solution is to call a word such as (s") or flit, and follow that with the inline data. These words get the return address from the return stack, use that to push the relevant data on the data/FP stack, then increment the return address to skip over the data, and then either return to the changed return address or jump to it. Both ways are very ex- pensive on modern CPUs, because they cause mis- predictions from the hardware return stack 1 : If the changed address is returned from, the return incurs a branch misprediction (about 20 cycles on a mod- ern Intel or AMD CPU); if the changed address is jumped to, the jump has a chance to predict cor- rectly, but all outer returns will mispredict once (at about 20 cycles per misprediction).</p><p>A faster approach is to jump across the data, and then let some code push the data on the data/FP stack. This does not cause significant mispredic- tions, but the code is bigger (jump plus inlined lit- eral code).</p><p>Finally, if you put the data elsewhere (i.e., a dif- ferent section), you get fewer mispredictions, and you save the space for the jump around the data.</p><p>As an example of the benefit of putting the data out-of-line, consider the following micro- benchmark:</p><p>You often build one structure A in memory, and in the middle of that, have to build some out-of-line part B, and afterwards continue building A. If you have two sections, that is easy: you put A in one section, and B in the other section. branch mispredictions per iteration. If VFX would put the floating-point number in foo1 in a separate section instead of inline, it could achieve the same performance as foo2.</p><p>Quotations are another case of having to build something else in the middle of a colon definition; in this case the "something else" is a colon defini- tion itself. Again, the usual implementation is to jump around it (used in, e.g., Gforth), and putting the quotation in a separate section can save that overhead. In this case, however, two sections are not sufficient, as quotations can be nested arbitrar- ily deeply, so you need a whole stack of sections.</p><p>Locals are another case where you have to build some additional stuff (in this case, headers) in the middle of a colon definition; the headers are no longer needed at the end of the colon definition and their space can be reclaimed, so the usual inline- and-skip approach is particularly inefficient here. Locals in Gforth were developed before sections, and the code for dealing with that problem is com- plicated; we foresee it becoming much simpler once we take advantage of sections, but we have not made these changes yet.</p><p>One way of implementing recognizers is to create a temporary word for each recognized string, then treat the temporary word like an ordinary word (i.e., execute or compile, it), and finally, delete the temporary if no longer needed <ref type="bibr">[Ert16]</ref>. With sections, this is relatively straightforward to imple- ment (especially the case when you cannot delete the "temporary" and have to make it permanent). With sections, the data can just stay in the or- dinary dictionary section, and the code can have a separate section (or a stack of them, for quotations), thus separating code and data for good. Moreover, systems can get rid of all the padding they insert at the moment to work around this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Further uses</head><p>The uses above are not an exhaustive list. When I presented sections to other Gforth developers, they came up with uses I had not thought of during de- velopment (e.g., simplifying the locals implementa- tion).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Progamming interface</head><p>In the following, "switching a section" means that the dictionary pointer (what here reports, and where allot allocates) is now the dictionary pointer of the switched-to section. switch the current section to the first section of name if there is no outer call to name, or the next section if there is; execute xt, and switch the current section back on leaving name.</p><p>For multi-tasking, the dictionary and the named section stacks should have per-task instances that are instantiated on-demand.</p><p>Currently the section implementation in Gforth only supports the dictionary as a section stack, named sections without stack, and no proper han- dling of per-task section stacks, yet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="0">value x</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>2 I use VFX for the performance results in this paper, because it is a high-performance system, where one would expect good performance also for the micro-benchmarks I present.</p><p>The implementation of sections for use within a ses- sion is pretty straightforward: Just a data strucand ways to manage named sections and a stack of sections.</p><p>Things get more interesting when it comes to im- plementing savesystem. There are two basic op- tions:</p><p>The interface for working with sections is simple, consisting of just a few words.</p><p>The implementation is not that complex, either. Dealing with sections across savesystem does take some additional effort, however.</p><p>• Keep all the sections, and preserve them into the next session.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>References</head><p>• Collapse all the sections into one (the dictio- nary), and start the next session with just the dictionary, and with empty named sections. <ref type="bibr">[Ert16]</ref> M. Anton Ertl. Recognizers: Arguments and design decisions. In 32nd EuroForth Conference, 2016.</p><p>The current implementation in Gforth takes the collapsing approach. One advantage is that the loader (which does not know about sections) does not need to be changed.</p><p>Traditionally, Gforth creates a relocatable image by running Gforth twice and doing the same things, and finally saving one non-relocatable image per run; the non-relocatable images are for different ad- dresses, and by comparing them, we can tell if a cell is an address (then they differ by the difference in image start addresses), or something else (then they do not differ); if they differ, but by a different amount (e.g., because the cell contains the address of an allocated piece of memory), the process out- puts a warning.</p><p>With sections, this process had to be enhanced as follows: When saving an image, first the dictio- nary is written, then the other sections, and sec- tions meta-data last. The sections meta-data con- tains the length and the original start address of each section, and also allows us to determine where in the non-relocatable image the sections are. If two cells differ, the comparison program looks for each image, whether the value of the cell, interpreted as address points into one of the sections, and com- putes the offset into the collapsed image from that; if, for both images, this gives the same offset o, then the cell is a relocatable address, with value image- start +o, and that's what the comparator stores in the relocatable image. I.e., in the relocatable image, the original section structure is no longer present.</p><p>Of course, that is not the only option. E.g., a system without relocatable images could just save each section as ELF or COFF section with a fixed virtual start address. The OS loader would then load all the sections where they belong (untested). <ref type="bibr">[Lev00]</ref> Levine. Linkers and Loaders. Morgan Kaufmann, San Francisco, 2000.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>Supporting multiple sections in a Forth system pro- vides a number of benefits. Forth systems have used workarounds to deal with the absence of sections, but these workarounds have a cost both in complex- ity and sometimes also in performance that can be eliminated by adding sections.</p></div>		</body>
		<back>
			<div type="references">

				<listBibl/>
			</div>
		</back>
	</text>
</TEI>
