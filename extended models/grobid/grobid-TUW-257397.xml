<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Raab</surname></persName>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Unanticipated Context Awareness for Software Configuration Access using the getenv API /phone/call/inpocket/vibration = off /phone/call/notinpocket/vibration = on</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Configuration files, command-line arguments and environment variables are the dominant tools for local configuration management today. When accessing such program execution environments, however, most applications do not take context , e.g. the system they run on, into account. The aim of this paper is to integrate unmodified applications into a coherent and context-aware system by instrumenting the getenv API. We propose a global database stored in configuration files that includes specifications for contextual interpretations and a novel matching algorithm. In a case study we analyze a complete Debian operating system where every getenv API call is intercepted. We evaluate usage patterns of 16 real-world applications and systems and report on limitations of unforeseen context changes. The results show that getenv is used extensively for variability. The tool has acceptable overhead and improves context-awareness of many applications. 1 Introduction The goal of context-oriented programming (COP) is to avoid the tedious, time-consuming and error-prone task of implementing context awareness manually, and instead adapt the application&apos;s behavior using the concept of layers [1, 12]. Each layer represents one dimension of the context relevant to the application. Contextual values [27] act as variables whose values depend on layers. A program execution environment consists of the environment variables and key/value pairs retrieved from configuration files. A program execution environment can be tightly integrated with contextual values [21]. Context awareness [5] is a property of software and refers to its ability to correctly adapt to the current context. Our aim is to make applications context-aware that previously were not. For example, an important context for a browser is the network it uses. In a different network, different proxy settings are required to successfully retrieve a web page. We want the browser to automatically adapt itself to the network actually present, i.e., make it context-aware in respect to the network. Markus Raab Institute of Computer Languages, Vienna University of Technology e-mail: markus.raab@complang.tuwien.ac.at 2 Markus Raab Although COP eases the writing of new software, there remains a huge corpus of legacy software that cannot profit from context awareness. Our paper aims at intercepting the standard API getenv in a way that COP-techniques are applied to unmodified applications. We focus on getenv because we found that it is used extensively. Our interception technique, however, does not make any assumption on the API. We recommend to specify the values and the context of the program execution environments separately. This configuration specification contains place-holders, each representing a dimension of the context: [/phone/call/vibration] type=boolean context=/phone/call/%inpocket%/vibration In this example, vibration is a contextual value of type boolean and %inpocket% a placeholder to be substituted in contextual interpretations. Thus, the value of vibration changes whenever inpocket changes. E.g., when a context sensor measures body temperature only on one side of the gadget, it will change the value of %inpocket%. Thus, when the mobile phone is in the pocket, it will turn on vibration. When the mobile phone is lying on a table, it will turn off vibration to prevent falling down when someone calls. If needed, users can even specify further context. For example , some users dislike the context-dependent feature as described. Our approach inherently allows users to reconfigure every parameter in every context. To turn on vibration if the phone is not in the pocket, we configure our device differently: In this paper we analyze the popular getenv() API. The function getenv() is standardized by SVr4, POSIX.1-2001, 4.3BSD, C89, and C99. Because of this standardization and ease of use it is adopted virtually everywhere, even in core libraries such as libc. It allows developers to query the environment. Using standard getenv implementations developers have to act carefully: settings valid in the current context can differ from those received through getenv. To reduce the danger of assuming wrong context information we propose to use a context-aware implementation. We implement it in the whole system by intercepting every getenv API call.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>Context-oriented programming (COP) enables us to naturally separate multi-dimen- sional concerns <ref type="bibr">[5,</ref><ref type="bibr">24,</ref><ref type="bibr">26]</ref>. In some sense it extends object-oriented programming. Activation and deactivation of layers belong to its main concepts. Every layer rep- resents a dimension of context that cuts across the system. All active layers together form the context the program currently is in.</p><p>The (de)activation of layers occur at any time during program execution. A cur- rently active stack of layers determines the context the program or thread is in. COP allows us to specify programs with adaptable, dynamic behavior. Later ap- proaches <ref type="bibr">[14]</ref> go beyond object-oriented programming: they support program con- struction with layers only. Furthermore, later work considers software engineering perspectives <ref type="bibr">[24]</ref> and modularity visions <ref type="bibr">[13]</ref>.</p><p>Tanter suggested a lightweight subset of COP: Contextual values. They are eas- ier to understand because they "boil down to a trivial generalization of the idea of thread-local values" <ref type="bibr">[27]</ref>. They are variables whose values depend on the current context. Contextual values originate from COP and naturally work along with the concepts of dynamic scoping and layers.</p><p>For newly written context-aware software, COP is a viable choice. For legacy software, however, rewriting seems unrealistic. So in this paper we introduce a new approach that does not require modifications of the application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EnvElektra</head><p>In our approach, we want to intercept every call to the getenv API. Whenever an ap- plication calls the API, we want to invoke a context-aware implementation instead. EnvElektra, which is our research tool, contains such a getenv() implementation. The implementation contains a novel matching algorithm for context awareness. When EnvElektra is installed and activated on a system, the matching algorithm will be used for every call of getenv() done by any application.</p><p>The basic idea of EnvElektra's getenv() implementation is as follows: First, it ensures that the data structure is up-to-date. Second, the matching algorithm cal- culates a new key for the parameter of getenv() using the context specification. Third, this key is searched in the data structure. With the found key, we recursively descend until every relevant context is considered.</p><p>The library LibElektra <ref type="bibr">[21]</ref> (shown in <ref type="figure">Fig. 1</ref>) maps the program execution envi- ronments (e.g., command-line arguments and configuration files) to the in-memory key/value pairs. LibElektra includes start-up code that initializes all key/value pairs from a key database. The key database is modular via plugins <ref type="bibr">[18]</ref>. The plugins allow us to use different syntax for configuration files.</p><p>Fig. 1 also depicts the EnvElektra architecture. The system with EnvElektra has to provide three artifacts (bold, blue boxes): process layer (de)activation. In the remainder of this chapter we will explain the user-provided artifacts and the matching algorithm. Finally, we will give a full ex- ample demonstrating how the system works interconnected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Context Sensors</head><p>An essential issue to enjoy global, context-aware configuration access without mod- ifying the application is an out-of-process layer (de)activation. We will show why such context sensors require us to use a database.</p><p>The original function getenv() retrieves values from the environment. Inter- nally, it uses the data structure char ** environ. By design, environ is copied into every process and will not receive any external changes afterwards. Thus, environ cannot consider out-of-process changes and cannot be used in EnvElektra.</p><p>We prefer to use configuration files that are read by the application itself. Then security is correctly handled by the operating system. In EnvElektra the adminis- trator decides which configuration files are used, possibly with different syntax for each file <ref type="bibr">[20]</ref>. EnvElektra makes sure that all applications have the same global view of the system's configuration files leading to a consistently configured system. This way values returned by getenv() will not be different from values retrieved from configuration files. The configuration files are viewed as a key/value database</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head><p>Context sensors observe the system and change the database when they detect context changes. They are responsible to modify the layers accordingly. Context sensors write their layer information into /env/layer. The key /env/layer is part of the database and resides within one of the configuration files. The use of files en- ables out-of-process communication between context sensor and applications. Thus, context changes can have an immediate effect on applications. We identified two different kinds of context sensors to be used with our approach:</p><p>Information within the Database: Quite often, the necessary value is already present in the database. For example, in Linux many syscalls and the /sys-file sys- tem already provide much information. Using plugins, these sources are easily em- bedded within the database. Then we only need a symbolic link from /env/layer to the correct key. For example, if /env/layer/nodename points to /syscall/uname/ nodename, then %nodename% will resolve to the nodename as returned by the uname system call. In EnvElektra we mount plugins into any part of the hierarchy <ref type="bibr">[18]</ref>.</p><p>Context Sensor Daemons: In other cases, we implement a daemon, i.e. an ac- tive process, that updates /env/layer. Doing so, we can implement hysteresis, value transformations, and even complex feedback control systems. For exam- ple, to update %inpocket% a daemon measures the temperatures and modifies /env/layer/inpocket whenever we cross a threshold value. Changes in the data- base influence all processes across the whole system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Context Specification</head><p>Up to now, we have established a database that contains key/value pairs to be used in a getenv() implementation. We have to make the database context-aware with the layer-information present in /env/layer, e.g.:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>/env/layer/inpocket = notinpocket</head><p>Furthermore, we specify which key is used in which contextual interpretation: <ref type="bibr">[/phone/call/vibration]</ref> type=boolean context=/phone/call/%inpocket%/vibration Now, when an API accesses /phone/call/vibration, the lookup layer will search for /phone/call/%inpocket%/vibration. Layer interpretations are stored in the database below the key /env/layer. In this case the correct contextual in- terpretation of %inpocket% is notinpocket. Using more than one placeholder cre- ates several dimensions of variability. Late-binding is necessary so that unmodified software benefit from contextual features. EnvElektra needs to resolve its context awareness as late as possible, i.e., on getenv() calls.</p><p>For example, if a phone-call application executes getenv("vibration") it will look up /phone/call/vibration. Because of the context specification, we know we want the key /phone/call/%inpocket%/vibration instead. For the correct interpretation of %inpocket% we will lookup /env/layer/inpocket first. We get the value notinpocket for the layer %inpocket%. Thus, getenv <ref type="bibr">("vibration")</ref> will return the value of /phone/call/notinpocket/vibration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Matching algorithm</head><p>The core of our approach is the contextual lookup within our alternative imple- mentation of the getenv API. In EnvElektra getenv() provides the context-aware variability.  <ref type="figure">key) {  if(needsReload(conf)) {  reloadConfiguration(conf);  reloadLayers(conf);  }  return contextLookup(conf, key);  }</ref> Context is not static but dynamically changes over time. Our approach sup- ports dynamic changes of context using reloadLayers() even though the original getenv implementation did not. The interception approach limits us to context- changes within getenv(): We cannot (de)activate layers at other places. Instead, we make sure that for every contextLookup() the correct context is used.  <ref type="figure">, key, "context");  if (m) return contextLookup (cfg, fix(m));  else return lookup (cfg, key);  }</ref> The idea of the algorithm is: First, we look whether a context is specified for the key. If it is, contextLookup descends recursively after replacing all placeholders in the key. If it is not, a ordinary lookup will be used. The full implementation features namespaces, symbolic links and defaults <ref type="bibr">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Example</head><p>We present a full example that demonstrates recursion with several layers. Suppose a mobile phone is lying on the table in a building during a meeting. To simplify the example, we assign constant values to the layers:</p><p>/env/layer/inpocket = notinpocket /env/layer/inbuilding = inbuilding</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7</head><p>In a real system, a sensor will continuously update the values. So far, we already discussed the layer inpocket. The layer inbuilding represents a value from a location context. Layers such as inmeeting are called virtual sensors <ref type="bibr">[1]</ref>. In this case the value of the layer is calculated by a sensor querying the person's schedule. The application running on the phone uses the following non-context-aware code: char * use_vibration = getenv("vibration"); if (!strcmp(use_vibration, "on")) {/ * activate vibration * /} We add context awareness with the following specification: <ref type="bibr">[/phone/call/vibration]</ref> type=boolean context=/phone/call/%inbuilding%/vibration [/phone/call/inbuilding/vibration] type=boolean context=/phone/call/%inpocket%/%inmeeting%/vibration [/phone/call/notinbuilding/vibration] type=boolean context=/phone/call/%handsfree%/vibration Due to lack of space, we here specify only two of the six possible configurations:</p><p>/phone/call/inpocket/inmeeting/vibration = on /phone/call/notinpocket/inmeeting/vibration = off Suppose the mobile phone gets a call. By above getenv we request to lookup /phone/call/vibration to know whether vibration is turned on. In the first step, it will find the context and resolve inbuilding. In the next step, it will recursively search in the specification again, and find another context with /phone/call/ %inpocket%/%inmeeting%/vibration. Then the placeholders are again replaced with the respective values. Resolving this key, the algorithm will not find an- other matching specification. Thus, it returns the configuration value of not in pocket and in meeting, i.e., /phone/call/notinpocket/inmeeting/vibration. Because this configuration value is off, the phone will not vibrate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>Our methodological foundation is built on "theory of cases" <ref type="bibr">[6,</ref><ref type="bibr">7]</ref>. Other research should supplement our work with further case and user studies.</p><p>We chose 16 popular systems for evaluation (as discussed in threats to validity in Section 5). We will solely focus on existing applications and their integration into a coherent system.</p><p>The evaluation was conducted on different machines using Debian GNU/Linux Jessie 8.1 amd64. For the evaluation we globally intercept getenv() using /etc/ld .so.preload. By listing EnvElektra in /etc/ld.so.preload it will be loaded be- fore any other library. Thus its symbols will be preferred. Because of this preference EnvElektra will be used for every getenv()-call.</p><p>In each of the following subsections, we will answer one of the questions:</p><p>RQ1: What are the usage patterns of getenv() in popular applications? RQ2: For which applications can we actually exploit getenv() to be used for unanticipated context awareness? What are the fundamental limitations? RQ3: What is the overhead that occurs in a system using EnvElektra?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">RQ1: Usage Patterns</head><p>Only APIs that are actually called during runtime can be exploited for context awareness. To learn more about usage patterns, we count how often getenv(key) is executed. the above applications can be started within the same session. lines of code: Count lines of code with the tool cloc. getenv all: Count all calls to getenv while using the application. getenv init: Count all calls to getenv while starting the application. all unique: From all getenv calls, how many different keys were used? later unique: From getenv calls after initialization, how many different keys were used? For wget and curl the first download counts as initialization. same: From the getenv calls during startup (during runtime an arbitrary high num- ber could be acquired), what is the maximum number of queries with the same</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>application</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9</head><p>To interpret the numbers correctly we have to know that the usage patterns vary widely even for the same application. For example, firefox started within GNOME requests 11 GNOME specific and 8 GTK specific environment variables (like G_DEBUG). If executed on a system with OpenGL enabled, 43 additional en- vironment variables (like __GL_EVENT_LOGLEVEL) are used to determine OpenGL configurations. Additionally, the tested system requested three vendor (NV) specific variables. For KDE, KDE_FULL_SESSION was used as detection. Then 8 more KDE- specific and 15 more QT-specific environment variables were requested if started within KDE. Thus, the numbers depend on the desktop environment and hardware.</p><p>For better reproducibility, we freshly installed Debian Jessie KDE and GNO- ME variants, respectively. The only modification was the installation of EnvElektra. For example, on a daily used KDE with many installed applications, we measured 210.276 getenv() during startup, which is 21 more than with a freshly installed KDE. We see that the numbers also depend on the installed software.</p><p>The above 13 applications request an average of 2969 environment values (2790 median). Akonadi, configured to use IMAP, had the highest number of calls to getenv. The reason seems to be a potential misuse of a libc function which re- quested LANGUAGE 5126 times. During the KDE startup 27% of all getenv calls were LANGUAGE. We conclude that excessive use can be unintentional.</p><p>From the numbers in the table we conclude that getenv() is used extensively in all examined applications. Applications often reread environment parameters during user interactions. This statement is true for both large applications and small helper tools. As expected, large feature-rich applications request much more environment variables. The ratios of requested and unique environment variables varies greatly: it is 14% median, and in akonadi it is ∼ 1%. We see that applications tend to request the same variables often.</p><p>Our findings regarding RQ1 are: <ref type="bibr">(1)</ref> We quantitatively show that getenv() is pervasive. We think that the usage patterns stem from a rather random use of getenv(): variability seems to be added ad-hoc whenever single developers needed it. Because getenv() has no noticeable performance implication and typically is not unit-tested, it is likely that quality assurance will not find unnecessary occurrences. (2) Based on our observation, getenv() is used frequently after startup. Implications: Developers seem to not optimize calls to getenv(). The re- sulting high number of getenv()-calls open up possibilities to influence the behavior of applications on context changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ2: Unanticipated Context Awareness</head><p>We already showed that the use of getenv() is pervasive, even after startup. Now, we want to find out whether changes in the context -and thus in the variables returned by getenv() -actually have an influence on the behavior.</p><p>We found that in help-, save-and open-dialogs different values returned by getenv() often influence the behavior of the application in a way easily visible to the user. These environment variables often have immediate and visible im- pact when changed dynamically. For example, gimp uses for every open dialog G_FILENAME_ENCODING and for every help dialog GIMP2_HELP_URI. On context changes, e.g. when we enter another network or mount a new file system, the soft- ware can automatically be adapted with EnvElektra.</p><p>Now, we investigate context awareness of proxy settings. A user changing the network with a different proxy should be able to continue browsing. lynx requests and correctly uses http_proxy for every single page. curl has the same behavior and reloads 7 additional environment variables every time. wget gives less control per download but still requests http_proxy for every page in recursive download- ing mode. Firefox uses the proxy for most pages but pages in cache are displayed even when the proxy is unreachable. Chromium is the only browser not rereading http_proxy. Instead, it requests many internals such as GOOGLE_API_KEY during run-time. EnvElektra supports http_proxy well.</p><p>Our approach is very successful whenever an application executes other pro- grams because during the startup of the programs the whole environment is always requested and used. Many programs use a pager or editor as external program. For example, man executes a pager for every displayed manpage.</p><p>For some applications it is possible to specify a configuration file using an envi- ronment variable. In EnvElektra configuration files can be mounted. Then they are a part of the database, which permits full configurability. For example, less executed within man uses the environment variable LESSKEY. In such cases our approach pro- vides seamless context-aware configuration.</p><p>Some getenv() calls, however, do not have any user-visible impact. Instead, they seem to be left-overs. In LibreOffice, WorkDirMustContainRemovableMedia is obviously a workaround for a very specific problem. It is not documented and searching the web for it only reveals the use in the source code. Instead, OOO_ENABLE_LOCALE_DATA_CHECKS is an announced workaround. In GTK GTK_ TEST_TOUCHSCREEN is requested extensively. According to the commit log it was explicitly introduced as a test feature.</p><p>Sometimes recurring getenv cannot be exploited to improve context awareness. For example, LANGUAGE is requested very often but does not influence the user- interface after startup. Here changes at runtime seem to have no impact. Such envi- ronment variables will only be context-aware during the start of an application.</p><p>A limitation of our approach is the impossibility to detect unwanted changes of environment variables. For example, the environment variable CC can change during</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11</head><p>In EnvElektra the runtime-context-change feature can easily be (de)activated for process hierarchies, though.</p><p>Not a single crash occurred in our experiments regardless of which values we modified. This behavior is not entirely surprising: First, software should validate values returned from getenv(). Thus, wrong values from getenv() are rejected. Second, we did no systematic stress testing but only searched for useful changes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ3: Overhead</head><p>Finally, we want to evaluate whether the overhead of EnvElektra is acceptable. The benchmarks were conducted on a hp</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R</head><p>EliteBook 8570w using the central processor</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>unit Intel</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R Core</head><p>TM i7-3740QM @ 2.70GHz. Overhead is measured with valgrind by running the executable without and with EnvElektra. The glibc getenv() implementation linearly searches through the whole envi- ronment. On the one hand, our implementation does not have this constraint. Its complexity is O(log(n)) compared to O(n) for environ iteration. We do not use unordered hash maps because we need lexically ordered iteration, e.g. to iterate over all layers and during reloadConfiguration(). On the other hand, the con- textual lookup involves recursion. Depending on the specification EnvElektra needs additional nested lookups. Regarding the overall overhead, we first report about the diversity of the applica- tions. For the startup of gimp the overhead of 2.6% is negligible. For the startup of firefox, however, the overhead is 6.5%. The reason is that Firefox performs exec() 5 times during startup. Then EnvElektra needs to be initialized and needs to parse its configuration files again. For very small applications, e.g. curl and wget, the pars- ing strongly affects the runtime overhead. If they download empty files, the overhead even dominates. The overhead between different applications varies greatly.</p><p>Next, we were interested in the impact on a system which executes many pro- cesses each with trivial tasks. An extreme example happens to be the compilation of C software projects with gcc. Because gcc spawns 5 subprocesses for the compila- tion of every .c file, the overhead seems to get immense. Actually, the overhead of a trivial program's compilation, only containing int main(){}, is 90%. The parsing of configuration files gets dominant. It is astonishing that the overhead of a compila- tion for a full project is only 14%. For this benchmark we compiled EnvElektra from scratch. The absolute times are 2:23 min total when compiling with EnvElektra and 2:05 min total without EnvElektra as measured with the time utility. The compila- tion executed 6847 processes, did 30862 getenv calls, 6199 of which contained CC. Even though trivial process executions have large overhead, the overall performance only suffers little, even in extreme cases.</p><p>We further were very interested in any other occurrence with a similar number of many process executions. The booting of Debian executes 732 processes. The most often requested environment variable was SANE_DEBUG_SANEI_SCSI with 286 oc- currences. In the script startkde, 227 binaries are executed. The executed number of processes in the case of compilation actually seems to represent an exception. We conclude that occurrences where processes are spawned excessively are rare.</p><p>Finally, we want to discuss the overhead of the reload feature. We chose the following setup: We installed the webserver lighttpd locally. EnvElektra was ac- tive throughout the whole experiment. To download 10 files with 1MB to 10MB size each we executed curl -o "#1 http://localhost/test/ <ref type="bibr">[1]</ref><ref type="bibr">[2]</ref><ref type="bibr">[3]</ref><ref type="bibr">[4]</ref><ref type="bibr">[5]</ref><ref type="bibr">[6]</ref><ref type="bibr">[7]</ref><ref type="bibr">[8]</ref><ref type="bibr">[9]</ref><ref type="bibr">[10]</ref>". With- out reloading this execution resulted in 83,786,947 instructions. With reloading Env- Elektra every millisecond, valgrind counted 91,569,790 instructions. The reloading caused the configuration to be fetched 91 times instead of 4 times. Because of an optimization within EnvElektra only stat is used on the configuration files without parsing them again. Thus, the overhead is only 9.3%.</p><p>Different to the benchmark setup above we will now change the database once during program execution. Then EnvElektra will reread the respective configuration file. We have to take care that the changed value does not influence the control flow. For example, if we add the no_proxy variable, proxy setup is skipped and the performance even increases. Thus, we changed COLUMNS, which is requested for every download but does not influence the overhead more than unrelated parameters. When changing it during one of the ten requests the execution needed 95,248,722 instructions. We see that actual context changes have acceptable overhead of ∼ 4%.</p><p>Our findings regarding RQ3 are: <ref type="bibr">(1)</ref> In applications that terminate very soon, e.g. only showing help text, the run-time overhead dominates. In practical use, however, EnvElektra only adds run-overhead from 2.6% to 14% (in extreme but realistic cases).</p><p>(2) Dynamic reload has about 10% overhead. On context changes the over- head increases again by about 4% in a realistic http-proxy-transition.</p><p>Implications: EnvElektra's run-time overhead typically is low and thus ac</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Threats to Validity</head><p>As in all quantitative studies our concern is if the evaluated software is represen- tative. In RQ1 we address it by using a significant number of diverse open-source software in terms of functionality, development teams and programming languages. We did not consider context awareness already present in applications. Although interception also works for closed-source software, we did not study it because of the impossibility to cross-check with source code. Anyhow some of the software, including libreoffice, chromium and eclipse, has at least origins in closed-source de- velopment. Thus, the results can be valid for closed-source software, too. While we think that the software we inspected represents some characteristics of variability APIs, more general conclusions need further work. In the methodology of RQ2, we need to interpret whether contextual aware- ness can be exploited. We avoid subjective judgements about context awareness during program start. One could also modify the environment with a wrapper script to achieve similar results. We prefer to examine dynamic context changes which are impossible with former approaches. To improve reproducibility and objectivity we only consider visible changes in the user interface.</p><p>We exclusively measure calls of getenv but do not consider the use of the environ pointer, the third parameter of main, and /proc. We cannot guarantee full coverage. Therefore our evaluation actually underestimates the full potential.</p><p>We added optional logging to count the number of getenv. Logging, however, influences a system deeply. On one system two start-processes failed when logging was activated. We did not find other occurrences that caused differences in behavior. Thus, we always rerun our tests without logging.</p><p>The benchmarks are conducted comparatively and consider only a single imple- mentation of getenv. Therefore run-time measurements may not apply for other versions or OSs. Additionally, the benchmarks yield very different results depend- ing on the size of the used configuration files and the respective parser. To level out this problem, we took care that our setup is realistic. We used 8 different configu- ration files and especially chose parsers which are known to be slow. We think that it is straight-forward to reproduce our benchmarks in a way that they perform even better than the numbers we reported.</p><p>Overall, while we cannot draw general conclusions for context-aware configu- ration access in the getenv API, we think that our study unveils some important insights, particularly for open source software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Riva et al. <ref type="bibr">[23]</ref> acquired software-engineering-related knowledge from studying context-aware software. Different from our approach, they reverse-architected ex- isting context-aware support systems. We preferred to study the behaviour of well- known software when introducing context awareness.</p><p>Context-aware middleware <ref type="bibr">[8,</ref><ref type="bibr">9]</ref> is a well-established research direction. Env- Elektra could be seen as local context-aware middleware for configuration. Env- Elektra scores in situations where legacy software needs to be deployed.</p><p>Using the correct context is a subtopic of avoiding configuration errors. Yin et al. <ref type="bibr">[28]</ref> researched different types of configuration-parameter-related mistakes. They investigated value-environment mistakes which can be caused by wrong contextual interpretation. Which errors actually are induced by incorrect contextual interpreta- tion, however, is still an open question.</p><p>A lot of work exists about how to extract program configuration constraints from source code <ref type="bibr">[16,</ref><ref type="bibr">22]</ref>. The authors argue that even though many constraints are ex- tracted, sometimes additional external knowledge is needed. We think that context awareness is such a constraint.</p><p>Context-oriented programming (COP) already has an important role within software-engineering <ref type="bibr">[1,</ref><ref type="bibr">12,</ref><ref type="bibr">24]</ref>. COP mainly aims at more comprehensible pro- grams expressing more context awareness. Our approach tackles the problem in a different direction: We add context awareness without changing the program.</p><p>Previous work <ref type="bibr">[19]</ref> describes context-awareness by using explicit layer activa- tions. Other than our approach, these methods cannot be used for already existing applications.</p><p>Niu et al. <ref type="bibr">[17]</ref> report on a web-based framework which uses indoor location, which is an important context sensor. Software product line engineering <ref type="bibr">[2,</ref><ref type="bibr">25]</ref> deals with the question how to construct products by combining features. Configu- ration specification languages <ref type="bibr">[10,</ref><ref type="bibr">11]</ref> rarely have support for context. An exception is the context oriented component model PCOM <ref type="bibr">[15]</ref>. Unlike our approach, these approaches cannot be used for already existing applications.</p><p>Yuan et al. <ref type="bibr">[29]</ref> provided a quantitative characteristic study for software logging. Similar to our study they revealed that their object of study is used in four large open-source applications pervasively. Different to our approach, they researched how logging statements were introduced and changed, while we show how APIs for variability are intercepted for more context awareness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper, we described a context-aware database using configuration files. A getenv implementation uses it for context-aware configuration access. Applications facilitating this API profit from context awareness. Our approach is unique because it allows applications to be context-aware without any modifications.</p><p>We saw that getenv() in most software provides excessive variability which is currently underutilized. This variability benefits from context awareness. The paper gives ideas for programmers how getenv() can be used with more efficacy. Some- times software is even capable to dynamically adapt to context changes even though</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15</head><p>small synthetic benchmarks the overhead might be devastating, in practice it stays well with reasonable bounds.</p><p>Our results are:</p><p>• Presentation of an approach in which applications are more aware of their context • A novel context-aware getenv() implementation downloadable from http://www.libelektra.org. • Providing experimental validation by a case study of significant complexity.</p><p>Acknowledgements I would like to thank Franz Puntigam, Helmut Toplitzer, Christian Amsüss, Nedko Tantilov and the anonymous reviewers for a detailed review of this paper. Many thanks especially to Natalie Kukuczka and Elisabeth Raab.  <ref type="bibr">(2007) 2. Berger, T., Lettner, D., Rubin, J., Grünbacher, P., Silva, A., Becker, M., Chechik, M., Czar</ref> necki, K.    <ref type="bibr">1408684 28. Yin, Z., Ma, X., Zheng, J., Zhou, Y., Bairavasundaram, L.N., Pasupathy, S.: An empirical</ref> study on configuration errors in commercial and open source systems. In: </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>References 1. Baldauf, M., Dustdar, S., Rosenberg, F.: A survey on context-aware systems. International Journal of Ad Hoc and Ubiquitous Computing 2(4), 263-277</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>.</head><label></label><figDesc>Dey, A.K., Abowd, G.D.: The what, who, where, when, why and how of context-awareness. In: CHI '00 Extended Abstracts on Human Factors in Computing Systems, CHI EA '00. ACM, NY (2000). URL ftp://ftp.cc.gatech.edu/pub/gvu/tr/1999/99-22.pdf 6. Easterbrook, S., Singer, J., Storey, M.A., Damian, D.: Selecting empirical methods for soft- ware engineering research. In: F. Shull, J. Singer, D. Sjøberg (eds.) Guide to Advanced Em</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>1 Architecture of EnvElektra. The common data structure is a set of key/value pairs (middle). Bold, blue boxes need to be provided by users of EnvElektra.</head><label></label><figDesc></figDesc><table>(1) unmodified applications that be-
come context-aware, (2) context specifications, and (3) context sensors for out-of-Fig. LibElektra 

key/value database 

d e l e g a t e w o r k 

unmodified 
applications 

access 

uses 

access 

access 

key/values 

context-aware 
implementation 
of getenv 
API 

plugins 

load, store 
and check 

influences 

access 

context sensors 

config. files 

context 
specification 

is part of 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>The essence of EnvElektra's getenv() implementation is:</head><label></label><figDesc></figDesc><table>char * getenv(char * </table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl/>
			</div>
		</back>
	</text>
</TEI>
