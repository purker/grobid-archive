<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Model-driven Development Meets Security: An Evaluation of Current Approaches</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kresimir</forename><surname>Kasal</surname></persName>
							<email>kkasal@sba-research.org</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">SBA Research</orgName>
								<orgName type="institution" key="instit2">Vienna University of Technology</orgName>
								<orgName type="institution" key="instit3">Vienna University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johannes</forename><surname>Heurix</surname></persName>
							<email>heurix@ifs.tuwien.ac.at</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">SBA Research</orgName>
								<orgName type="institution" key="instit2">Vienna University of Technology</orgName>
								<orgName type="institution" key="instit3">Vienna University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Neubauer</surname></persName>
							<email>neubauer@ifs.tuwien.ac.at</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">SBA Research</orgName>
								<orgName type="institution" key="instit2">Vienna University of Technology</orgName>
								<orgName type="institution" key="instit3">Vienna University of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Model-driven Development Meets Security: An Evaluation of Current Approaches</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Although our society is critically dependent on software systems, these systems are mainly secured by protection mechanisms during operation instead of considering security issues during software design. Deficiencies in software design are the main reasons for security incidents, resulting in severe economic consequences for (i) the organizations using the software and (ii) the development companies. Lately, model-driven development has been proposed in order to increase the quality and thereby the security of software systems. This paper evaluates current efforts that position security as a fundamental element in model-driven development, highlights their deficiencies and identifies current research challenges. The evaluation shows that applying special-purpose methods to particular aspects of the problem is more suitable than applying generic ones, since (i) the problem can be represented on the proper abstraction level, (ii) the user can build on the knowledge of experts, and (iii) the available tools are more efficient and powerful.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The Evaluation Taxonomy</head><p>This section identifies and describes several dimensions in model-based security. The identified dimensions are orthogonal but can still affect each other. For example, if the modeling paradigm is aspect-oriented, one of the artifacts that the method requires is a set of transformation rules that are needed for model weaving. The proposed taxonomy is influenced by the comparison framework developed by Khwaja and Urban (cf. <ref type="bibr">[11]</ref>). The framework was intended for evaluation of specification techniques and was already used by <ref type="bibr">Villarroel et al. (cf. [14]</ref>) to evaluate development methods for secure information systems. Nevertheless, Khwaja and Urban's comparison framework did not cover aspects such as security mechanisms that can be modeled by a specific technique, and it did not classify the distribution of modeled systems, the artifacts that have to be provided by the modeler, or the applied modeling paradigm. Furthermore, there was no differentiation between several possible dimension instantiations that can occur in system verification. Therefore, these issues are handled in the proposed taxonomy. The taxonomy will provide a classification method that can easily be applied by a practitioner when comparing model-driven security methods in order to choose the appropriate one and consists of the following dimensions: Paradigm: This dimension is concerned with the modeling paradigm. In case of model-driven security, two alternatives are possible: In single, possibly hierarchical models, crosscutting concerns are modeled in each place where they are needed, which amounts to a significant redundancy in the overall model. By contrast, in models conforming to aspect-oriented development, crosscutting concerns are described in a separate model to be subsequently woven into (or integrated with) the primary model using so called weaving rules, thus eliminating redundancy. Artifacts: There are three forms of artifacts: (i) Static models describe the static structure of a system such as classes and associations between them; (ii) Dynamic models describe the behavior of a system including interactions or states of entities; (iii) Transformation rules define how models are transformed in the MDA approach and how aspects are woven into aspect-oriented models. Formality: Formal expressions allow for precise, unambiguous and verifiable specifications of models. Design patterns, for instance, are semi-formal models specifying the system's functionality by describing how entities are assembled and interact with each other to form the desired system. Metamodels are grammars describing how valid models are built. Examples of formal modeling techniques are automata, state machines, or logics and calculus systems. Distribution: This dimension deals with the existence of distributed components and their interoperability. Differences are made between single or multi-process systems, where the latter may be distributed over multiple machines acting as autonomous and possibly mobile agents. Different instances of this dimension include client/server constructs, P2P-architectures or multiple agent systems. Granularity: Coarse granularity allows abstracting from details to get a more complete picture of the system, e.g., describing the system as a composition of interacting subsystems where each subsystem consists of several other components that are left outside the scope of the model. Fine-grained models offer a more detailed view, including elements such as classes and interacting functions, but may also be of much higher complexity. Executability: If the model is executable, it contains enough information to be verified without the need to be enriched with additional information, since its semantics is represented in a mathematically precise and unambiguous way. Otherwise, the model could not be executed by a machine. In such a case, it needs to be supplemented with additional data during the transformation process. With executable models, extracting test cases from them and making them executable is a plausible technique for validating the system. Verification: The system's verification can be handled in different ways: While manual testing is error-prone and tedious, automated test case generation is more preferable where we distinguish between (i) deriving both test cases and production code from the same model (ii) and test- specific models being independent from the system built manually. Model checking verifies conformance to a specific requirement, while theorem proving involves verifying whether a theory (system specification) entails a logic formula (requirement). Tool support: If available, tool support includes assisting the user in the modeling process of the system, generating code, checking the system specification's syntax and consistency, as well as checking whether a system is consistent with its specification (verification) and completely fulfills the user requirements (validation). Applicability: In this dimension we differentiate between several application domains for which systems can be specified by applying a particular technique. Examples for application domains are information systems, Web applications, e-commerce systems, embedded systems, etc. Security mechanisms: In this section, security modeling techniques are categorized according to security mechanisms (and thus, indirectly, security requirements) that can be represented and modeled by a particular method. Possible instances for security mechanisms are access control, security protocols and intrusion detection mechanisms. Security mechanisms enforce security requirements. A security aspect represents a particular set of behavior needed by a certain system, as used in aspect- oriented software development (AOSD). A security aspect can represent a security mechanism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Model-driven Security Approaches</head><p>This section presents selected model-driven security and formal method approaches, starting with UMLsec, a hierarchical methodology, followed by interesting aspect- oriented approaches. Finally, general and special-purpose formal techniques will be discussed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">UMLsec (Juerjens 2002)</head><p>UMLsec is a very general and powerful technique. It enhances UML's expressiveness by applying security- related stereotypes, tags, and security constraints. These are used to encapsulate knowledge on prudent security engineering such that developers need not be specialized in the domain of security <ref type="bibr">[3]</ref>. UMLsec is both a modeling language and a methodology, since the corresponding tool suite allows for iterative refinement and adaptation of the system models. UMLsec, as a modeling language, allows the specification of requirements regarding confidentiality, integrity, non-repudiation, and non- interference (secure information flow). These requirements are expressed as stereotypes and tagged values and are translated into constraints that evaluate the security properties of the model, since the author provides a formal semantics for the fragment of UML that is needed for UMLsec. A system is composed of subsystems which are in turn composed of further subsystems or components that can be modeled in the form of class diagrams or state charts. UMLsec can also be applied to model aspects and systems' crosscutting concerns separately. In such a case, the modeler would have to provide transformation (weaving) rules that specify and determine how specific models have to be integrated <ref type="bibr">[15]</ref>. By applying UMLsec, the system can be described on several levels of granularity. Even if there is no consensus on whether UML is an architecture description language (ADL) (cf. <ref type="bibr">[16]</ref>), it can also be used to model system architectures, since package and deployment diagrams can be expressed by using UML and therefore also by UMLsec. Formal semantics was provided <ref type="bibr">[3]</ref> to formally analyze the behavior of interacting components. Because interactions can be specified in UML, distributed systems can be modeled as well <ref type="bibr">[17]</ref>; Juerjens demonstrated this with the TLS security protocol <ref type="bibr">[3]</ref>.</p><p>In UMLsec the modeler has to provide static and dynamic models including secrecy (confidentiality), integrity, non-interference, non-repudiation, data authenticity (can a piece of data be traced back to its original source?), and entity authenticity (can a protocol participant be identified?) as security requirements. Although Juerjens provided a formal basis and thus the foundation for executable UML modeling to simulate whole systems, UMLsec lacks support for exact, traceable and fully automated transition from models to implementation code, thus denying executability. In the meantime, this problem has been solved in the form of a rich toolset making it possible to formally verify the designed models <ref type="bibr">[18]</ref>: With state-of-the-art model checkers and theorem provers, this toolset allows the automatic analysis of exported UML models formatted in XML Metadata Interchange (XMI) format. Although UMLsec was initially intended to tackle the problem of designing secure information systems, the author recently also addressed the development of secure embedded systems (cf. <ref type="bibr">[19]</ref>). As this approach evolves, further application areas may emerge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Secure Software Architectures by Using</head><p>Yu et al. <ref type="bibr">[20]</ref> apply software architecture models (SAM) to define the system's software architecture and the required security aspects. The approach is a formal method for aspect-oriented modeling at an architectural level. SAM is a development framework based on two complementary formalisms: predicate transition nets (also referred to as high-level Petri nets) and temporal logic. Petri nets are used to visualize and describe the high-level static structure of the system, as well as to model the architecture's behavior. Linear temporal logic formulas (LTL) are used to specify the required security properties (that is, security requirements, such as constraints set on the information flow between the interacting components). A consequence of expressing security properties in temporal logic is that policies (i.e., sets of security properties or requirements) are expressed on a very low abstraction level. Expressible policies include safety and liveness properties and variations of these (cf. <ref type="bibr">[21]</ref>). In SAM, a hierarchical set of compositions is used to describe the system. Each composition consists of a set of components, a set of connectors, and a set of constraints that have to be satisfied by the interacting components (cf. <ref type="bibr">[7]</ref>). The approach is well suited for modeling distributed architectures. In the problem domain model, a precise description of the system's functionality is given. Once this model is established, it is divided into the base architecture model and the security aspect model by applying separation of concerns. The base architecture model defines the software architecture of the targeted application, including basic functional modules and their connections. In this model, no security properties (requirements) are specified; these are specified in the security aspect model, along with vulnerabilities, threats, and provided mechanisms that enforce security policies. Thus, security aspects in this context represent components which implement security-relevant features and mechanisms of information systems. A secure architecture model, the result of merging the base architecture model with the security aspect model, is the model where security policies are enforced. As Petri nets are the basis for the modeling formalism, model checking could also be applied to verify security properties (which are represented by LTL formulas). However, the approach lacks any tool support and no significant further work has been done in order to enhance the proposed method. oriented extensions to model attacks and thereby intrusion detection aspects (IDAs) responsible for detecting these attacks. The modeler has to provide static and dynamic views of the system's aspects. Class diagrams are used to represent the system's static attributes, and state machine diagrams are used to represent the dynamic views of intrusions, which describe how the attacker intrudes into the system. The attack scenario models are then transformed into programs (i.e., code is generated for the IDAs) and subsequently woven into the primary program. After weaving, the aspects act as intrusion detection components to automatically identify attacks against the target system. The method is not limited to a specific application domain and the framework can also be used to make distributed systems intrusion-aware. Several open source tools like ArgoUML, AspectJ, and Novasoft Metadata Framework are used to build the framework. When modeling intrusions, the level of formality is high due to state machines describing the attacks. Nevertheless, when considering the remaining application, which is written in an ordinary programming language and for which no model is available, the system is too complex to be verified formally. Therefore, the resulting intrusion-aware application needs to be tested manually by applying a set of attacks from the Web security threat classification released by the Web Application Security Consortium (WASC) <ref type="bibr">[23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Automated Validation of Internet Security Protocols and Applications</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">A Model-Based Aspect-Oriented Framework for Building Intrusion-Aware Software Systems (Zhu et al. 2008)</head><p>Zhu et al. <ref type="bibr">[22]</ref> propose a model-based, aspect-oriented framework for building intrusion-aware software systems. Such a system includes a group of intrusion detection aspects (IDAs) which can automatically detect intrusions. The authors developed a UML profile with aspect- In <ref type="bibr">[24]</ref>, the authors propose a tool, called AVISPA, intended to speed up the development of security protocols and to improve their security. The approach provides a language called the High-Level Protocol Specification Language (HLPSL) which is used to describe the protocols and their intended security requirements, and a number of analysis tools to formally validate them <ref type="bibr">[10]</ref>. The authors state that the approach provides a modular and expressive formal language for specifying security protocols and properties, and integrates several different back-ends that implement a variety of automatic analysis techniques ranging from protocol falsification to abstraction-based verification methods for both finite and infinite numbers of sessions <ref type="bibr">[24]</ref>. The language offers an expressive formalism that allows specification of roles, control flows, data structures as well as security requirements <ref type="bibr">[24]</ref>. Providing four separate analysis back-ends, the specification validation is tackled from different angles. Upon termination, the analysis result is presented, stating whether the problem could be solved, whether the problem could not be solved due to exhausted resources (e.g., memory) or some other reason that prevented the tool from solving the problem.</p><p>In general, the method offers a high level of formality, since HLPSL is based on Lamport's Temporal Logic of Actions <ref type="bibr">[25]</ref>. The user has to provide a dynamic model of the system's behavior which is represented by a distributed system consisting of interacting processes with messages sent to and received from each other. The model is not executable, since it is an abstraction of the protocol and not its implementation. Authenticity, integrity, and confidentiality can be analyzed with this approach. However, as with all methods based on state exploration, the size and the complexity of analyzed systems are severely limited by the state explosion problem (cf. <ref type="bibr">[26]</ref>). traced to them <ref type="bibr">[21]</ref>) to be analyzable. Lastly, as with all model checking methods, the size and the complexity of analyzed systems are severely limited by the state explosion problem (cf. <ref type="bibr">[26]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Alloy</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Symbolic Model Verifier</head><p>The Symbolic Model Verifier (SMV) is a model- checking system that can be used for analyzing designs of synchronous and asynchronous process systems. It provides a language for describing finite automata, and it can directly check the validity of temporal logic formulas (that is, linear temporal logic, or LTL for short, and computation tree logic, or CTL for short). The tool uses a textual description of the system's dynamic model and the corresponding specification which is expressed in LTL and CTL terms. On termination, it produces either 'true' if the specification holds or a trace showing why the required property is violated. SMV programs consist of one or more modules, which can declare variables and assign values to them. Usually, assignments give the initial value of a variable (e.g., init(var) := 0), whereas the variable's next value is specified in terms of expressions comprising the current value (e.g., next(var) := ((var + 1) mod 3)) <ref type="bibr">[27]</ref>, thereby modeling state transitions. Values can also be nondeterministic, in case the environment is influencing the system. In SMV, processes can be represented by modules that can be composed synchronously or asynchronously. In the latter case, the modules run at different speeds, and they are interleaving arbitrarily. Such asynchronous compositions can be used for describing communication protocols, asynchronous circuits, and other systems whose actions are not synchronized with a global clock <ref type="bibr">[27]</ref>.</p><p>In general, the proposed method offers a high level of formality, since it is based on temporal logic. It is well suited for modeling distributed systems, and the user has to provide a model of the system's dynamic behavior. The granularity of modeled systems can vary: On the one hand, processes that communicate with each other can be modeled, which can describe a view of the system's architecture. On the other hand, the method can be applied for modeling finite state machines, such as Mealy automata. Executable software systems cannot be modeled, but security protocols can. Properties like authenticity, integrity, confidentiality and non-repudiation can be verified. Of course, these have to be transformed into temporal logic formulas first (that is, combinations of safety and liveness properties, since all properties can be Alloy is a declarative modeling language based on first-order logic, extended with relational logic operators <ref type="bibr">[28]</ref>. The language was primarily designed for modeling software designs. Models written in the Alloy language can be analyzed using the so-called Alloy Analyzer, a model-finder built on a SAT (satisfiability problem) solver to simulate models and check their properties. Hereafter, we use the term Alloy to refer to both the language and the tool. The key elements of the approach are a logic, a language, and an analysis, which are introduced below <ref type="bibr">[28]</ref>.</p><p>• In <ref type="bibr">[28]</ref>, the authors describe Alloy as a first- order relational logic, which provides the building blocks of the language. All logical structures are represented as relations, and all structural properties are expressed with relational operators. States and executions are both described using constraints.</p><p>• The language adds a syntax to the underlying first-order relational logic. To support classification, the Alloy language supports typing, sub-typing and compile- time type-checking. Furthermore, the language's module system allows a reuse of generic declarations and constraints.</p><p>• Literally speaking, the analysis of Alloy models is a form of constraint solving, either by finding an instance of a model or by finding a counterexample for a given property. An instance is an example of the specified model, in which both the facts and the predicate hold. To make instance finding feasible, a user-specified scope is defined that limits the size of the analyzed instances. Within this bound, the analyzer translates the constraint into a Boolean formula and solves it using a commercial SAT solver <ref type="bibr">[28]</ref>. The solution is then presented to the user.</p><p>In general, the proposed method is suitable for modeling static and dynamic aspects of software systems. Furthermore, it offers a high level of formality, since the language is based on first-order relational logic. The Alloy language is abstract enough to model the problem domain's specific entities, as well as to model distributed systems, since message transmissions can be represented as dynamic operations. The modeled systems are not executable but are also not bound to a specific application area, since Alloy is expressive enough to capture several problem domains. As the approach is based on first-order logic, security requirements such as authenticity, integrity, non-repudiation, and confidentiality can be expressed. These have to be specified by the user as first- order formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Evaluation of Model-driven Security Approaches</head><p>Tables I provides a detailed overview of the surveyed methods, answering the question which modeling approaches are applicable for solving which problems. In summary, the conducted classification revealed that UMLsec is the most generally applicable approach focused on security, since all the other methods are either limited to modeling single security mechanisms (e.g., role-based access control), or they are general enough to model security as well but offer no security-specific language elements. The aspect-oriented approaches concentrate on just a single security aspect and lack the adaptability of the other methodologies, thus are unable to support the development of secure real-world applications on their own where usually several security aspects are of equal importance. Alloy is an example of such a language which is indeed very expressive but does not provide established rules of prudent security engineering to make them available for users who may not be experts in security. In such a case, the user has to model all the security aspects of the problem domain, which often requires a deep understanding of security (e.g., cryptographic protocols). Likewise, the Symbolic Model Verifier (SMV) model- checking system can be applied for analyzing dynamic behavior of parallel executing processes and can be used for the analysis of cryptographic security protocols as well. However, the level of abstraction offered by the SMV modeling language is far lower than the level adequate for describing security protocols. As a result, modeling security protocols in the SMV language is more complex than in AVISPA, since there are much more details to consider. Therefore, even if generally applicable methods (e.g., UMLsec, Alloy) can be applied to a broader range of security problems than special-purpose methods, this does not imply that they are more adequate. First, it depends on the particular problem which method fits best. And second, we have made the experience that picking the adequate special purpose method and applying it to the particular problem is more efficient and leads to better results, since (i) the problem can be represented on the proper abstraction level, (ii) the user can build on the knowledge of experts, and (iii) the available tools are more efficient and powerful. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dimension</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>In recent years, model-driven development has been introduced in order to increase the quality and thereby the security of software systems. This paper presented an evaluation of current efforts that position security as a fundamental element in model-driven development. Our evaluation revealed that approaches that analyze implementations of modeled systems are still missing. Due to the fact that implementations are not generated automatically from formal specifications, verification of running code is reasonable. A further insight was that all the aspect-oriented approaches modeled only a single security aspect. So even if the presented techniques worked well for modeling a single security mechanism, it has not been shown by anyone how adequate the AOSD principle is for developing secure real-world applications. Therefore, modeling several security aspects and combining them with the primary model is one of the next steps that the modeling community has to take. Further work will focus on the evaluation of how complex the weaving rules may become and how difficult it might be to verify a system consisting of several security aspects if more than one aspect is considered. Successfully modeling and thus generating a secure system including several security mechanisms, such as a security protocol (e.g., Needham-Schroeder) and access control (e.g., role- based access control), would provide the necessary confidence that the AOSD paradigm is suitable for development of complex and secure real-world applications. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>References</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported by grants of the Austrian Government's BRIDGE Research Initiative (contract 824884), the FIT-IT Research Initiative (contract 816158) and was performed at the research center Secure Business Austria funded by the Federal Ministry of Economy, Family and Youth of the Republic of Austria and by the City of Vienna.</p></div>		</body>
		<back>
			<div type="references">

				<listBibl/>
			</div>
		</back>
	</text>
</TEI>
