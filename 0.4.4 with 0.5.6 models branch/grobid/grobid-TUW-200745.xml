<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="de">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ein Lösungsarchiv mit Branch-and-Bound-Erweiterung für das Generalized Minimum Spanning Tree Problem DIPLOMARBEIT zur Erlangung des akademischen Grades Computational Intelligence eingereicht von</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Diplom-Ingenieur</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">im Rahmen des Studiums</orgName>
								<orgName type="department" key="dep2">Fakultät für Informatik</orgName>
								<orgName type="institution" key="instit1">Technischen Universität Wien</orgName>
								<orgName type="institution" key="instit2">Technische Universität Wien</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Gruber</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">im Rahmen des Studiums</orgName>
								<orgName type="department" key="dep2">Fakultät für Informatik</orgName>
								<orgName type="institution" key="instit1">Technischen Universität Wien</orgName>
								<orgName type="institution" key="instit2">Technische Universität Wien</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Ein Lösungsarchiv mit Branch-and-Bound-Erweiterung für das Generalized Minimum Spanning Tree Problem DIPLOMARBEIT zur Erlangung des akademischen Grades Computational Intelligence eingereicht von</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Betreuung Betreuer: Univ.-Prof Dr.Günther Raidl Mitwirkung: Univ.-Ass. Dr. Bin Hu Wien, September 5, 2011 (Unterschrift Verfasser) (Unterschrift Betreuer)</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>A-1040 Wien Karlsplatz 13 Tel. +43-1-58801-0 www.tuwien.ac.at Erklärung Christian Gruber Wachbergsraße 29 3382 Schollach Hiermit erkläre ich, dass ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen der Arbeit-einschließlich Tabellen, Karten und Abbildungen-, die an-deren Werken oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe. ii Kurzfassung In dieser Arbeit wird ein Algorithmus für das Generalized Minimum Spanning Tree-Problem (GMST) entwickelt. Beim GMST-Problem ist ein vollständiger Graph gegeben, bei dem die Knoten in Cluster partitioniert sind. Als Lösung wird ein Spannbaum gesucht, der von jedem Cluster genau einen Knoten beinhaltet und dessen Kosten minimal sind. Dieses Problem ist NP-schwierig. In dieser Arbeit wird eine Heuristik für dieses Problem entwickelt. Bei diesem Verfahren wird ein Evolutionärer Algorithmus (EA) mit zwei ver-schiedenen Lösungsarchiven verwendet. Die Lösungsarchive werden dazu benutzt Lösungen zu speichern, um Duplikate zu erkennen und diese in neue Lösungen umzuwandeln. Das eine Lösungsarchiv beruht auf einer Kodierung, bei der die ausgewählten Knoten der Cluster einer Lösung gespeichert werden, während das andere Archiv auf einer Kodierung beruht, bei der gespeichert wird, welche Cluster in der Lösung verbunden sind. Diese Archive werden in dieser Arbeit durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Dabei wird versucht im Archiv an günstigen Positionen geeignete Bounds zu berechnen, die Auskunft darüber geben, wie gut die Lösungen in diesem Bereich des Archivs höchstens sein können. Wird eine Bound gefunden, die schlechter als die beste gefunden Lösung ist, sind diese Lösungen im weiteren Verlauf des Algorithmus uninteressant und werden nicht mehr berücksichtigt. Das führt dazu, dass mehrere Lösungen von vornherein als schlecht erkannt werden können und somit nur Lösungen verfolgt werden, die auch Verbesserungen bringen können. Zusätzlich zu der Bounding-Strategie wird auch noch ein Nearest Neighbour Ansatz verwendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n näch-sten Nachbarcluster bevorzugt werden. Am Ende der Arbeit wurden Tests durchgeführt, bei denen die Bounding Strate-gie in den unterschiedlichen Archiven verwendet wurde. Diese Tests führten zu dem Ergebnis, dass die Bounding Strategie zu einer Verbesserung gegenüber den Archiven ohne Bounding Strategie führt. Der Vergleich zwischen den Archiven hat ergeben, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen beiden Varianten. iii Abstract In this work, an algorithm for the generalized minimum spanning tree problem (GMST) is developed. Given is a complete graph where the nodes are partitioned into clusters. A solution is a spanning tree which contains exactly one node of each cluster and its costs are minimal. This problem is NP-hard. In this work, a heuristic is developed for this problem. In this method, an evolutionary algorithm (EA) is used with two different solution archives. Using a solution archive, it is possible to store solutions generated by the EA in order to detect duplicates and converts duplicate solutions into new solutions. One solution archive based on an encoding in which the spanned nodes of each cluster in the solution are stored. The other archive is based on an encoding which characterizes the connections between the clusters. These archives are extended by a bounding strategy based on the branch-and-bound technique. They try to calculate appropriate bounds at a convenient positions which give information about how good the solutions in the respective area of the archive can be in the best case. If a bound was found which is worse than the best known solution, the solutions are unattractive in the course of the algorithm and will not be considered. Therefore inferior solutions can be detected at an early stage and only promising solutions that can bring improvements will be pursued. In addition to the bounding strategy a nearest neighbor approach is implemented in which a cluster attached to the spanning tree is preferred among the the n nearest neighboring clusters. Tests were carried out in which the bounding strategy was used in the different variants. These tests led to the conclusion that the bounding strategy leads to an improvement in comparison to the &quot;normal&quot; archives. The comparison between the archives shows that the pop version lead to better results than the gosh version. When both archives are used simultaneously, the results are better than the results of the other two variants.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="de">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kurzfassung</head><p>In dieser Arbeit wird ein Algorithmus für das Generalized Minimum Span- ning Tree-Problem (GMST) entwickelt. Beim GMST-Problem ist ein vollständiger Graph gegeben, bei dem die Knoten in Cluster partitioniert sind. Als Lösung wird ein Spannbaum gesucht, der von jedem Cluster genau einen Knoten beinhaltet und dessen Kosten minimal sind. Dieses Problem ist NP-schwierig. In dieser Arbeit wird eine Heuristik für dieses Problem entwickelt.</p><p>Bei diesem Verfahren wird ein Evolutionärer Algorithmus (EA) mit zwei ver- schiedenen Lösungsarchiven verwendet. Die Lösungsarchive werden dazu benutzt Lösungen zu speichern, um Duplikate zu erkennen und diese in neue Lösungen umzuwandeln. Das eine Lösungsarchiv beruht auf einer Kodierung, bei der die ausgewählten Knoten der Cluster einer Lösung gespeichert werden, während das andere Archiv auf einer Kodierung beruht, bei der gespeichert wird, welche Clus- ter in der Lösung verbunden sind.</p><p>Diese Archive werden in dieser Arbeit durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Dabei wird versucht im Archiv an günstigen Positionen geeignete Bounds zu berechnen, die Auskunft darüber geben, wie gut die Lösungen in diesem Bereich des Archivs höchstens sein können. Wird eine Bound gefunden, die schlechter als die beste gefunden Lösung ist, sind diese Lösungen im weiteren Verlauf des Algorithmus uninteressant und werden nicht mehr berücksichtigt. Das führt dazu, dass mehrere Lösungen von vornherein als schlecht erkannt werden können und somit nur Lösungen verfolgt werden, die auch Verbesserungen bringen können.</p><p>Zusätzlich zu der Bounding-Strategie wird auch noch ein Nearest Neighbour Ansatz verwendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n näch- sten Nachbarcluster bevorzugt werden.</p><p>Am Ende der Arbeit wurden Tests durchgeführt, bei denen die Bounding Strate- gie in den unterschiedlichen Archiven verwendet wurde. Diese Tests führten zu dem Ergebnis, dass die Bounding Strategie zu einer Verbesserung gegenüber den Archiven ohne Bounding Strategie führt. Der Vergleich zwischen den Archiven hat ergeben, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen beiden Varianten.</p><p>iii Abstract In this work, an algorithm for the generalized minimum spanning tree problem (GMST) is developed. Given is a complete graph where the nodes are partitioned into clusters. A solution is a spanning tree which contains exactly one node of each cluster and its costs are minimal. This problem is NP-hard. In this work, a heuristic is developed for this problem.</p><p>In this method, an evolutionary algorithm (EA) is used with two different solu- tion archives. Using a solution archive, it is possible to store solutions generated by the EA in order to detect duplicates and converts duplicate solutions into new solutions. One solution archive based on an encoding in which the spanned nodes of each cluster in the solution are stored. The other archive is based on an encoding which characterizes the connections between the clusters. These archives are extended by a bounding strategy based on the branch-and-bound technique. They try to calculate appropriate bounds at a convenient positions which give information about how good the solutions in the respective area of the archive can be in the best case. If a bound was found which is worse than the best known solution, the solutions are unattractive in the course of the algorithm and will not be considered. Therefore inferior solutions can be detected at an early stage and only promising solutions that can bring improvements will be pursued.</p><p>In addition to the bounding strategy a nearest neighbor approach is implemented in which a cluster attached to the spanning tree is preferred among the the n nearest neighboring clusters.</p><p>Tests were carried out in which the bounding strategy was used in the different variants. These tests led to the conclusion that the bounding strategy leads to an improvement in comparison to the "normal" archives. The comparison between the archives shows that the pop version lead to better results than the gosh version. When both archives are used simultaneously, the results are better than the results of the other two variants.  </p><formula xml:id="formula_0">G = (V, E, c), wobei V die Knoten- menge, E die Kantenmenge und c : E → R + die Kostenfunktion ist. Die Knotenmenge V ist partitioniert in m paarweise disjunkte Cluster V 1 , V 2 , . . . , V m , wobei i=1,...,m V i = V , V i ∩ V j = ∅ ∀i, j = 1, . . . , m, i = j. d i ist die Anzahl der Knoten in Cluster V i , i = 1, .</formula><p>. . , m. Eine Lösung für das GMST-Problem ist ein Graph S = (P, T ), wobei P = {p 1 , p 2 , . . . , p m } ⊆ V enthält genau einen Knoten von jedem Cluster (p i ∈ V i f or all i = 1, . . . , m). T ⊆ E ist ein Spannbaum auf die Knoten in P . Die Kosten von T ergeben sich aus den Kantenkosten, C(T ) = <ref type="bibr">(u,v)∈T c(u, v)</ref>. Die optimale Lösung ist dann ein Graph S = (P, T ) dessen Kosten C(T ) minimal sind. Ein Beispiel für eine solche Lösung ist in Abb. 1 zu finden. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.1">Gosh-Kodierung</head><p>Bei der Gosh-Kodierung wird für jeden Cluster angegeben, welcher Knoten in diesem Cluster ausgewählt wurde. Die kodierte Lösung besteht somit aus einem Vektor P = {p 1 , p 2 , . . . , p m } wobei p i ∈ V für alle i = 1 . . . m. Um aus der kodierten Lösung den Phänotypen und den dazugehörigen Lösungswert zu bekommen, kann dazu ein MST- Algorithmus angewendet werden (z.B. Kruskal).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.2">Pop-Kodierung</head><p>Bei der Pop-Kodierung wird gespeichert, welche Cluster miteinander verbunden sind. Dazu wird ein globaler Graph definiert [7]: G G = (V G , E G ), wobei V G den Clustern des ursprünglichen Graphen G entsprechen und E G den Kanten zwischen den Clustern,</p><formula xml:id="formula_1">d.h. E G = V G ×V G . Auf diesen Graphen G G kann nun ein Spannbaum S G = (V G , T G ) gebildet werden, wobei T G ⊆ E G .</formula><p>Die • null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde.</p><p>• complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde oder alle Lösungen in dem darunter liegenden Subtrie bereits complete sind.</p><p>• forbidden <ref type="formula">(</ref> Es ergeben sich also zwei Arten von Clustern. V 1 ist die Menge der Cluster für die bereits eine Knotenauswahl getroffen wurde und V 0 ist die Menge der Cluster für die noch keine Auswahl getroffen wurde. Um in einem bestimmten Trie-Knoten eine Bound zu berechnen, wird zunächst der</p><formula xml:id="formula_2">Graph G = (V , E ) definiert, wobei V = V 1 ∪ V 0 .</formula><p>Die Menge E setzt sich aus 3 verschiedenen Arten von Kanten zusammen:</p><formula xml:id="formula_3">• E 11 = V 1 × V 1 sind die</formula><p>Kanten zwischen allen Paaren von Clustern, für die bereits eine Auswahl getroffen wurde. Die Kantenkosten ergeben sich aus der Distanz zwischen den ausgewählten Knoten der Cluster.</p><p>• E 10 = V 1 × V 0 sind die Kanten zwischen allen Paaren von Clustern, bei de- nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht wurde. Die Kantenkosten zwischen den Clustern </p><formula xml:id="formula_4">V i ∈ V 1 und V j ∈ V 0 lauten c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist. • E 00 = V 0 × V 0 sind die</formula><formula xml:id="formula_5">V i ∈ V 0 und V j ∈ V 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.</formula><p>Die Definition der Kantenmenge lautet also E = E 11 ∪ E 10 ∪ E 00 . Die Berechnung der Kantenkosten wird in einem Preprocessing-Schritt durchgeführt, d.h. sie erfolgt einmal zu Beginn des Algorithmus und ist somit für die Laufzeit des Algorithmus nicht mehr relevant. Um die Bound zu berechnen, wird für den Graphen G ein mi- In Abb. 5 wird illustriert wie eine Boundberechnung im Gosh-Lösungsarchiv funk- tioniert. In diesem Beispiel wird im Trie-Knoten des Cluster V 3 die Bound berechnet. An dieser Position wurden die Cluster V 1 , V 2 und V 3 schon in den oberen Ebenen einge- fügt und somit eine Knotenauswahl für die Cluster getroffen. In den darunter liegenden Clustern (V 4 , V 5 und V 6 ) wurde noch keine Auswahl getroffen. Für die Boundberech- nung bedeutet das, dass hier zwischen den Clustern V 1 , V 2 und V 3 als Kantenkosten der Abstand der ausgewählten Knoten genommen wird. Zwischen dem Cluster V 3 und V 4 wird als Kosten der Distanzen zwischen dem ausgewählten Knoten 1 (V 3 ) und dem Knoten 3 (V 4 ) genommen, da dieser die geringste Distanz zum Knoten 1 (V 3 ) hat. Zwi- schen den Clustern V 4 , V 5 und V 6 werden die minimalen Distanzen zwischen den Clus- tern verwendet. D.h. zwischen Cluster V 6 und V 4 wird die Kante zwischen Knoten 2 (V 6 ) und Knoten 1 (V 4 ) genommen und zwischen V 5 und V 4 wird die Kante zwischen Knoten 1 (V 5 ) und Knoten 4 (V 4 ) genommen.</p><formula xml:id="formula_6">nimaler Spannbaum S = (V , T ) ermittelt, wobei T ⊆ E . Die Bound entspricht dabei den Kosten des Spannbaums T , C(T ) = (u,v)∈T c(u, v</formula><p>Ist die berechnete Bound schlechter als die beste bisher gefundene Lösung, kann der Pointer 1 des Clusters V 3 als complete markiert werden. Das kann gemacht werden, da zwischen den Clustern V 4 , V 5 und V 6 immer der minimale Abstand genommen wurde. Wenn nun Knoten in den Clustern ausgewählt werden, bleiben die Kosten des Spannbaums gleich oder werden größer aber sie werden sicher nicht kleiner. Das führt dazu, dass alle Lösungen in diesem Subtrie mindestens so groß sind als die berechnete Bound und somit in diesem Fall auch größer sind als die beste bisher gefundene Lösung.</p><p>Wie vorhin schon erwähnt, ist eine Möglichkeit, wann die Boundberechnung durchge- führt werden kann, die Einfüge-Operation des Lösungsarchivs. Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Bei einer erfolg- reichen Einfüge-Operation werden also m Trie-Knoten durchlaufen. Eine Möglichkeit wäre, in jedem dieser m Trie-Knoten für den jeweiligen Pointer, der dem ausgewählten Knoten dieses Clusters in der Lösung entspricht, die Bound zu berechnen. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Konvertierungs-Methode</head><p>Die zweite Möglichkeit, wann Boundberechnungen durchgeführt werden können, ist bei der Konvertierungs-Operation des Lösungsarchivs. Bei der Konvertierungs-Operation wird aus einer im Archiv enthaltenen Lösung eine neue Lösung gemacht, die der alten möglichst ähnlich ist. Die Boundberechnung erfolgt nach jeder Änderung, die in der alten Lösung gemacht wird. Ist diese Bound besser als die beste bisher gefundene Lö- sung, wird diese neue Lösung akzeptiert. Ist die Bound aber schlechter, so werden die Änderungen wieder rückgängig gemacht, die Lösung im Archiv als complete markiert und danach weiter nach einer anderen neuen Lösung gesucht.</p><p>In Algorithmus 3 ist dargestellt wie die Konvertierung mit Berücksichtigung der Bounds funktioniert. Zuerst wird ein zufälliger Trie-Knoten der Lösung sol ausgewählt. In Zeile 5 wird dann geprüft, ob es einen null-Pointer in dem ausgewählten Trie-Knoten gibt. Wenn es einen gibt, wird die Lösung geändert und überprüft ob die Bound der neuen Lösung an dieser Position schlechter ist als die beste bisher gefunden Lösung. Wenn sie besser ist, wird sie akzeptiert und es kann abgebrochen werden. Ist sie schlechter, wird die Änderung wieder rückgängig gemacht und der Pointer als complete markiert. Die Suche wird danach fortgesetzt. In den Zeilen 14-21 wird versucht, entlang der Lösung im Archiv eine Ebene nach unten zu gehen. Dieser Schritt erfolgt nur, wenn der Pointer nicht complete ist und die Bound besser ist als die beste Lösung. Wenn entlang von sol nicht nach unten gegangen werden kann, wird in den Zeilen 22-31 versucht einen anderen Pointer, der nicht complete ist, zu finden und an diesen eine Ebene nach unten zu gehen. Hier erfolgt wieder eine Überprüfung der Bound. Der ausgewählte Pointer wird nur weiter verfolgt, wenn die Bound besser ist als die beste Lösung.</p><p>Es kann vorkommen, dass in einem Trie-Knoten kein Pointer vorhanden ist, der zu einer guten Bound führt. Das hat zur Folge, dass alle Pointer als complete markiert werden und somit nicht mehr weiter nach unten gegangen werden kann. Deshalb muss bei jedem Schleifendurchlauf überprüft werden, ob es noch einen Pointer gibt, der nicht complete ist. Wenn nicht, wird dieser Trie-Knoten gelöscht und der zugehörige Pointer im Eltern-Knoten als complete markiert. Danach kann Abgebrochen werden und f alse zurück gegeben werden. Die Konvertierungs-Methode wird danach nochmal aufgerufen. Das kann zu einem Problem führen. Wenn die Ausgangslösung relativ schlecht ist, kann die Suche nach einer neuen Lösung recht lange dauern. Tests haben gezeigt, dass dieser Fall nicht sehr oft auftritt und in den meisten Fällen schon nach wenigen Versuchen eine neue Lösung gefunden werden kann. In wenigen Fällen wurde aber lange nach einer Lösung gesucht. Um dieses Problem zu umgehen, wurde ein Parameter num_conv eingeführt, mit dem die Anzahl der Konvertierungsversuche begrenzt werden kann.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 3 GoshTrie convert with Bound</head><p>Eingabe: sol -solution to convert, best solution bestsol Ausgabe: convertion successfull (true/false) 1: curr ← random Trie-node along sol 2: add all clusters from root to curr to V 1 and the other clusters to V Danach wird mit der Methode calculateBound mit einem angepassten Kruskal Algo- rithmus ein minimum Spanning-Tree ermittelt. Ähnlich wie bei der Boundberechnung im Gosh-Archiv, werden im Pop-Archiv auch drei Arten von Kanten zur Berechnung verwendet:</p><p>• E 11 = V 1 × V 1 ist die Menge aller Kanten von G . Die Kantenkosten ergeben sich aus dem Abstand zwischen den ausgewählten Knoten der Cluster.</p><p>• E 10 = V 1 × V 0 sind die Kanten zwischen allen Paaren von Clustern, bei de- nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht wurde. Die Kantenkosten zwischen den Clustern</p><formula xml:id="formula_7">V i ∈ V 1 und V j ∈ V 0 lauten c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist. 20 2.2. Boundberechnung im Pop-Archiv • E 00 = V 0 × V 0 sind</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>die Kanten zwischen allen Paaren von Clustern, für die noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern</head><formula xml:id="formula_8">V i ∈ V 0 und V j ∈ V 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.</formula><p>Im Kruskal-Algorithmus werden jetzt zunächst alle Kanten von E 11 eingefügt. Danach werden die restlichen Kanten E 10 ∪ E 00 , wie bei einem normalen Kruskal-Algorithmus, in der Reifenfolge ihrer Kantenkosten hinzugefügt, sodass kein Zyklus entsteht.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 5 calcClusters</head><p>Eingabe: root-node cN r; solution sol; data; current level of the trie aktP os Wie vorhin bereits erwähnt, wird mit den Methoden calcClusters und generateList die bestmögliche Auswahl von Knoten innerhalb der Cluster getroffen. Zunächst wird mit calcClusters (Algorithmus 5) für jeden Knoten der zu untersuchen- den Cluster die Kosten berechnet, die entstehen wenn dieser Knoten ausgewählt wird. Dazu wird calcClusters rekursiv aufgerufen, um, angefangen bei den Clustern in der untersten Ebene, die Kosten für die Knoten zu berechnen.</p><p>Die Kosten werden in der Methode calcClusterweights (Algorithmus 6) berechnet. Dazu wird für jeden Knoten p i ∈ C cur des jeweiligen Clusters C cur ∈ V 1 die mini- malen Kosten berechnet, die entstehen würden, wenn dieser ausgewählt werden würde. Das geschieht, indem für alle Nachfolgecluster C suc ∈ V 1 ein Knoten p j ∈ C suc ausgewählt wird. Der Knoten p j wird dabei so gewählt, dass die Summe der Kosten von p j und die Distanz von p i zu p j minimal ist. Die Kosten des Knoten sind also C(p i ) = p j ∈Psuc (C(p j ) + dist(p i , p j )), wobei P suc die Menge der minimalen Knoten der Nachfolgecluster von C cur ist. In der Datenstruktur nodes werden für alle Knoten deren Kosten C(p i ) gespeichert und berechnet und auch alle Knoten der Menge P suc gespeichert. Diese Datenstruktur wird für die spätere Auswahl der Knoten in den Clus- tern benötigt.</p><p>Mit der Methode generateList (Algorithmus 7) werden nun die ausgewählten Knoten innerhalb der Cluster ermittelt. Dazu wird beginnend beim Wurzelcluster der Knoten mit den geringsten Kosten in data gespeichert. Dazu wird die Datenstruktur nodes ver- wendet, in der für jeden Knoten die günstigsten Nachfolgeknoten gespeichert sind. Zur Umsetzung der inkrementellen Boundberechnung wurde ein Vektor valid verwen- det, indem für jeden Cluster angegeben wird, ob sich die Knotenkosten in den Cluster ändern. Die einzige Änderung die, gegenüber der "normalen" Boundberechnung zu machen ist, ist in der Methode calcCluster vorzunehmen. In Algorithmus 8 ist zu se- hen, wie die geänderte Methode aussieht. In der Methode wird der Vektor valid dazu verwendet, um festzustellen, ob die Bound berechnet werden soll oder nicht.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 8 calcClustersImprove</head><p>Eingabe: root-node cN r; solution sol; data; current level of the trie aktP os </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rekombination</head><p>Bei der Rekombinations-Methode wurde die in <ref type="bibr" target="#b19">[13]</ref> verwendete Methode als Grundlage genommen und durch den Nearest Neighbour Ansatz ergänzt. Die Rekombination wird dabei wie folgt durchgeführt: Für jedes Cluster C i wird über- prüft, ob es in den beiden Lösungen den gleichen Vorgänger hat. Wenn das der Fall ist, wird dieser Vorgänger in die neue Lösung übernommen. Hat der Cluster C i in den beiden Lösungen unterschiedliche Vorgänger, gibt es drei Möglichkeiten:</p><p>• Ein Vorgänger C j ist in der Menge der Nearest Neighbours von C i und der andere C k nicht: In diesem Fall wird C j in der neuen Lösung aufgenommen.</p><p>• Beide Vorgänger sind in der Menge der Nearest Neighbours von C i : Hier wird zufällig einer der beiden ausgewählt. Genau wie beim Gosh-Archiv wird auch beim Pop-Archiv die Bounding Strategie in die Einfüge-Methode integriert. Bei der Pop-Einfüge-Methode wird, wie auch in Kapi- tel 2.1.1, die Bound nicht in jedem Einfügeschritt berechnet, sondern nur für einen Teil der Trie-Knoten der einzufügenden Lösung. Dazu wird wieder der Parameter branch_and_bound_prob verwendet, der angibt mit welcher Wahrscheinlichkeit die Bound für einen Trie-Knoten berechnet wird.</p><p>Algorithmus 10 PopTrie insert with Bound Eingabe: solution to insert sol; best solution bestsol Ausgabe: insertion successfull (true/false) Variablen: m=number of clusters; root=root from archiv Pointer noch null, wird ein Trie-Knoten erzeugt und an dieser Stelle in den Trie einge- fügt. Beim ersten Aufruf der Methode calcBoundByDynP rog wird die Bound mithilfe der "normalen" dynamischen Programmierung ermittelt. Für alle weiteren Aufrufe der Methode calcBoundByDynP rog innerhalb derselben Einfügeoperation wird die inkrementelle Boundberechnung, die in Kapitel 2.2.1 beschrieben wird, verwendet. Dazu müssen vorher alle Cluster, für die sich die Kosten der Knoten ändern, markiert werden. Deshalb wird vor der Boundberechnung die Methode invalidate aufgerufen. In dieser Methode werden alle Cluster, vom aktuellen Cluster bis hin zur Wurzel im Spannbaum der Lösung, markiert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Konvertierungs-Methode</head><p>In der Konvertierungs-Methode des Pop-Archivs wird die Bounding Strategie ebenfalls angewendet. Die Konvertierungs-Methode mit Bounds funktioniert dabei ähnlich wie die des Gosh-Archivs. Bei jeder Änderung der Lösung wird die Bound berechnet und überprüft, ob diese besser als die beste bisher gefundene Lösung ist. Ist das nicht der Fall, wird die Änderung rückgängig gemacht und eine andere Lösung gesucht. Zusät- zlich zur Bounding Strategie wurde die Konvertierungs-Methode durch den Nearest Neighbour Ansatz erweitert.</p><p>In Algorithmus 11 wird der Ablauf der Konvertierungs-Methode gezeigt. Dabei wird zunächst zufällig ein Trie-Knoten curr aus den möglichen Startknoten entlang der Lö- sung ausgewählt. Im nächsten Schritt wird zuerst zufällig aus den Nearest Neighbours von curr ein null-Pointer ausgewählt. Ist keiner vorhanden wird aus den restlichen Pointern zufällig ein null-Pointer ausgewählt. Wurde ein null-Pointer gefunden, kann eine neue Lösung generiert werden. Bei dieser neuen Lösung erfolgt dann eine Bound- überprüfung. Die Boundberechnung wird mit Methode calcBoundByDynP rog durch- geführt. Ist die Bound schlechter als die beste bisher gefundene Lösung, wird die Än- derung der Lösung wieder rückgängig gemacht, der vorher ausgewählte Pointer auf complete gesetzt und mit der Suche fortgesetzt. Ist die Bound nicht schlechter, kann abgebrochen werden. Wurde kein null-Pointer gefunden, wird zunächst versucht, ent- lang der Lösung im Archiv eine Ebene nach unten zu gehen. Hierbei wird wieder eine Boundüberprüfung durchgeführt. Kann entlang der Lösung nicht weiter nach unten gegangen werden, wird im aktuellen Trie-Knoten zufällig ein Pointer aus den Nearest Neighbours von curr ausgewählt, der nicht complete ist. Wird so ein Pointer nicht gefunden, wird aus den restlichen Pointern zufällig ein Pointer ausgewählt, der nicht complete ist. Die Lösung wird dementsprechend geändert und es erfolgt wieder eine Boundüberprüfung. Da der EA ein randomisierter Algorithmus ist, wurden für alle Tests 30 Runs gemacht und für die Auswertung der Mittelwert C avg (T ) = 1/n n i=1 C(T i ) und die Standard- abweichung S = 1/(n − 1) n i=1 (C(T i ) − C avg ) 2 genommen. Die Tests wurden auf dem Cluster des Institut für Computergraphik und Algorithmen der TU-Wien durchge- führt, welcher aus 14 Maschinen mit jeweils zwei QuadCore-CPUs und 24 GB Ar- beitsspeicher besteht.</p><p>Grundsätzlich wurden zwei Arten von Tests durchgeführt. Zum einen sind Testläufe gemacht worden, bei denen der EA nach einer fixen Laufzeit terminiert und zum an- deren Testläufe bei denen nach einer bestimmten Anzahl von Generationen der EA ter- miniert. Letztere wurden unter anderem dazu verwendet, um den Speicherverbrauch des Archivs genauer zu untersuchen.</p><p>Die folgenden Tests wurden mit einer fixen Laufzeit durchgeführt. Die Daten der ver- wendeten Testinstanzen und die Laufzeit werden in Tabelle 1 dargestellt. In Tabelle 6 sind die Ergebnisse dieses Tests zu sehen. Dabei wurden wieder 4 Varianten miteinander verglichen: "normalen" Gosh und Pop Archive ohne Bounding-Strategie (T rie), die Variante mit Bounding-Strategie innerhalb der Einfüge-Methode (T rie + insert−Bound), die Bounding-Strategie innerhalb der Konvertierungs-Methode (T rie+ convert−Bound) und die Bounding-Strategie in beiden Methoden gleichzeitig (T rie+ ins&amp;conv − Bound). Hier ist zu sehen, dass bessere Ergebnisse bei den Varianten mit Bounding-Strategie erzielt werden, außer bei den Instanzen bei denen das Optimum schon mit den "normalen" Archiven erreicht wird. Außerdem ist zu sehen, dass in der Variante, in der in beiden Methoden die Bounding-Strategie verwendet wird, schlechtere Ergebnisse erreicht werden, als in den Varianten, wo die Bounding-Strategie nur bei der Einfüge-oder Konvertierungs-Methode verwendet wird. Das ist auf die geringere An- zahl von Generationen zurück zu führen, die oft nur halb so groß ist als bei den beiden anderen Varianten.</p><p>In den bisherigen Tests ist zu sehen, dass durch die Verwendung der Bounding-Strategie die Anzahl der erzeugten Generationen geringer sind. Dadurch ist ein Vergleich des Speicherverbrauchs der beiden Varianten nicht möglich, da bei dem Archiv ohne Bound- ing mehr Lösungen in das Archiv eingefügt werden als beim Archiv mit Bounding. Um jetzt den Speicherverbrauch der unterschiedlichen Varianten miteinander zu ver- gleichen, wird als Abbruchbedingung für den EA eine fixe Anzahl von Generationen genommen. So werden bei allen Varianten gleich viele Generationen erzeugt.</p><p>Für diese Tests wurde die Abbruchbedingung des EAs auf 10.000 Generationen gesetzt. In den Tabellen 7 und 8 sind die Ergebnisse für diese Tests zu sehen. In der Tabelle 7 wurde das Gosh-Archiv untersucht, während in Tabelle 8 die Ergebnisse für das Pop-Archiv zu sehen sind. Es wurden jeweils das "normale" Archiv ohne Bounding- Strategie, das mit Bounding-Strategie in der Einfüge-Methode und das mit Bounding- Strategie in der Konvertierungs-Methode miteinander verglichen. Die Spalte C avg ent- spricht dabei wieder dem Durchschnitt der Lösungswerte über alle Runs, unter diesem Wert steht in Klammern die Standardabweichung, Zeit entspricht der durchschnittlich benötigten Zeit und M em den benötigten Speicher für das Archiv.</p><p>In diesen Ergebnissen ist zu sehen, dass die Varianten mit Bound immer mehr Spei- cher benötigen als die ohne Bound. Das kommt zunächst überraschend, da man zuerst annehmen würde, dass durch die Bounding-Strategie auch weniger Speicher verbraucht würde. Der Grund für den erhöhten Speicherverbrauch bei der Einfüge-Methode ist in Abb. 8 zu sehen. In diesem Beispiel wird zunächst versucht, im Gosh-Archiv die Lösung &lt;321112&gt; (in der Grafik rot dargestellt) einzufügen. In Knoten V 5 wird eine Bound festgestellt, die schlechter ist als die beste bisher gefundene Lösung, und somit der Pointer 1 als complete markiert. Danach wird die Einfügeoperation abgebrochen und f alse zurück geben. Für den EA sieht es daher so aus, als wäre die Lösung im Archiv schon enthalten. Im nächsten Schritt wird mit der Konvertierungsmethode eine neue Lösung &lt;341112&gt; erzeugt. Diese wird nun erfolgreich in das Archiv eingefügt. Würde die Bounding-Strategie nicht verwendet werden, wäre die Lösung &lt;321112&gt; beim ersten Mal eingefügt worden. Da die Bounding-Strategie verwendet wurde, ist nun die Lösung &lt;321112&gt; bis zum Knoten V 5 und die Lösung &lt;341112&gt; ganz eingefügt worden. D.h. beim Erzeugen einer neuen Lösung für die neue Generation wurden die drei Knoten V 3, V 4 und V 5 des ersten Einfügeversuchs zusätzlich eingefügt. Deshalb kommt es bei der Verwendung der Bounding-Strategie zu einem höheren Speicherver- brauch.</p><p>Um zu belegen, dass das der Grund für den erhöhten Speicherverbrauch ist, wurden weitere Tests durchgeführt. Bei diesen Tests wurden Lösungen, bei denen eine Bound 39 3.3. Fixe Anzahl von Generationen Abb. 8: Grund für erhöhten Speicherverbrauch gefunden wurde, die schlechter ist als die beste bisher gefundene Lösung, trotzdem in der neuen Generation akzeptiert. D.h. wenn beim Einfügen einer Lösung eine schlechte Bound gefunden wird, wird der jeweilige Pointer als complete markiert und dann true zurück gegeben. Das hat zur Folge, dass der EA die Lösung als neu akzeptiert.</p><p>Die Ergebnisse dieser Variante werden in Tabelle 9 gezeigt. Hier ist zu sehen, dass für die meisten Instanzen bei dieser Variante weniger Speicher für das Archiv gebraucht wurde.</p><p>Bei der Bounding-Strategie in der Konvertierungs-Methode ist der Grund für den er- höhten Speicherverbrauch ähnlich wie bei der Einfüge-Methode. Wenn bei der Konver- tierungs-Methode in einem zufällig ausgewählten Startknoten der Lösung keine null- Pointer gefunden werden, wird versucht, entlang der Lösung im Trie eine Ebene nach unten zu gehen. Wenn das nicht möglich ist, wird versucht bei einem anderen nicht complete-Pointer eine Ebene nach unten zu gehen. Wenn jetzt aufgrund von Bounds, die schlechter als die beste bisher gefunden Lösung sind, in diesem neuen Knoten alle Pointer complete werden, wird die Konvertierung abgebrochen und an einer anderen Stelle nochmal versucht. Da der Pointer der Lösung in dem Startknoten in diesem Fall auf complete gesetzt wurde, wird beim nächsten Konvertierungsversuch der Startknoten aus den darüber liegenden Ebenen ausgewählt. D.h. bei der Verwendung der Bounding- Strategie ist die Wahrscheinlichkeit höher, dass in den oberen Ebenen die Konvertierung durchgeführt wird. Das führt dazu, dass beim anschließenden Einfügen einer Lösung der neu einzufügende Subtrie größer ist. Deshalb werden mehr Trie-Knoten mit der Die Tests haben ebenfalls ergeben, dass der Speicherverbrauch der Archive durch die Verwendung der Bounds erhöht wird. Das ist darauf zurück zu führen, dass wenn beim Einfügen einer Lösung eine Bound gefunden wird, die schlechter ist als die beste bisher gefundene Lösung, diese Lösung teilweise eingefügt wird und zusätzlich noch eine neue konvertierte Lösung.</p><p>Die Ergebnisse dieser Arbeit wurden auch mit den Ergebnissen anderer Arbeiten ver- glichen, um zu sehen wie das Verfahren im Vergleich zu anderen abschneidet. Dabei hat sich gezeigt dass die Bounding-Strategie mit anderen Verfahren mithalten kann und in einigen Instanzen bessere Ergebnisse liefert.</p><p>Die Ergebnisse dieser Arbeit haben gezeigt, dass die Bounding-Strategie eine Verbesserung gegenüber dem Lösungsarchiv ohne Bounding-Strategie bringt. Ein wichtiger Punkt bei der Bounding-Strategie ist es, eine effiziente Methode für die Boundberechung zu finden, damit die Anzahl der erzeugten Generationen nicht zu stark abnimmt. Für an- dere Problemstellungen könnte dieses Verfahren auch Verbesserungen bringen, wenn eine effiziente Methode zur Boundberechnung gefunden wird.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Minimum Spanning Tree-Problem . . . . . . . . . . . . . 1 1.2 Evolutionäre Algorithmen . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.3 Lösungsarchive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.4 Lösungsrepräsentationen . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.4.1 Gosh-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.4.2 Pop-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.5 Branch and Bound . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.6 Bisherige Ansätze . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 1.6.1 EA mit Gosh-Lösungsarchiv . . . . . . . . . . . . . . . . . . . 8 1.6.2 EA mit Pop-Lösungsarchiv . . . . . . . . . . . . . . . . . . . . 10 2 Algorithmus 12 2.1 Boundberechnung im Gosh-Archiv . . . . . . . . . . . . . . . . . . . . 13 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>1.1 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.1.2 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 17 2.2 Boundberechnung im Pop-Archiv . . . . . . . . . . . . . . . . . . . . . 19 2.2.1 Inkrementelle Boundberechnung . . . . . . . . . . . . . . . . . 23 2.2.2 Pop mit Nearest Neighbours Reduktion . . . . . . . . . . . . . 24 2.2.3 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 26 2.2.4 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 27Vorgehensweise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 v 3.2 Tests mit fixer Laufzeit . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.2.1 Analyse der Cuts . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.2.2 Gosh-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 3.2.3 Nearest Neighbours . . . . . . . . . . . . . . . . . . . . . . . . 34 3.2.4 Pop-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 3.2.5 Beide Archive . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 3.3 Fixe Anzahl von Generationen . . . . . . . . . . . . . . . . . . . . . . 39 3.4 State of the Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43Das Generalized Minimum Spanning Tree-Problem (GMST) ist ein kombinatorisches Optimierungsproblem, das eine Verallgemeinerung des Minimum Spanning Tree Prob- lems (MST) ist. Für das MST-Problem ist ein vollständiger Graph G gegeben, bei dem jeder Kante Kosten zugeordnet sind. Eine Lösung des MST-Problems entspricht einer Teilmenge von Kanten, die einen minimalen Spannbaum bilden. Ein minimaler Spannbaum ist ein kreisfreier Teilgraph von G, der mit allen Knoten des Graphen ver- bunden ist und dessen Summe der Kantenkosten minimal ist. Beim GMST-Problem werden zusätzlich noch die Knoten des MST-Problems durch Cluster partitioniert. Die formale Definition des GMST-Problems sieht wie folgt aus [4]: Gegeben ist ein vollständiger gewichteter Graph</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>Ein Evolutionärer Algorithmus (EA) [9] ist eine Metaheuristik, mit deren Hilfe Opti- mierungsprobleme gelöst werden können. Der EA macht sich die Eigenschaften der natürlichen Evolution zunutze, um ausgehend von einer Anfangspopulation im Laufe der Zeit immer bessere Lösungen zu finden. Dazu werden drei Operationen angewen- det: Selektion, Mutation und Rekombination. Der EA arbeitet mit einer Population von Lösungen, wobei die einzelnen Lösungen in kodierter Form gespeichert werden. Diese kodierten Lösungen werden Genotyp genannt. Sie bestehen oft aus einem Bitstring. In dieser Arbeit werden die Lösungen aber als Integer-Vektor gespeichert. Auf die Kodierungsarten wird in Kapitel 1.4 noch genauer eingegangen. Um die Lösungen auswerten zu können ist es notwendig, die Lösungen auch wieder zu dekodieren. Die dekodierten Lösungen werden Phänotypen genannt. Der Ablauf des EA ist wie folgt: Zunächst wird für jede Lösung der Population aus den dazugehörigen Phänotypen ein Fitnesswert berechnet. Dieser Fitnesswert ist ein Maß dafür wie gut die Lösung ist. Danach werden durch eine Selektionsfunktion mit Hilfe der Fitnesswerte, zwei Elternlösungen ausgewählt. Aus diesen beiden Elternlö- sungen wird dann durch eine Rekombination eine neue Lösung generiert. Die Idee dabei ist, dass die guten Teile der ausgewählten Lösungen zusammengesetzt werden und dadurch eine neue bessere Lösung entsteht. Danach wird eine Mutation angewen- det, in der die Lösung zufällig an einer bestimmten Stelle verändert wird, um nicht so schnell in einem lokalen Optimum festzustecken. Die Mutation wird aber nur mit einer bestimmten Wahrscheinlichkeit ausgeführt, da sonst der Zufall einen zu großen Einfluss auf die Lösungsfindung hat. 1.3. Lösungsarchive Wie bei den meisten Metaheuristiken, ist die Definition der einzelnen Methoden all- gemein gehalten. Um den EA auf ein spezifisches Problem anzuwenden, müssen diese Methoden angepasst werden. Es gibt zwei unterschiedliche Arten von EAs: • Steady-State-EA: Dabei wird in jedem Generationsschritt nur eine Lösung aus der Population ersetzt. Die restlichen Lösungen bleiben erhalten.Bei einem EA werden neue Lösungen durch Kombination von alten Lösungen, die sich in der Population befinden, erzeugt. Das kann dazu führen, dass eine neu generierte Lö- sung sich schon in der Population befindet bzw. früher schon einmal untersucht wurde. Daraus können sich zwei Probleme ergeben. Zum einen führt es dazu, dass die sel- ben Lösungen mehrmals evaluiert werden und somit unnötig Laufzeit verbraucht wird, da die erneute Evaluierung keinen Sinn macht. Zum anderen kann das mehrfache be- trachten der selben Lösungen zu einem Diversitätsverlust führen, d.h. dass sich die Lösungen in der Population nach kurzer Zeit kaum mehr unterscheiden. Das führt dazu, dass der Lösungsraum nicht mehr so breit durchsucht wird und man so auch schneller in einem lokalen Optimum hängen bleibt. Um diesen Problemen entgegen zu wirken, sollte bei jeder generierten Lösung überprüft werden, ob diese in früheren Generationen schon einmal erzeugt worden ist. Dazu rei- cht es aber nicht die Lösungen mit der aktuellen Population zu vergleichen, da hier nur ein kleiner Ausschnitt der bisher untersuchten Lösungen enthalten ist. Daher wird eine Speicherstruktur verwendet, die Lösungsarchiv [12] genannt wird, in der jede generierte Lösung gespeichert wird und in angemessener Zeit danach gesucht werden kann. Das Lösungsarchiv muss drei Eigenschaften erfüllen. Es muss in angemessener Zeit überprüft werden können ob eine Lösung im Archiv vorhanden ist. Außerdem soll aus einer Lösung, die im Archiv enthalten ist, schnell eine neue Lösung generiert werden können, die der alten möglichst ähnlich ist. Zusätzlich sollen die beiden Aufgaben mit einem angemessenen Speicherverbrauch realisiert werden.Beim Binärbaum können alle drei Operationen in O(l * log 2 (n)) durchgeführt werden. Der Nachteil dieser Datenstruktur ist, dass in jedem Knoten eine vollständige Lösung gespeichert wird, was zu einem hohen Speicherverbrauch führt. Bei einem Trie können alle Operationen in O(l) ausgeführt werden. Das führt zu dem Ergebnis, dass ein Trie die geeignetste Datenstruktur, für die vorhin erwähnten benötigten Eigenschaften, ist. Algorithmus 1 EA mit Lösungsarchiv 1: generate random population pop and insert into archiv 2: while termination condition not satisfied dosol new ← recombination(parent1, parent2)if sol new included in archiv then</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>Pop-Kodierung wird nun mithilfe der Predecessor-Darstellung gemacht. Dazu wird ein Cluster als Wurzelcluster ausgewählt. In dem Spannbaum S G gibt es nun für jeden Cluster einen eindeutigen Pfad zum Wurzelcluster und somit auch einen eindeutigen Vorgänger. Für die Lösungsrepräsentation wird in einem Vektor oder Array für jeden Cluster (außer dem Wurzelcluster) der Vorgänger gespeichert. In Abb. 2 ist ein Beispiel dazu angegeben. Ein Problem dieser Kodierung ist, dass nicht jede Kodierung eine gültige GMST-Lösung darstellt. Dieser Faktor muss bei den EA-Operationen berücksichtigt werden, damit dadurch keine ungültigen Lösungen erstellt werden. Sonnleitner [13] hat dazu in seinerArbeit einen Repair-Mechanismus entwickelt, mit dem ungültige Lösungen in gültige umgewandelt werden können. Mittels dynamischer Programmierung kann dann aus der kodierten Lösung die optimale Auswahl der Knoten innerhalb der Cluster erfolgen und somit der Phänotyp und den dazugehörigen Lösungswert ermittelt werden.Branch and Bound ist ein Verfahren, mit deren Hilfe man beweisbar optimale Lösungen für kombinatorische Optimierungsprobleme finden kann. Das Verfahren beruht auf der Idee der beschränkten Enumeration und basiert auf dem Divide &amp; Conquer Prinzip. Branch and Bound-Algorithmen bestehen prinzipiell aus zwei Bereichen: Abgrenzung (Bound) und Verzweigung (Branch).Das Gosh-Lösungsarchiv ist ein Trie, bei dem jede Ebene einem Cluster V i entspricht. Jeder Trie-Knoten enthält d i Pointer, d.h. für jeden Knoten im Cluster gibt es einen Pointer. Die Pointer können folgende Zustände annehmen: • null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde. • complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde oder alle Lösungen in den darunter liegenden Subtrie bereits complete sind.Um aus einer Lösung im Trie eine neue Lösung zu generieren, werden zunächst jene Trie-Knoten ermittelt, die für eine Änderung in Frage kommen. Das sind jene Trie- Knoten entlang der Lösung im Archiv, die nicht in einem als complete markierten Bereich liegen. Danach wird aus diesen Trie-Knoten einer zufällig ausgewählt, indem dann die Änderungen gemacht werden sollen. In diesem Trie-Knoten wird nach einem null-Pointer gesucht. Wenn ein solcher null-Pointer vorhanden ist, wird die Lösung dementsprechend abgeändert. Gibt es keinen, geht man im Trie entlang der Lösung zum nächsten Trie-Knoten und wiederholt die Suche. Ist der Pointer der Lösung aber complete wird ein anderer Pointer ausgewählt und zu diesem Trie-Knoten weiter gegan- gen. Die Frage welche Ebene im Archiv welchem Cluster zugeordnet wird, wurde in [15] näher betrachtet. Wenn die Trie-Knoten der i-ten Ebene im Archiv dem Cluster V i zu- geordnet werden, kommt es zu einem Problem. Es entsteht ein so genanntes Bias im Trie, d.h. die Wahrscheinlichkeit einer Lösungsänderung in einem Cluster ist nicht für alle Cluster gleich groß. Die Knoten in den unteren Ebenen des Archivs haben eineWie vorher schon erwähnt, hat Sonnleitner [13] in seiner Arbeit das Lösungsarchiv auf Basis der Pop-Kodierung aufgebaut. Bei der Pop-Kodierung werden, wie in Kapitel 1.4.2 bereits beschrieben, die globalen Kanten zwischen den Clustern berücksichtigt. Dabei werden die Vorgänger der Cluster in dem Spannbaum des globalen Graphen, in einem Vektor gespeichert. Das Pop-Lösungsarchiv ist ein Trie, der aus m − 1 Ebenen besteht, wobei jede Trie- Ebene für ein Cluster steht. Außer für den Wurzelknoten, da dieser keinen Vorgänger hat. In jedem Trie Knoten gibt es m − 1 Pointer, da ein Cluster in einem Baum nicht sein eigener Vorgänger sein kann. In Abb. 4 ist ein Beispiel zu sehen, wie eine Lösung in einem Pop-Lösungsarchiv gespeichert wird. In diesem Beispiel sind zwei Lösungen in dem Archiv schon enthalten. Die Lösung &lt;-65611&gt; wurde dem Archiv neu hinzuge- fügt. Da in dieser Kodierung auch Lösungen dargestellt werden können, die keinen Baum darstellen, gibt es in dem Pop-Lösungsarchiv, anders als im Gosh-Archiv, noch einen zusätzlichen Pointerzustand, der eine ungültige Lösung markiert. Die Pointer können daher folgende Zustände annehmen:</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head></head><label></label><figDesc>Lösungsarchiv verwendet. Die beiden Archive wurden in den Arbeiten von Wolf [15] und Sonnleitner [13] bereits implementiert. Diese Archive wer- den als Ausgangsposition genommen und durch eine Bounding Strategie basierend auf einem Branch and Bound Verfahren erweitert. Wie in Kapitel 1.5 bereits beschrieben, besteht das Branch and Bound Verfahren aus zwei Schritten, dem Verzweigen (Branch) und dem Abgrenzen (Bound). Der Branch- Schritt ergibt sich aus dem Lösungsarchiv. Das Archiv kann im Prinzip als Entschei- dungsbaum angesehen werden. In jedem Trie Knoten wird für einen bestimmten Clus- ter eine Entscheidung getroffen und somit entstehen dadurch die verschiedenen Teil- probleme. Im Gosh-Archiv bestehen die Entscheidungen in den Trie-Knoten aus der Auswahl eines Knoten innerhalb eines Clusters, während im Pop-Archiv entschieden wird, welchen Vorgänger der Cluster in dem Spannbaum hat. Für den Bound-Schritt muss eine untere und eine obere Schranke definiert werden. Als obere Schranke wird immer die bisher beste Lösung, die vom Evolutionären Algorithmus gefunden wurde, genommen. Die untere Schranke wird in den einzelnen Trie-Knoten berechnet. Wie die Berechnung genau erfolgt, wird in den Kapiteln 2.1 und 2.2 erläutert. Falls hier eine untere Schranke gefunden wird, die größer als die beste bisher gefundene Lösung ist, kann dieser Teil des Lösungsarchivs als complete markiert werden. Im weiteren Verlauf des Algorithmus werden diese Lösungen schon als besucht erkannt und somit im EA nicht mehr berücksichtigt. Es gibt prinzipiell zwei Möglichkeiten wann eine Bound berechnet wird. Zum einen beim Einfügen der Lösung im Lösungsarchiv und zum anderen beim Konvertieren einer schon eingefügten Lösung zu einer neuen. In dieser Arbeit werden beide Varianten untersucht und auch miteinander kombiniert. 2.1 Boundberechnung im Gosh-Archiv Die Boundberechnung erfolgt immer für einen bestimmten Pointer in einem Trie-Knoten. Bei der Gosh-Kodierung wird, wie in Kapitel 1.4.1 bereits erläutert, für jeden Cluster gespeichert, welcher Knoten in dem Cluster ausgewählt wurde. Soll in einem bestimmt- en Trie-Knoten die Bound berechnet werden, bedeutet das, dass für alle Cluster vom aktuellen Trie-Knoten bis hin zur Wurzel schon eine Auswahl der Knoten in den Clus- tern getroffen wurde. Für alle Cluster in den darunterliegenden Trie-Ebenen wurde noch keine Auswahl getroffen.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head></head><label></label><figDesc>Kanten zwischen allen Paaren von Clustern, für die noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head></head><label></label><figDesc>). Die Berechnung des Spannbaums erfolgt mit einem Kruskal Algorithmus mit Union-Find. Die Laufzeit dieses Algorithmus wird durch das Sortieren der Kanten bestimmt. Da der Graph G ein vollständiger Graph ist, entspricht die Anzahl der Kanten |E| = m * (m − 1). Dadurch ergibt sich eine Laufzeit von O(mAbb. 5: Boundberechnung im Cluster V 3 beim Einfügen der Lösung &lt;321112&gt;</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head></head><label></label><figDesc>Das führt aber zu einem Problem. Die Berechnung der Bound hat eine Laufzeit von O(m 2 log(m 2 )). Wenn in jedem Trieknoten die Bound berechnet wird, müsste die Bound m-mal ermittelt werden. Das würde zu einer Laufzeit von O(mwas eine erhebliche Verschlechterung gegenüber der normalen Einfüge-Operation ohne Boundberechnung, mit einer Laufzeit von O(m), wäre. Eine Möglichkeit dieses Problem abzuschwächen ist es, die Bound nicht in jedem der m Trie-Knoten zu berechnen, sondern nur in einer bestimmten Auswahl von Knoten. Dazu wurde der Parameter branch_and_bound_prob eingeführt, mit dem angegeben werden kann, mit welcher Wahrscheinlichkeit eine Boundberechnung für einen Trie- Knoten durchgeführt wird. Als ein guter Wert für diesen Parameter hat sich 0, 05 her- ausgestellt. Das bedeutet, es wird für 5% der Trie-Knoten die Bound berechnet. Die Auswahl erfolgt dabei zufällig. In Algorithmus 2 ist der Pseudocode für die Einfüge-Operation mit Boundberechnung dargestellt. Diese beruht auf der Einfüge-Operation von Wolf [15], nur dass diese durch die Bounding Strategie erweitert wurde. Zunächst wird der Vektor V 0 , in der alle Clus- ter gespeichert sind, die noch nicht in das Archiv eingefügt worden sind, initialisiert. Ausgehend vom Wurzelknoten wird nun immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Der Cluster wird dabei immer aus dem Vektor V 0 entfernt und dem Vektor V 1 hinzugefügt, indem alle Cluster gespeichert sind die schon eingefügt worden sind. Diese beiden Vektoren wer- den dann für die spätere Boundberechnung benötigt. Ist der Pointer gleich null, muss ein neuer Trie-Knoten angelegt werden. Dazu wird zufällig ein Cluster aus dem Vektor V 0 ausgewählt. Danach wird, mithilfe des Parameters branch_and_bound_prob, er- mittelt ob für diesen Trie-Knoten eine Bound berechnet werden soll. Wird eine Bound berechnet und ist sie schlechter als die beste bisher gefundene Lösung, werden alle Trie-Knoten in den darunterliegenden Sub-Trie gelöscht und der Pointer als complete markiert. Anschließend wird die Einfüge-Operation abgebrochen und f alse als Rück-Algorithmus 2 GoshTrie insert with Bound Eingabe: sol -solution to insert; best solution bestsol Ausgabe: insertion successfull (true/false) Variablen: m=number of clusters; root=root from archivcurr.next[pos] ← new node with cluster randcurr ← curr.next[pos] 26: end for 27: check if there are complete subtrees along sol 28: return true gabewert zurück gegeben. Das hat zur Folge, dass die Lösung so behandelt wird als wäre sie schon einmal einge- fügt worden und es wird eine neue Lösung generiert. Wenn das Einfügen erfolgreich war, wird von unten nach oben entlang von sol untersucht, ob bei einem Trie-Knoten alle Pointer complete sind. Ist das der Fall kann dieser gelöscht werden und der Pointer im Eltern Knoten auf complete gesetzt werden.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>0 3 :</head><label>3</label><figDesc>while curr! = null &amp;&amp; curr! = complete doif curr.next[sol[curr.cluster]]! = complete] thenDie Boundberechnung erfolgt, genauso wie beim Gosh-Archiv auch, immer für einen bestimmten Pointer in einem Trie-Knoten. Bei der Pop-Kodierung wird, wie in Kapi- tel 1.4.2 erläutert, für jeden Cluster der Vorgänger des minimalen Spannbaums, der aus den globalen Graphen G G erzeugt wird, gespeichert. Wenn in einem bestimmten Trie- Knoten die Bound berechnet werden soll, bedeutet das, dass für alle Cluster vom ak- tuellen Trie-Knoten bis hin zur Wurzel der Vorgänger bereits ausgewählt wurde. Diese Menge wird als V 1 bezeichnet. Für alle Cluster in den darunterliegenden Trie-Ebenen wurde noch keine Auswahl getroffen. Sie sind noch mit keinem Cluster verbunden.Die Berechnung der Bound erfolgt nun in mehreren Schritten. In Algorithmus 4 wird in dem Pseudocode gezeigt, wie die Boundberechnung funktioniert. Zunächst wird ein Vektor data erzeugt, indem am Ende der Funktion die ausgewählten Knoten in den Clustern gespeichert werden. Die Elemente von data werden mit -1 initialisiert. Danach wird mit den Methoden calcClusters und generateList durch dynamische Programmierung für die einzelnen Bäume von G ermittelt, welche Knoten innerhalbuntil it exists a nextinnerN ode 11: bound ← calculateBound(sol, data, aktP os) 12: return bound der Cluster ausgewählt werden sollen. Die Knoten werden so ausgewählt, dass die Kosten der daraus entstehenden Lösung minimal sind. Begonnen wird dabei mit dem Baum der vom Wurzelknoten des Lösungsarchivs ausgeht. Danach wird geprüft, ob es noch ein Cluster in C ∈ V 1 gibt, für den noch kein Knoten ausgewählt wurde, d.h. dessen Eintrag in data noch -1 ist. Falls es so einen Cluster gibt, wird für diesen Cluster C der Wurzelknoten des Baums, in dem er sich in G befindet, ermittelt. Von diesem Wurzelknoten wird nun wieder mit calcClusters und generateList eine Auswahl der Knoten für die Cluster des Baums getroffen. Das wird solange wiederholt bis für alle Cluster in V 1 eine Auswahl getroffen wurde.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>1 :</head><label>1</label><figDesc>for i=0. . . aktP os do</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head></head><label></label><figDesc>Eingabe: current cluster cN r; solution sol; data Variablen: minW eight=current minimal weight of the cluster 1: childCl ← all cluster which predecessor is cN r in sol 2: for all nodes parentN ode in cluster cN r dofor all nodes childN ode in cluster child dovalue= nodes[childN ode].weight + distance(parentN ode, childN ode)nodes[parentN ode].addF olower(child, minChildN odeN r, minV alue)if nodes[parentN ode].weight &lt; minWeight then 14: minW eight = nodes[parentN ode].weight 15: data[cN r] = parentN odeEingabe: current cluster cN r; node -selected node of cluster cN r node; solution sol; data; current level of the trie aktP os 1: data[cN r] = node 2: for i=0 . . . aktP os doif sol[i] == cN r thengenerateList(i, nodes[node].getF ollower(i), data, sol, aktP os)Die Laufzeit der Boundberechnung wird durch die Berechnung der Kosten für die einzel- nen Knoten bestimmt. Im schlimmsten Fall müssen für alle Knoten des Graphen die Kosten berechnet werden. Deshalb kommt es zu einer Laufzeit von O(n</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>1 :</head><label>1</label><figDesc>if !valid[cNr] thenfor i=0. . . aktP os doIn [10] wurde ein Ansatz verfolgt, indem für die Berechnung eines GTSP sogenannte "candidate lists" verwendet wurden, um den Suchraum einzuschränken. Dabei wurden für jeden Knoten die n nächsten Nachbarn in einer Liste gespeichert und nur diese als mögliche Nachfolger in der Tour betrachtet. Der Ansatz wird auch in dieser Arbeit ver- folgt. Dazu wird die Rekombinations-und Mutations-Methode des EAs entsprechend angepasst. Außerdem wird in der Konvertierungs-Methode des Pop-Lösungsarchivs die Nearest Neighbour Reduktion auch angewendet. Darauf wird später in Kapitel 2.2.4 genauer eingegangen werden.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head></head><label></label><figDesc>Beide Vorgänger sind nicht in der Menge der Nearest Neighbours von C i : Hier wird ebenfalls einer der beiden zufällig ausgewählt.In der Mutations-Methode wird an einer zufällig ausgewählten Stelle in der Lösung eine Änderung vorgenommen. Der Ablauf der Mutations-Methode ist wie folgt: Zuerst wird zufällig ein Cluster C i in der Lösung ausgewählt, dessen Vorgänger geändert werden soll. Danach werden alle Nearest Neighbours ermittelt, deren direkten oder indirekten Vorgänger nicht C i ist. Im nächsten Schritt wird aus dieser Liste zufällig ein neuer Vorgänger ermittelt und in die neue Lösung gespeichert. Gibt es keinen solchen Nearest Neighbour, werden mit Hilfe eines Tiefensuche-Algorithmus alle möglichen Cluster, deren direkten oder indirekten Vorgänger nicht C i ist, ermittelt. Danach wird aus diesen Clustern einer zufällig ausgewählt und als neuer Vorgänger für C i genommen. In Algo- rithmus 9 wird gezeigt wie die Mutations-Methode funktioniert.cand ←all cluster where mutate is not the direct or indirect predeccessor in sol 5: end if 6: pred new ← random element from cand 7: sol[mutate] ← pred new</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head></head><label></label><figDesc>if curr.next[pos] == null thenif i == m − 1 thenDer Ablauf der Insert-Methode wird in Algorithmus 10 gezeigt. Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Ist ein solcher</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head></head><label></label><figDesc>Genauso wie bei der Insert-Methode in Kapitel 2.2.3, wird in dieser Methode beim er- sten Aufruf von calcBoundByDynP rog die Bound mittels "normalen" dynamischen Programmierung ermittelt. Bei allen weiteren Boundberechnungen innerhalb dersel- ben Konvertierungsoperation, wird die inkrementelle dynamische Programmierungs- Methode verwendet. Dazu wird vor jeder Boundberechnung die Methode invalidate aufgerufen, die alle Cluster markiert, für die die Kosten neu berechnet werden müssen.Algorithmus 11 PopTrie convert with Bound Eingabe: solution to convert sol; best solution bestsol Ausgabe: convertion successfull (true/false) Variablen: nn[i]... Nearest Neighbours of Cluster i 1: curr ← random trie-node of the possible startpoints from sol 2: while curr! = null &amp;&amp; curr! = complete doif curr.next[sol[curr.cluster]]! = complete] thenif bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) thensol[curr.cluster] ← random not-complete-pointer from nn[curr], if none exist, random not-complete-pointer from all pointer in currif bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) thendelete curr.next[sol[curr.cluster]] and set it completeDie folgenden Tests wurden mit 14 TSPLib-Instanzen 1 durchgeführt. Diese Instanzen sind ursprünglich für das Traveling Salesman Problem erzeugt worden und wurden für das GMST-Problem angepasst. Dazu wurden Cluster der Instanz hinzugefügt und die einzelnen Knoten mittels geografischem Clustering zugeordnet. Die verwendeten In- stanzen bestehen aus 150-442 Knoten und 30-89 Clustern. Im Schnitt hat also jedes Cluster 5 Knoten. Die erweiterten TSPLib-Instanzen wurden auch von Wolf [15] und Sonnleitner [13] verwendet, was einen Vergleich der Ergebnisse erleichtert.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14" validated="false"><head>Tabelle 1 :</head><label>1</label><figDesc>Testinstanzen und die verwendete Laufzeitim Bereich T rie + convert − Bound die Bounding-Strategie innerhalb der Konvertierungs-Methode und unter T rie + ins&amp;conv − Bound bei der die Bounding- Strategie in beiden Methoden gleichzeitig verwendet wird dargestellt. C avg entspricht dem durchschnittlichen Lösungswert über alle Runs, darunter in Klammern steht die Standardabweichung und Gen ist die durchschnittliche Anzahl der erzeugten Genera- tionen. In den Ergebnissen ist zu sehen, dass alle drei Bounding Varianten gegenüber des "nor- malen" Archivs bessere Ergebnisse liefern. Die Variante, in der die Bounding Strate- gie in beiden Methoden verwendet wurde, liefert jedoch gegenüber der beiden anderen Varianten schlechtere Ergebnisse. Dieses Resultat ist auf die geringere Anzahl von erzeugten Generationen zurück zu führen. In einigen Instanzen wurden nur halb so viele Generationen erzeugt als in den anderen Varianten.Tabelle 3: Vergleich der verschiedenen Bounding-Varianten im Gosh-Archiv Trie Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound Instanz C avg (T ) Gen C avg (T ) Gen C avg (T )895,133.368 21.891,1 21.467 21.890,1 16.071 21.890,6 11.354,326.404 20.339,7 15.985 20.346,2 13.081 20.341,0 11.pcb442 19.667,218.106 19.657,4 7.576 19.648,9 10.707 19.Als nächstes wurde versucht herauszufinden, wie sich der Nearest-Neighbours-Ansatz, der in Kapitel 2.2.2 erläutert wurde, auf den Evolutionären Algorithmus auswirkt. Bei diesen Tests wurde der EA ohne Archiv verwendet. Dabei wurde der EA einmal mit und einmal ohne dem Nearest-Neighbours-Ansatz verwendet und miteinander verglichen. Bei diesem Test wurde der Parameter num_nearest_neighbour, der angibt, wie viele Nachbarn in der Nearest-Neighbour-List eines Clusters enthalten sind, auf 5 gesetzt. D.h. es werden für jeden Cluster die 5 nächsten Nachbarn bevorzugt. In Tabelle 4 sind die Ergebnisse dieses Tests dargestellt. Hier ist zu sehen, dass der EA mit dem Nearest- Neighbours-Ansatz für alle Instanzen eine Verbesserung liefert. Für die nachfolgenden Tests wurde daher der Nearest-Neighbours-Ansatz auch verwendet. Tabelle 4: Vergleich von "normalen" EA mit einem EA mit Nearest NeighboursTabelle 5: Vergleich der verschiedenen Bounding-Varianten im Pop-Archiv Trie Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| kroa150 9.815,0 62.747 9.815,0 44.525 9.815,0 32.376 9.815,021.886,0 36.538 21.886,0 23.104 21.886,0 22.734 21.886,0 13.318,6 28.971 20.316,1 18.548 20.316,0 20.506 20.320,6 13.pcb442 19.630,2 26.755 19634,4 15.859 19.627,7 22.892 19.627,4 13.In diesem Kapitel wurde der Vergleich der verschiedenen Bounding-Strategien auch für das Pop-Archiv durchgeführt. In Kapitel 3.2.1 wurde in dem Test herausgefunden, dass Cuts in allen Ebenen des Tries vorkommen können. Deshalb wurde für den Vergleich der Bounding-Strategien der Parameter skip_bound hier nicht verwendet, d.h. die Bound wurde in jeder Ebene berechnet. Für den Parameter branch_and_bound_prob wurden für das Pop-Archiv, genau wie im Kapitel 3.2.2 für das Gosh-Archiv, Tests mit unterschiedlichen Werten für diesen Parameter gemacht. Mit dem Resultat, dass auch hier der Wert 0, 05 die besseren Ergebnisse liefert. Tabelle 5 zeigt die Ergebnisse für diesen Test. Hier ist zu sehen, dass die Varianten mit den Bounding-Strategien meistens besser sind als die Variante mit "normalem" Archiv. Außer für die Instanzen kroa150, pr226, pr264 und f l417 für die auch mit dem Archiv ohne Bounding-Strategie das Optimum erreicht wurde.In [13] wurde eine Variante getestet, bei der beide Archive gleichzeitig verwendet wur- den. In dieser Arbeit soll auch getestet werden, wie sich die Bounding-Strategie in den verschiedenen Varianten auswirkt, wenn beide Archive gleichzeitig verwendet werden. Der Parameter skip_bound wird auf 0, 5 gesetzt. Dieser hat aber nur Auswirkungen auf das Gosh-Archiv, d.h. im Pop-Archiv werden in allen Ebenen Bounds berechnet. Der Parameter branch_and_bound_prob wurde, genau wie bei den vorherigen beiden Tests, auf 0, 05 gesetzt.</figDesc><table></table></figure>

			<note place="foot" n="1"> http://elib.zib.de/pub/Packages/mp-testdata/tsp/tsplib/tsp/index.html</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gosh-und Pop Archiv</head><p>Trie</p><p>Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| kroa150 9.815,0 21.637 9.815,0 14.801 9.815,0 9.853 9.815,0 7.638 (0,0) (0,0) (0,0) (0,0) rat195 752,1 18.540 751,3 11.167 <ref type="bibr">752,8 9.476 752,6 5.372 (2,8)</ref> (1,4) (3,4) (3,2) d198 7.044,0 11.199 7.044,0 7.149 7.044,0 5.418 7.044,0 3.924 (0,0) (0,0) (0,0) (0,0) krob200 11.244,016.633 11.244,0 10.592 11.244,0 10.370 11.244,0 7.531 (0,0) (0,0) (0,0) (0,0) ts225 62. <ref type="bibr">268</ref>  </p><p>9.815,0 9.815,0 9.815,0 9.815,0 (0,0) (0,0) (0,0) d198 7.062,0 7.044,0 7.044,0 7.044,0 (0,0) (0,0) (0,0) krob200 11.245,0 11.244,0 11.244,0 11.244,0 Diese Varianten wurden in den beiden Archiven getestet und verglichen. Im Gosh- Archiv haben die Bounding Varianten in allen Instanzen bessere Ergebnisse erzielt, als bei der "normalen" Variante. Die Variante, in der in beiden Methoden die Bounding- Strategie verwendet wird, hat jedoch schlechtere Ergebnisse gebracht als in den anderen beiden Bounding-Varianten. Das ist auf die geringere Anzahl von erzeugten Gener- ationen zurück zu führen. Im Pop-Archiv waren die Ergebnisse der Bounding Vari- anten ebenfalls besser als die der "normalen" Variante. Bei der Variante, in der beide Archive gemeinsam verwendet wurden, haben die Bounding-Varianten ebenfalls eine Verbesserung erzielt. Beim Vergleich zwischen den Archiven kann man sagen, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen bei- den Varianten.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Generalized Spanning Trees and Extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Feremans</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>Universite Libre de Bruxelles, Diss.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Solving medium to large sized Euclidean generalized minimum spanning tree problems / Indian Institute of Management, Research and Publication Department</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ghosh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Computing Generalized Minimum Spanning Trees with Variable Neighborhood Search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leitner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Raidl</surname></persName>
		</author>
		<editor>HANSEN, P.</editor>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mladenovi´novi´</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A M</forename><surname>Pérez</surname></persName>
		</author>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">M</forename><surname>Batista</surname></persName>
		</author>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Moreno</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Vega</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hrsg</surname></persName>
		</author>
		<title level="m">Proceedings of the 18th Mini Euro Conference on Variable Neighborhood Search. Teneriffa, Spanien</title>
		<meeting>the 18th Mini Euro Conference on Variable Neighborhood Search. Teneriffa, Spanien</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Combining Variable Neighborhood Search with Integer Linear Programming for the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leitner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Raidl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Heuristics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="473" to="499" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Evolutionary Algorithm with Solution Archive for the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Raidl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EUROCAST 2011-13th International Conference on Computer Aided Systems Theory</title>
		<editor>QUESADA-ARENCIBIA, A.</editor>
		<meeting>EUROCAST 2011-13th International Conference on Computer Aided Systems Theory<address><addrLine>Las Palmas de Gran Canaria, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="256" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An efficient algorithm for generalized minimum spanning tree problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<idno>978-1-4503-0072-8</idno>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;10: Proceedings of the 12th annual conference on Genetic and evolutionary computation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Solving Two Generalized Network Design Problems with Exact and Heuristic Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leitner</surname></persName>
		</author>
		<editor>G. Raidl and B. Hu</editor>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">S</forename><surname>Myung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Tcha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="231" to="241" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Einführung in Evolutionäre Algorithmen.: Optimierung nach dem Vorbild der Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Nissen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Vieweg</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A hybrid heuristic approach for solving the generalized traveling salesman problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Pop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Iordache</surname></persName>
		</author>
		<imprint>
			<publisher>KRASNOGOR</publisher>
			<pubPlace>Natalio (Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pier</forename><forename type="middle">L</forename><surname>Lanzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hrsg</surname></persName>
		</author>
		<title level="m">GECCO, ACM</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="481" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Pop</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<pubPlace>Diss</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Twente</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Enhancing Genetic Algorithms by a Trie-Based Complete Solution Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolutionary Computation in Combinatorial Optimisation-EvoCOP</title>
		<imprint>
			<biblScope unit="page" from="239" to="251" />
			<date type="published" when="2010" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Ein neues Lösungsarchiv für das Generalized Minimum Spanning Tree-Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sonnleitner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Enhancing a Genetic Algorithm by a Complete Solution Archive Based on a Trie Data Structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Šramko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Ein Lösungsarchiv-unterstützter evolutionärer Algorithmus für das Generalized Minimum Spanning Tree-Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wolf</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">A Complete Archive Genetic Algorithm for the Multidimensional Knapsack Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zaubzer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
