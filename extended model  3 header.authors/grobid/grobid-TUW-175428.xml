<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="de">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Misar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Fakultät für Informatik</orgName>
								<orgName type="institution">Technischen Universität Wien</orgName>
								<address>
									<postCode>0025068</postCode>
									<settlement>Matrikelnummer</settlement>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>! FAKULTÄT FÜR !NFORMATIK Ein hybrides Verfahren basierend auf Variabler Nachbarschaftssuche und Dynamischer Programmierung zur Tourenfindung in einem Ersatzteillager mit domänenspezifischen Nebenbedingungen DIPLOMARBEIT zur Erlangung des akademischen Grades Diplom-Ingenieur im Rahmen des Studiums Software Engineering &amp; Internet Computing eingereicht von Betreuung: Betreuer: Univ.Prof. Dipl.-Ing. Dr. Günther Raidl Mitwirkung: Univ.Ass. Mag. Dipl.-Ing. Matthias Prandtstetter</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="de">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Danksagung</head><p>Die vorliegende Arbeit durfte ich am Institut für Computergraphik und Algorithmen der Technischen Universität Wien erstellen und es freut mich diese nun fertig in Händen halten zu können.</p><p>Ich möchte mich für die Geduld und Mithilfe von Seiten Günther Raidls bedanken und ebenso Matthias Prandtstetter großen Dank für seine Betreuung aussprechen. In den vergangenen Monaten hat er einen besonders großen Beitrag zur Vervollständi- gung dieser Arbeit geleistet. Natürlich gilt meine Anerkennung auch allen anderen Personen, die von Seiten des Instituts ihren Anteil an der Entstehung dieser Arbeit hatten.</p><p>Es ist mir weiters ein Anliegen auch all jene zu erwähnen, die mich im Laufe des gesamten Studiums begleitet und unterstützt haben. Dazu zählen vor allem meine Studienkollegen Christian und Gerhard, sowie gleichermaßen auch meine Eltern, die mir zu jedem Zeitpunkt eine große Hilfe waren und Linda, der ich an dieser Stelle für ihre Ausdauer und Motivation danken will.</p><p>iii iv Erklärung zur Verfassung der Arbeit Hiermit erkläre ich, Thomas Misar, wohnhaft in 1070 Wien, Seidengasse 3/108, dass ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten Quellen und Hilfs- mittel vollständig angegeben habe und dass ich die Stellen der Arbeit (einschließlich Tabellen, Karten und Abbildungen), die anderen Werken oder dem Internet im Wort- laut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe. <ref type="bibr">Wien, 20.04.2009</ref> ( </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract</head><p>Within this thesis a real-world problem related to a warehouse for spare parts is considered. Regarding several constraints typically stated by spare parts suppliers the time needed to collect articles should be minimized. Based on continuously arriving orders by customers predefined delivery times and capacity constraints have to be met. To accomplish this task efficient pickup tours need to be determined which is the main issue covered by this work which comes to an end with experimental results of a concrete implementation of the proposed approach.</p><p>The algorithm presented embeds a specifically developed dynamic program for com- puting optimal walks through the warehouse into a general variable neighborhood search (VNS) scheme. Several stages are used for first splitting up all orders, then creating tours out of the results and finally assigning them to available workers. The VNS uses a variant of the variable neighborhood descent (VND) as local improve- ment procedure. While the neighborhood structures defined are intended to produce candidate solutions, a dynamic program specially designed to compute optimal order picking tours is used to evaluate them. For this purpose properties specific to ware- houses are exploited such to compute optimal routes within polynomial time. The final assignment of workers to tours is realized by another VNS. The task is then to find an allocation such that the last article to be picked up will be collected as early as possible.</p><p>Evaluations of experimental results of a concrete implementation indicate that the presented approach provides valuable pickup plans and computation times can be kept low. Moreover the performed test runs have been compared to a reference so- lution which was computed based on an approach found in relevant literature. A detailed analysis of the obtained results showed that the application of the proposed approach to real-world instances is promising whereas the savings with respect to working time can be kept high. Overall an efficient as well as effective approach is introduced to solve this real-world problem.</p><p>ix x</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problembeschreibung</head><p>Die folgende Aufgabenstellung stammt in ihrer ursprünglichen Form von der Firma Dataphone GmbH und wurde in Zusammenarbeit mit Mitarbeitern des Instituts für Computergraphik und Algorithmen der Technischen Universität Wien angepasst, um innerhalb eines gemeinsamen Projekts einen Lösungsansatz dafür zu entwerfen.</p><p>Im Zuge der Reorganisation und Erweiterung des Lagers eines Ersatzteillieferanten soll eine automationstechnisch unterstützte Lagerverwaltung eingeführt und ausge- baut werden, die unter anderem die Möglichkeit bieten soll, einzelne Prozessabläufe im Lageralltag zu rationalisieren. Zu diesem Zweck wurden sämtliche Artikel bezie- hungsweise jene Ladungsträger, auf denen sich die Artikel befinden, mit maschinen- lesbaren Kodierungen, konkret mit Barcodes, versehen und eine zentrale Lagerver- waltungssoftware eingeführt. Auf Basis einer im Hintergrund eingerichteten Daten- bank erlaubt die grafische Oberfläche der Software die Erfassung und Verwaltung von Stammdaten und Bestelldaten sowie den Zugriff auf den aktuellen Lagerstand.</p><p>In einer ersten Ausbaustufe soll vor allem die Zusammenstellung der einzelnen von Kunden in Auftrag gegebenen Bestellungen möglichst effizient realisiert werden, wo- bei folgende Schritte zu berücksichtigen sind:</p><p>1. Ein Kunde gibt eine Ersatzteillieferung in Auftrag.</p><p>2. Für jeden Auftrag fasst ein Lagerarbeiter die erforderliche Anzahl der bestellten Artikel aus dem Lager aus und bringt sie in eine so genannte Verdichtungszone.</p><p>3. Ein dieser Verdichtungszone zugeteilter Mitarbeiter packt alle zu den jeweili- gen Bestellungen gehörenden Einzelteile in entsprechend dimensionierte Kisten, versieht diese mit Adresstickets und leitet sie an den Lieferanten (Paketdienst, Post, etc.) weiter.</p><p>Während der erste und der dritte Punkt dieser Abarbeitungsreihenfolge derzeit schon verlässlich und ohne gröbere Verzögerungen ablaufen, stellt der zweite Punkt den Flaschenhals in der Zusammenstellung der Aufträge dar, da hierbei die Mitarbeiter große Strecken im Lager zurücklegen müssen, um alle Einzelteile einzusammeln. Da im Normalfall bis zu sechs Mitarbeiter gleichzeitig an bis zu 1000 täglichen Aufträgen bestehend aus je fünf unterschiedlichen Artikeln arbeiten, gibt es durch geschickte Aufteilung der Aufträge ein großes Einsparungspotential, sofern eine geschickte Ein- teilung von Artikeln zu Touren vorgenommen wird. Folgender neu gestalteter Ablauf soll daher realisiert werden:</p><p>1. Mehrere Kunden geben (unabhängig voneinander) jeweils eine Ersatzteilliefe- rung in Auftrag.</p><p>2. Alle derzeit im Lager tätigen Mitarbeiter bekommen jeweils eine Liste von Artikeln, die sie entlang einer vorberechneten Tour im Lager auf Kommissio- nierungswagen laden sollen. Diese Artikel können im Allgemeinen auch zu un- terschiedlichen Aufträgen gehören.</p><p>3. Nach Abarbeitung dieser Liste stellt jeder Mitarbeiter den von ihm bedienten Kommissionierungswagen in der Verdichtungszone ab und entnimmt dort einen weiteren, allerdings leeren Kommissionierungswagen, um sich auf eine neue Tour zum Ausfassen weiterer Artikel zu machen.</p><p>4. Der Mitarbeiter in der Verdichtungszone verfährt weiterhin so, dass er alle Artikel eines Auftrags in entsprechende Schachteln verpackt und an den Bo- tendienstübergibttendienst¨tendienstübergibt. Dabei muss er allerdings beachten, dass nun die Artikel, die einer Bestellung zugeordnet sind, auf unterschiedlichen Kommissionierungswa- gen zwischengelagert sein können.</p><p>Die Verdichtungszone selbst (siehe Abb. 2.1) ist in drei Zonen unterteilt, die als eine Art Zwischenlager verstanden werden können. Von dort holen die Lagermitarbeiter leere Kommissionierungswagen, um Artikel aus dem Lager auszufassen und stellen diese befüllt wieder dort ab. Mitarbeiter, die für Verpackung und Versand zuständig sind, können dann von dort die entsprechenden Waren abholen und die Bestellabwick- lung fortsetzen. Da diese einzelnen Zonen entsprechend weitläufig sind, um genügend Platz zu bieten, ist vorgesehen, dass alle zu einer Bestellung gehörigen Artikel inner- halb derselben Zone abgeliefert werden sollen. Dies verringert den Zeitaufwand für die Verpackung und macht die Arbeit in der Verdichtungszone wesentlich einfacher und effizienter.</p><p>Gegenstand dieser Arbeit ist nun die Entwicklung eines Lösungsansatzes, mit dessen Hilfe es möglich wird, die Aufteilung der Bestellungen auf unterschiedliche Mitarbei- ter derart zu optimieren, dass die Touren der Kommissionierer möglichst kurz wer- den, wodurch gleichzeitig der zeitliche Abstand zweier Entnahmen einzelner Artikel aus dem Lager minimiert wird. Ausschlaggebend hierfür ist, dass durch diese Auf- teilung der Bestellungen auf mehrere gleichzeitig im Lager arbeitende Personen bei entsprechender Optimierung große Einsparungen erreicht werden können, da für die Mitarbeiter besser organisierte Touren mit kürzeren Wegen möglich sind. Weiters soll erreicht werden, dass die jeweils zu einer gemeinsamen Bestellung gehörenden Artikel ungefähr zeitgleich in der Verdichtungszone bereitgestellt und im Weiteren verpackt werden, um mehrere Aufträge ohne den Einsatz größerer Zwischenlager gleichzeitig bearbeiten zu können.</p><p>Neben dieser prinzipiellen Aufgabenstellung müssen jedoch noch mehrere Nebenbe- dingungen berücksichtigt werden, die einen entscheidenden Einfluss auf die tatsächli- che Realisierung der einzelnen Kommissionierungstouren haben:</p><formula xml:id="formula_0">4 Verdichtungszone W W W W W W W W VZ 1 W W W W W W W W W W W W W W W W VZ 2 Verpackung &amp; Versand W W W W W W W W W W W W W W W W VZ 3 W W W W W W W W W Stellplatz für Kommissionierungswagen</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abbildung 2.1: Schematische Darstellung der Verdichtungszone</head><p>• Die Kommissionierungswagen können einerseits nur bis zu einer gewissen Ka- pazität beladen werden und andererseits ist es aufgrund ihrer Bauweise nur vorgesehen, dass sie sich in eine Richtung bewegen. Wegen des schmalen Gang- systems ist ein Umkehren innerhalb eines Ganges nicht ohne Weiteres möglich.</p><p>• Dië Uberkreuzung zweier Kommissionierungstouren innerhalb eines Regalgan- ges sollte möglichst vermieden werden, da aufgrund der Platzbeschränkung ein¨Uberholen ein¨ ein¨Uberholen oder aneinander Vorbeifahren nicht möglich ist.</p><p>• Manche Artikel können an mehreren Positionen im Lager verfügbar sein. Ab- hängig von der bestellten Menge müssen oder können dann unter Umständen auch mehrere solcher Lagerplätze für einen Artikel angefahren werden.</p><p>• Einen weiteren Aspekt birgt die Tatsache, dass nicht alle an einem Tag zu bearbeitenden Bestellungen zu Arbeitsbeginn bereits bekannt sind, da noch im Laufe des Tages weitere Bestellungen eintreffen können. Dies entspricht sogar eher dem Normalfall, wodurch Anzahl und Struktur der zu bearbeitenden Aufträge im Laufe des Tages stark variieren. Ein Lösungsansatz soll das insofern berücksichtigen, als die Berechnungen jederzeit mit angepassten Eingabewerten wieder gestartet werden können sollen. Das heißt, es wird immer mit den aktuell offenen Bestellungen neu gerechnet.</p><p>• Die Bearbeitung von Bestellungen sollte nach Möglichkeit in der Reihenfolge ihres Eintreffens geschehen, um die Lieferzeiten möglichst sicher einhalten zu können.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head><p>• Die zuvor beschriebene Einteilung der Verdichtungszone in drei Zonen muss derart berücksichtigt werden, dass von den Kommissionierern ausnahmslos alle zu einer Bestellung gehörigen Artikel in derselben dieser drei Zonen abgeliefert werden.</p><p>Durch mobile Datenerfassungsgeräte soll der Optimierungsprozess unterstützt wer- den, da der Einsatz dieser Geräte es ermöglicht, die Entnahme eines Artikels be- ziehungsweise Abgabe eines Kommissionierungswagens in der Verdichtungszone in Echtzeit nachzuvollziehen. Dieses neue Lagerverwaltungssystem soll das derzeitige Verfahren ablösen, bei dem alle Entscheidungen durch Mitarbeiter getroffen werden.</p><p>Unter Berücksichtigung dieser Einschränkungen gilt es nun vorrangig die Berechnung von kürzesten Touren für die Mitarbeiter zu behandeln.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mögliche Erweiterungen</head><p>Die folgende Auflistung eröffnet mögliche Erweiterungen der gegebenen Problem- beschreibung, wobei deren Umsetzung aufgrund von massivem Mehraufwand nicht erfolgte. ¨ Uberdies beeinflussen diese Aspekte den Kern der Arbeit nicht, wodurch die zentralen Ergebnisse des vorgestellten Verfahrens ihre Aussagekraft behalten.</p><p>Folgende Punkte sind als zusätzliche Funktionalitäten und Optionen denkbar:</p><p>• Die im Lager verfügbaren Kommissionierungswagen haben durchaus unter- schiedliche bauartliche Voraussetzungen, was sich auf damit verbundene Eigen- schaften, wie Geschwindigkeit, Ladefläche oder Manövrierfähigkeit, auswirkt. Ein entwickelter Lösungsansatz dafür sollte dann genügend Flexibilität aufwei- sen, um damit umgehen zu können. Die Palette an Transportmitteln reicht dabei von " einkaufswagenähnlichen" Fahrzeugen bis hin zu Gabelstaplern.</p><p>• Die eingeschränkte Bewegungsfreiheit aufgrund der sehr schmalen Gänge im Lager verhindert es, dass zwei Kommissionierungswagen aneinander vorbeifah- ren können. Um Kollisionen auszuschließen, wäre es denkbar einen Algorithmus zu entwerfen, der entsprechende Zustände verbietet.</p><p>• Ein weiterer Punkt in Zusammenhang mit den im Lager verwendeten Fahrzeu- gen bezieht sich auf die Sicherheitsbestimmungen in Bezug auf Gabelstapler. Diese schreiben es prinzipiell vor, dass sich in einem Gang kein anderer Mit- arbeiter gleichzeitig mit einem Gabelstapler aufhalten darf. Die Sperrung von solchen Gängen muss dann natürlich berücksichtigt werden.</p><p>• Es kann der Fall auftreten, dass der Lagerleiter befindet, einen Lagerplatz mit einem anderen Artikel belegen zu wollen. In einem solchen Fall muss die Möglichkeit gegeben sein, dass der anderweitig benötigte Lagerplatz möglichst schnell (gleichzeitig aber kosteneffizient) leer geräumt wird.</p><p>• Weiters liegt durch das ständige Eintreffen von Bestellungen im Laufe eines Ar- beitstages der Anspruch an eine Online-Optimierungsaufgabe nahe. Das heißt, dass aktuell eintreffende Bestellungen jederzeit in den Optimierungsprozess aufgenommen werden können müssen. Im Unterschied zu einem kompletten Neustart der Berechnungen müssen in diesem Fall die bereits getätigten Opti- mierungen in den weiteren Verlauf des Programms einfließen.</p><p>• Außerdem kann es vorkommen, dass während der Zusammenstellung der einzel- nen Aufträge unvorhersehbare Vorkommnisse auftreten, auf die entsprechend reagiert werden muss. Artikel können beispielsweise fehlerhaft, kaputt oder gar nicht vorhanden sein. In einem solchen Fall muss der entsprechende Artikel von einer anderen Position im Lager entnommen werden oder möglicherweise sogar neu eingelagert werden. Wenn ein Lagerarbeiter mehr Zeit benötigt als angenommen, verzögert sich natürlich auch die Kommissionierung und entspre- chendë Anderungen müssen berücksichtigt werden Neben der offensichtlichen Verwandtschaft mit Varianten des VRP, besteht auch eine Verbindung zu Generalisierten Netzwerkproblemen <ref type="bibr" target="#b10">[9]</ref>. So kann die Möglichkeit einen Artikel von unterschiedlichen Lagerplätzen zu holen als implizite Clusterbildung ver- standen werden. Jeweils nur ein Knoten aus einem solchen Cluster soll besucht wer- den. Unter diesem Blickwinkel ist eine Verbindung zum Generalized Traveling Sales- man Problem (GTSP) <ref type="bibr" target="#b11">[10]</ref> offensichtlich, bei dem es gilt, jeweils einen Knoten pro Cluster auszuwählen und anschließend eine Tour zu berechnen, sodass jeder Cluster genau einmal besucht wird.</p><p>Wie später genauer erklärt wird, basiert der hier vorgeschlagene Lösungsansatz auf Variabler Nachbarschaftssuche (engl.: Variable Neighborhood Search) (VNS) <ref type="bibr" target="#b13">[12]</ref> mit integriertem Variable Neighborhood Descent (VND). Bei VNS/VND handelt es sich um Metaheuristiken, die auf der Idee aufbauen, dass ein globales Optimum stets ein lokales Optimum bezüglich aller möglichen Nachbarschaftsfunktionen ist. Unter einer Nachbarschaftsfunktion versteht man eine Rechenvorschrift, die es ermöglicht aus einer gegebenen Lösung x eine neue Lösung x zu berechnen, wobei sich x und x nur in einigen (wenigen) Merkmalen unterscheiden. VND durchsucht systematisch eine Menge von gegebenen Nachbarschaften, um so zu einer möglichst guten Lösung zu gelangen. Weiters wird durch VNS ein so genannter Shaking-Mechanismus ange- wendet, der dazu dient, festgefahrene Suchläufe durch das Einbringen von zufälligen zufälligen¨ zufälligen¨Anderungen zu verbessern.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Capacitated Vehicle Routing Problem</head><p>Eine Variante des VRP ist das Capacitated Vehicle Routing Problem (CVRP) <ref type="bibr" target="#b18">[17]</ref>, welches die Kapazitäten der verwendeten Fahrzeuge einschränkt. Das in <ref type="bibr" target="#b18">[17]</ref> beschrie- bene CVRP verlangt die Auslieferung eines einzigen Gutes an n Kunden ausgehend von einem Depot {0} unter Verwendung von k unabhängigen Transportmitteln mit jeweils identischer Kapazität C, wobei jedem Kunden i ∈ N = {1, . . . , n} die Menge d i zugestellt wird. Aus kombinatorischer Sicht handelt es sich bei der Lösung um eine Aufteilung {R 1 , . . . , R k } von N in k Routen, wobei jede dieser Routen</p><formula xml:id="formula_1">j∈R i d j ≤ C, 1 ≤ i ≤ k erfüllen muss.</formula><p>Zum klassischen, bereits N P-schweren VRP kommen also noch zusätzliche Ein- schränkungen hinzu, welche zu berücksichtigen sind. Das Problem wird dadurch al- lerdings nicht leichter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Vehicle Routing Problem</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Split Delivery Vehicle Routing Problem</head><p>Das Split Delivery Vehicle Routing Problem (SDVRP) <ref type="bibr" target="#b3">[2]</ref> beschreibt jene Form des VRP, bei der ein Kunde mehrmals angefahren werden darf oder sogar muss. Wieder sind mehrere Lieferanten im Einsatz und jedes Transportmittel hat die gleiche Ka- pazität. Nun kann es allerdings vorkommen, dass die benötigte Menge eines Kunden die Kapazität eines einzelnen TransportmittelsübersteigtTransportmittels¨Transportmittelsübersteigt oder aber auch einfach aus Effizienzgründen zwei Lieferanten einen Kunden mit Teillieferungen beliefern.</p><p>Wie bereits bei Dror und Trudeau in <ref type="bibr" target="#b8">[7]</ref> und <ref type="bibr" target="#b9">[8]</ref> gezeigt, können durch die Aufteilung von Lieferungen beträchtliche Einsparungen erzielt werden, sowie auch die Anzahl an Lieferanten reduziert werden. Dennoch bleibt das Problem an sich N P-schwer.</p><p>Die meisten Lösungsansätze gehen von der Annahme aus, dass die so genannte Drei- ecksungleichung erfüllt ist. Geht man von der Kostenberechnung auf Basis von Weg- strecken aus, so bedeutet dies, dass der direkte Weg zwischen zwei Knoten immer der kostengünstigste ist. Formal lässt sich das ganz leicht durch</p><formula xml:id="formula_2">c ij + c jk ≥ c ik , mit i, j, k ∈ {1, . . . , n}</formula><p>ausdrücken, wobei n die Anzahl an Kunden repräsentiert und c ij die Kosten für den Weg von Kunde i zu Kunde j angibt. Es wird dabei angenommen, dass c ij = c ji gilt.</p><p>Ein interessanter Aspekt der zuvor erwähnten Arbeiten <ref type="bibr" target="#b8">[7]</ref> und <ref type="bibr" target="#b9">[8]</ref> ist die Erkenntnis, dass es bei geltender Dreiecksungleichung eine optimale Lösung gibt, bei der je zwei Routen nie mehr als zwei gemeinsame Zielorte mit Teillieferungen anfahren.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Vehicle Routing Problem with Time Windows</head><p>Eine weitere Variante des VRP behandelt jene Problemstellung, bei der die Kunden innerhalb eines definierten Zeitfensters beliefert werden müssen. Bei diesem Problem, dem Vehicle Routing Problem with Time Windows (VRPTW) <ref type="bibr" target="#b20">[19]</ref>, kann sich die Reihenfolge der zu beliefernden Kunden daher nicht ausschließlich aus den Routen mit kürzesten Wegen definieren, sondern wird zusätzlich von einer zeitlichen Be- schränkung beeinflusst. Auch dieses kombinatorische Problem ist N P-schwer und ist als Erweiterung des klassischen VRP eine sehr häufig vorkommende Problemstellung im Bereich der Logistik, wo es neben der Belieferung aller Kunden mit minima- len Kosten nun auch zu berücksichtigen gilt, dass jeder Kunde nur innerhalb eines Zeitfensters [a i , b i ] beliefert werden kann, wobei a i der früheste und b i der späteste Zeitpunkt ist, zu dem Kunde i beliefert werden kann.</p><p>Da das Ziel die Minimierung des notwendigen Zeitaufwandes ist, muss die Dreiecksun- gleichung in konkreten Szenarien meist nicht erfüllt werden, da kürzere Strecken nicht immer gleichbedeutend mit kürzerem Zeitaufwand sind. Das heißt, dass t ij +t jk ≥ t ik , wobei t ij den Zeitaufwand für die Strecke von Kunde i zu Kunde j bezeichnet, in diesem Fall nicht zwingend gilt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generalisierte Netzwerkprobleme</head><p>Zur Klasse der Netzwerkprobleme zählt man unter anderen das Minimum Spanning Tree Problem, das Traveling Salesman Problem sowie das Problem kürzester Wege. Allgemein besteht die Aufgabe bei einem Netzwerkproblem darin, einen optimalen Teilgraphen F eines Graphen G unter Einhaltung gewisser Randbedingungen zu fin- den. Wenn man nun von Generalisierten Netzwerkproblemen spricht, so werden dabei die Knoten des Graphen G in Gruppen (engl.: Cluster) eingeteilt und die Randbe- dingungen auf dieser Basis formuliert. Hier kann dann beispielsweise ein minimaler SpannbaumüberSpannbaum¨Spannbaumüber alle Cluster oder ein Hamiltonkreis (siehe dazu auch Kapitel 3.3) für alle Cluster gesucht werden.</p><p>Formal ist bei einem Generalisierten Netzwerkproblem ein (un)gerichteter Graph G = (V, E), bestehend aus einer Menge von Knoten V = {1, . . . , n} und der Kantenmenge E ⊆ {(i, j) : i, j ∈ V }, gegeben. E(S) = {(i, j) ∈ E : i, j ∈ S} sei dann jene Teilmenge von Kanten, die ihre Endpunkte in S ⊆ V haben. Je nachdem welche Randbedingungen definiert werden, entsteht ein entsprechendes konkretes Problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Traveling Salesman Problem</head><p>Beim sogenannten Traveling Salesman Problem (TSP) <ref type="bibr" target="#b2">[1]</ref> handelt es sich um ein wei- teres kombinatorisches Optimierungsproblem, das in der Klasse der N P-vollständi- gen Probleme enthalten ist. Das Ziel hierbei ist es, alle vorhandenen Orte innerhalb einer Rundreise, bei der also der Startort gleich dem Zielort ist, zu besuchen und dabei eine möglichst kurze Strecke zu finden.</p><p>Um dieses Problem in ein mathematisches Modell zu bringen, bietet sich dië Uber- setzung in ein graphentheoretisches Problem an, wobei die Orte den Knoten und die Verbindungen der Orte den Kanten des Graphen entsprechen. Jede Kante besitzt ei- ne bestimmte Länge, womit die mit ihrer Verwendung verbundenen Kosten definiert sind. Gesucht ist nun eine Tour, welche ein Kreis im Graphen ist, der jeden Knoten genau einmal enthält. Eine solche Tour wird auch Hamiltonkreis genannt.</p><p>Der Einfachheit halber wird für dieses Problem meist angenommen, dass der zugrun- de liegende Graph vollständig ist, also je zwei Knoten durch eine Kante verbunden sind. Sollte der Graph nicht vollständig sein, kann man sich dadurch helfen, die feh- lenden Kanten einzufügen und mit so hohen Kosten zu belasten, dass sie in einer minimalen Tour nicht vorkommen würden, es sei denn es wäre sonst keine Tour auffindbar. Allerdings ist dann zu beachten, dass möglicherweise unlösbare Instan- zen durch diese Anpassung lösbar werden. Die Komplexität des Suchraumes unter</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Bekannte Lösungsansätze</head><p>Berücksichtigung der Anzahl n an Knoten im Graphen ist dabei in O(n n ).</p><p>Das geben sei ein Graph G = (V, E), bestehend aus einer Menge V = {v 1 , v 2 , . . . , v n } von Knoten und einer Menge E von Kanten. Weiters bezeichne e ij eine Kante von v i nach v j und c ij deren Kosten. Der Algorithmus von Dijkstra berechnet in diesem Graph den jeweils kürzesten Weg von einem Knoten v start ∈ V zu allen anderen Knoten v ∈ V .</p><p>Anfangs wird für jeden Knoten im Graph dessen initial bekannte Distanz zum An- fangsknoten mit</p><formula xml:id="formula_3">w(V start ) = 0 und w(V i ) = ∞ V i ∈ V, i = start</formula><p>festgehalten. Ausgehend vom ersten Knoten V start des Weges und beginnend mit die- sem wird nun jeweils immer ein Knoten V f " fixiert" und alle direkten Nachfolger zur Fixierung vorgemerkt, also " markiert". Dabei wird für jeden Knoten</p><formula xml:id="formula_4">V i die Distanz w(V i ) aktualisiert mit w(V i ) = min{w(V i ), w(V f ) + c if }</formula><p>und damit bestimmt, ob ein kürzerer Weg bis zum Knoten V i existiert. Wenn alle Nachfolger von V f in dieser Form bearbeitet wurden, wird der näheste davon fixiert und dessen Nachfolger untersucht. Ein Knoten, der bereits fixiert wurde, wird nicht mehr aktualisiert. Durch dieses Vorgehen nähert man sich Schritt für Schritt dem Zielknoten. Sobald dieser fixiert wird, hat man das Ende erreicht und einen optimalen Weg gefunden. Die Rekonstruktion des Weges ist durch RückverfolgungRückverfolgung¨Rückverfolgungüber die Gleichung</p><formula xml:id="formula_5">w(V i ) + c ij = w(V j )</formula><p>einfach möglich, womit sich natürlich auch mehrere mögliche kürzeste Wege ergeben können.</p><p>Anhand dieses ursprünglich von Dijkstra vorgestellten Algorithmus ist es daher möglich, durch schrittweises Lösen voneinander abhängiger Teilprobleme in einem Graphen den kürzesten Weg zwischen zwei Knoten zu bestimmen, sofern dieser exis- tiert.</p><p>Die Dynamische Programmierung folgt also einer einfachen Strategie: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Variable Nachbarschaftssuche</head><p>Variable Nachbarschaftssuche (VNS) ist eine vergleichsweise junge Metaheuristik, die ihren Ursprung um das Jahr 1995 hat, in dem sie erstmalig vorgestellt wurde (siehe <ref type="bibr" target="#b17">[16]</ref> und <ref type="bibr" target="#b12">[11]</ref>).</p><p>Grundsätzlich kann ein Optimierungsproblem allgemein formuliert werden als</p><formula xml:id="formula_6">min {f (x)|x ∈ X, X ⊆ Z}. (5.1)</formula><p>Z, X, x und f bezeichnen dabei den Lösungsraum, die Menge der gültigen Lösungen, eine konkrete Lösung und eine Funktion, die jeder Lösung x ∈ X einen reellen Zielfunktionswert zuordnet. Meist ist eine explizite Durchsuchung von X auf Basis von (vollständigen) Enumerationsverfahren nicht applikabel. Zudem sind viele der in der Praxis relevanten Probleme N P-schwer, was impliziert, dass die Existenz eines polynomiellen Algorithmus zur Lösung dieser Probleme höchst unwahrscheinlich ist.</p><p>Daher kommen häufig (Meta-)Heuristiken zum Einsatz.</p><p>VNS bietet dabei ein sehr einfach gehaltenes Verfahren mit vielen Ausbaumöglich- keiten und folgt dem einfachen Prinzip, bereits vorhandene Lösungen einer leichten Veränderung zu unterziehen, um somit neue, möglicherweise bessere, Lösungen zu erhalten. Um dabei systematisch vorgehen zu können, werden so genannte Nachbar- schaften definiert, welche im Wesentlichen auf Rechenvorschriften basieren, wie eine vorhandene Lösung abzuändern ist, um neue, möglicherweise bessere, zu erreichen.</p><p>Sei N = {N 1 , . . . , N kmax }, k max ≥ 1, als endliche Menge vorgegebener Nachbar- schaftsstrukturen, sowie N k (x) als Menge der Lösungen der k-ten Nachbarschaft von x definiert. Als globales Optimum wird jene Lösung x opt bezeichnet, für die</p><formula xml:id="formula_7">x opt = min {f (x)|x ∈ X, X ⊆ Z} gilt. Ein lokales Minimum x ∈ X in Bezug auf N k ist gegeben, wenn es keine Lösung x ∈ N k (x ) ⊆ X mit f (x) &lt; f (x ) gibt.</formula><p>Die Variable Nachbarschaftssuche beruht auf folgenden drei einfachen Tatsachen <ref type="bibr" target="#b13">[12]</ref>:</p><p>(i) Ein lokales Minimum bezüglich einer Nachbarschaftsstruktur ist nicht notwen- digerweise auch ein lokales Minimum bezüglich einer anderen.</p><p>(ii) Ein globales Minimum muss gleichzeitig ein lokales Minimum bezüglich aller Nachbarschaftsstrukturen sein.</p><formula xml:id="formula_8">f (x)</formula><p>lokale Optima globales Optimum</p><formula xml:id="formula_9">x x i x j xstart</formula><p>Abbildung 5.1: Lokale Optima und globales Optimum im Verlauf der Zielfunktion (iii) Sehr viele Probleme bieten die Eigenschaft, dass lokale Optima nahe beieinan- der liegen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Der letzte Punkt basiert auf vorhandenen Erfahrungswerten und lässt in vielen Fällen</head><p>Rückschlüsse von einem lokalen auf das globale Optimum zu.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Lokale Suche und Shaking</head><p>Lokale Suche mittels Variable Neighborhood Descent Unter lokaler Suche ver- steht man ein Verfahren, bei dem der Lösungsraum in einem begrenzten Bereich in der Umgebung einer gültigen Lösung durchsucht wird. Der zu durchsuchende Bereich wird durch die Nachbarschaft dieser Lösung vorgegeben. Das bedeutet, dass durch festgelegte Rechenvorschriften Adaptionen der Ausgangslösung vorgenommen wer- den und auf diesem Weg neue Lösungen erreicht werden. Um entscheiden zu können, ob eine Lösung besser oder schlechter ist, wird eine Bewertungsfunktion verwendet.</p><p>In Abb. 5.1 ist der Verlauf einer möglichen Zielfunktion dargestellt, sowie die Posi- tion x start einer Startlösung markiert, von welcher ausgehend innerhalb einer Nach-</p><formula xml:id="formula_10">barschaft N i beispielsweise alle Lösungen im Intervall [x i ; x start ] oder innerhalb ei- ner Nachbarschaft N j alle Lösungen im Intervall [x start ;</formula><p>x j ] erreichbar sind und die markierten lokalen Optima hierbei jeweils die besten Lösungen der Nachbarschaften darstellen.</p><p>Bei der konkreten Umsetzung der lokalen Suche durch den Variable Neighborhood Descent (VND) wird der LösungsraumLösungsraum¨Lösungsraumüber alle Nachbarschaftsstrukturen determi- nistisch durchsucht. Ausgangspunkt sind eine vorhandene Startlösung sowie die vor-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Lokale Suche und Shaking</head><p>definierte Reihenfolge der verfügbaren Nachbarschaftsstrukturen. Beginnend bei der ersten Nachbarschaft der Startlösung wird nun nach einer besseren Lösung gesucht, um auf Basis dieser die Suche fortzusetzen. Die Reihenfolge in der die Nachbarschaf- ten einer Lösung durchsucht werden hängt davon ab, ob Verbesserungen gefunden werden können oder nicht. Wird Nachbarschaft N i durchsucht und konnte eine Ver- besserung erzielt werden, so wird die Suche mit Nachbarschaft N 1 fortgesetzt. Kann in N i keine Verbesserung erzielt werden, so kommt Nachbarschaft N i+1 zum Einsatz. Der Algorithmus terminiert also erst, wenn keine weiteren Verbesserungen erzielt werden können. Auf diesem Weg werden alle Nachbarschaften durchsucht, wobei am Beginn der Kettë ublicherweise jene Strukturen stehen, deren Definition ein schnel- leres Durchsuchen erlaubt als bei später gereihten. In diesem Zusammenhang seien zwei Strategien erwähnt, anhand derer entschieden werden kann, wann das Durch- suchen einer Nachbarschaft beendet werden soll. Wird Best Improvement (für die beste Lösung einer Nachbarschaft) gewählt, dann werden die Nachbarschaften, wie eben beschrieben, komplett durchsucht. Unter Verwendung von Next Improvement (für die nächst bessere Lösung einer Nachbarschaft) wird die Suche innerhalb einer Nachbarschaft abgebrochen, sobald eine bessere Lösung gefunden werden konnte. Der erste Eindruck mag vermitteln, dass es für die LösungsverbesserungLösungsverbesserung¨Lösungsverbesserungüber alle Nachbarschaften besser wäre diese stets komplett zu durchsuchen. Tatsächlich ist es aber schwierig zu beurteilen welche Lösung für nachfolgende Nachbarschaften größe- res Optimierungspotential bietet. Sicher jedoch kann behauptet werden, dass Next Improvement kürzere Laufzeit hat als Best Improvement, sofern mindestens einmal abgebrochen werden kann, bevor eine Nachbarschaft komplett durchsucht wurde.</p><p>In Alg. 1 ist der Ablauf von VND dargestellt. Natürlich ist zu beachten, dass sich abhängig von der Anzahl der definierten Nachbarschaftsstrukturen auch die Laufzeit verändert. Eine größere Anzahl an Nachbarschaftsstrukturen erhöht den notwendigen Zeitaufwand, steigert aber gleichzeitig auch die Chance eine bessere Lösung zu finden.</p><p>Shaking Zusätzlich zur lokalen Suche kann der Einsatz von zufälligen Komponenten positiven Einfluss auf die Effizienz eines Algorithmus haben. Dies kann durch einen so genannten Shaking-Mechanismus erreicht werden, also einem zufälligen " Durch- schütteln", wodurch zufällige Veränderungen einer Lösung eine neue Lösung erzeu- gen. Angenommen alle vorhandenen Nachbarschaftsstrukturen alleine ermöglichen lediglich von der in Abb. 5.1 markierten Startlösung x start aus innerhalb des In- tervalls [x i ; x j ] neue Lösungen zu finden, so würde dies bedeuten, dass die besten auffindbaren Lösungen die beiden gekennzeichneten lokalen Optima wären. Durch das Shaking kann man allerdings erreichen, dass dieses Intervall verschoben wird und somit in einem neuen Bereich der Zielfunktion nach Optima gesucht werden kann, womit die Wahrscheinlichkeit steigt, das globale Optimum zu finden.</p><p>Bei der lokalen Suche handelt es sich also um einen Prozess, der innerhalb eines definierten Teilbereichs des gesamten Lösungsraumes nach besseren Lösungen sucht. Die Definition von zu durchsuchenden Teilbereichen (Nachbarschaften) ist allerdings</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 1 : VND</head><p>Input : eine Startlösung x start für das Optimierungsproblem Output : die beste gefundene (lokale) Lösung x Data : sei N eine endliche Menge vorgegebener Nachbarschaftsstrukturen</p><formula xml:id="formula_11">begin k ← 1 ; x ← x start ; repeat Suche nach bestem Nachbarn x der Lösung x innerhalb der k-ten Nachbarschaft (x ∈ N k (x)) ; if f (x ) &lt; f (x) then x ← x ; k ← 1 ; else k ← k + 1 ; until k = k max ; return x ; end</formula><p>abhängig von der aktuellen Lösung. Somit stellt sich natürlich stets die Frage, ob mit den zur Verfügung gestellten Nachbarschaften der gesamte Lösungsraum erreicht werden kann, beziehungsweise vor allem die optimale Lösung. Um nun auch mögli- cherweise nicht abgedeckte Bereiche des Lösungsraumes erreichen zu können, wird Shaking eingesetzt. Erzeugt werden diese Veränderungen durch zufälliges Generieren von Lösungen aus einer der Nachbarschaften der aktuellen Lösung.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Genereller Ansatz für die Variable Nachbarschaftssuche</head><p>Aus der Kombination von lokaler Suche und Shaking lässt sich nun der generelle Ansatz für VNS aufbauen. Dabei wird die lokale Suche eingebettet in einen wieder- kehrenden Ablauf von Shaking und der Entscheidung darüber, ob mit einer neuen und besseren Lösung fortgesetzt wird, oder keine Verbesserung innerhalb der lokalen Suche möglich war. Diese Vorgehensweise wird in Alg. 2 gezeigt. Es handelt sich hier um die Grundstruktur einer VNS, wobei die allgemein als lokale Suche bezeichnete Phase durch VND abgedeckt wird. Darüber hinaus bildet dieser Ablauf zugleich das Grundgerüst der in dieser Arbeit angewandten Nachbarschaftssuche.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>20</head><p>Algorithmus 2 : Genereller VNS-Ansatz Input : eine Startlösung x start für das Optimierungsproblem Output : die beste gefundene Lösung x Data : sei N eine endliche Menge vorgegebener Nachbarschaftsstrukturen Aus diesem Grund schien es sinnvoll zu sein, metaheuristische Verfahren in Kom- bination mit exakten Methoden zur Lösung von Teilaufgaben beziehungsweise zur Bewertung von konkreten Lösungen zu verwenden. Durch den Einsatz von VNS als Metaheuristik ist es möglich in kurzer Zeit sehr viele unterschiedliche Lösungen zu er- zeugen. Dabei werden zunächst gewisse Parameter ermittelt, die eine konkrete Lösung definieren. Allerdings muss diese auch bewertet werden, um deren Güte bestimmen zu können. Dies geschieht mittels Dynamischer Programmierung in einem weiteren Schritt des Algorithmus, in welchem auf Basis der durch die VNS vorgegebenen Pa- rameter einer Lösung eine passende konkrete Tour durch das Lager berechnet wird.</p><formula xml:id="formula_12">begin k ← 1 ; x ← x start ; repeat // Shaking: Erzeuge eine zufällige Lösung x aus x innerhalb der k-ten Nachbarschaft (x ∈ N k (x)) x ← shake(x, k) ; // Führe lokale Suche mittels VND durch x ← V N D(x ) ; if f (x ) &lt; f (x) then x ← x ; k ← 1 ; else k ← k + 1 ; until k = k max ; return x ; end</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Der grundsätzliche Ablauf</head><p>Der in dieser Arbeit entwickelte Algorithmus kann im Wesentlichen in vier Teilberei- che gegliedert werden, welche so lange wiederholt werden bis keine zu bearbeitenden Bestellungen mehr vorhanden sind: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Partitionierung vorhandener Bestellungen</head><p>Wie bereits erwähnt wurde, handelt es sich bei diesem Teil des Ablaufs um eine erste Auswahl aus den vorhandenen Bestellungen. Es gibt also sozusagen einen Contai- ner, der mit Bestellungen von Seiten der Kunden befüllt wird. Aus diesem werden dann jeweils die nächsten zu bearbeitenden ausgesucht und an die folgenden Phasenübergeben Phasen¨Phasenübergeben. Um die Anforderungen an die möglichst kurz zu haltenden Lieferzeiten einhalten zu können, werden die verfügbaren Bestellungen nach deren Lieferdatum geordnet. Zusätzlich wird berücksichtigt, dass Artikel einer Bestellung im selben Be- reich der Verdichtungszone abgelegt werden müssen und die damit verbundenen Ka- pazitätsbeschränkungen einzuhalten sind. Die Auswahl wird daher so getroffen, dass eine Partitionierung in ihrer Gesamtheit einen einzigen Bereich der Verdichtungszo- ne erreicht. Es ist natürlich ersichtlich, dass es sich bei dieser Vorgehensweise nur um einen möglichen Ansatz handelt, mit diesen Randbedingungen beziehungsweise mit im Verlauf des Arbeitstages eintreffenden Bestellungen umzugehen. Es wird hier- bei kein Anspruch auf Optimalität des Verfahrens gestellt, alle Nebenbedingungen werden dabei allerdings erfüllt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Zuordnung von Artikeln zu Touren</head><p>Obwohl dieser Schritt des Algorithmus hauptsächlich die Entscheidung trifft welche der bestellten Artikel innerhalb einer Tour eingesammelt werden sollen, erfolgt die Bewertung dessen auf Basis der Länge von konkreten Touren und das macht be- reits hier die Berücksichtigung mehrerer Einschränkungen notwendig. So auch bei Artikeln mit mehreren Lagerplätzen. Hier muss entschieden werden welche Menge von welchem Platz abgeholt werden soll, wobei natürlich auch die Kapazität der Kommissionierungswagen nichtüberschrittennicht¨nichtüberschritten werden darf.</p><p>Eine Lösung x für die Zuordnung von Artikeln zu Touren muss also mehrere Infor- mationen beinhalten, welchë uber die Menge S der Zuordnungen von Artikeln zu Touren bestimmt sind. Das ist zunächst die Information, welche Mengen</p><formula xml:id="formula_13">k 1 , . . . , k j ⊆ N j</formula><p>für jeden Artikel a j ∈ A einzusammeln sind, wobei A die Menge der Artikel bezeich- net (|A| = j) und j maximal gleich der Anzahl an unterschiedlichen Lagerplätzen für den Artikel a j sein kann. Weiters wird definiert von welchen Lagerplätzen </p><formula xml:id="formula_14">l 1 , . . . , l j ⊆ L j diese entnommen</formula><formula xml:id="formula_15">m S = {S i } (7.1) i=1 S i = {1, . . . , s i }, mit i ≥ 1 (7.2) s j = a j , l 1 , . . . , l j , k 1 , . . . , k j , mit j ≥ 1 (7.3)</formula><p>Zusätzlich sei T i definiert als ein konkreter Weg durch das Lager, auf welchem die durch S i implizierten Lagerplätze besucht werden. Die Menge</p><formula xml:id="formula_16">m T = {T i } (7.4) i=1</formula><p>bildet dann die Menge aller Touren T i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Konstruktionsheuristiken</head><p>Aufgrund der Tatsache, dass der Algorithmus ausgehend von einer Startlösung vie- le unterschiedliche Lösungen erzeugen und untersuchen soll, ist es notwendig einen schnellen Startpunkt zu generieren, was mittels Initialisierung per Konstruktionsheu- ristiken geschieht. Ausgehend davon kann dann in der Folge die vorhandene Lösung weiter verbessert werden. Da die Anzahl der gegebenen und zu erfüllenden Nebenbe- dingungen groß ist, bot sich die Entwicklung zweier unterschiedlicher Konstruktions- heuristiken an, von denen beide jeweils unterschiedliche Mengen von Einschränkun- gen abdecken.</p><p>Die erste dieser Heuristiken, die so genannte Collision Avoiding Heuristic (CAH), baut auf der Idee auf eine Menge von Touren erzeugen zu können, die nichtübernicht¨nichtüber- 28</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Zuordnung von Artikeln zu Touren</head><p>Algorithmus 4 : CollisionAvoidingHeuristic Input : eine Liste bestellter Artikel; Anzahl der Zonen m Output : eine Menge von Mengen bestehend aus einzusammelnden Artikeln innerhalb von m Touren Data : Menge S von Mengen S i , mit i = 1 . . . m, von einzusammelnden Artikeln begin foreach S i ∈ S do S i ← ∅ ; füge alle in Zone Z i bestellten Artikel zu S i hinzu ; return S ; end lappen. Es sollen dabei also keine Kreuzungen auftreten, sodass Arbeiter auf ihrem Weg durch das Lager nicht kollidieren. Um das zu erreichen, wird das Lager in m (physisch) nichtüberlappendenicht¨nichtüberlappende Zonen Z i , mit i = 1, . . . , m, eingeteilt. Nun wird für jede solche Zone Z i eine Tour T i errechnet, um alle Artikel einzusammeln, welche in Zone Z i gelagert sind. Der Parameter m kann nach Belieben gewählt werden, es bietet sich aber durchaus an ihn mit der Anzahl der verfügbaren Lagerarbeiter zu initialisieren. Der Ablauf dieser Heuristik wird in Alg. 4 skizziert.</p><p>Die zweite Konstruktionsheuristik, Time Saving Heuristic (TSH) genannt, versucht anhand der streng einzuhaltenden Liefertermine entsprechende Zuordnungen zu fin- den. Erreicht wird dies hierbei, indem zunächst eine Reihung der Bestellungen nach deren spätest möglichen Lieferzeitpunkten erstellt wird, um anschließend mittels First-Fit Verfahrens Touren T i , mit i = 1, . . . , m, zu berechnen, sodass die ersten benötigten und auszuliefernden Artikel in Tour T 1 eingesammelt werden. Erst wenn die Kapazität des ersten Kommissionierungswagens nicht mehr ausreichen sollte, wird eine zweite Tour T 2 für weitere Artikel erzeugt. Analog dazu entstehen eventu- ell benötigte weitere Touren T 3 , . . . , T m . Der Pseudo-Code für diesen Ablauf wird in Alg. 5 gezeigt.</p><p>Es ist offensichtlich, dass diese beiden Heuristiken alleine noch nicht ausreichen, um zulässige Lösungen des Problems zu produzieren. Bei CAH kann nicht zugesichert werden, dass etwa Lieferzeiten eingehalten werden und darüber hinaus werden die Ka- pazitäten der Kommissionierungswagen nicht beachtet. Andererseits kann bei TSH nicht garantiert werden, dass die Touren nichtüberlappennicht¨nichtüberlappen. Daher kann nur dann mit diesen Methoden gearbeitet werden, wenn zusätzlich Reparaturalgorithmen zum Einsatz kommen. Trotzdem soll angenommen werden, dass die vorerst gefundenen Lösungen als ad hoc-Antwort durchaus akzeptabel sind, etwa wenn das System im Betrieb morgens gestartet wird. Der Hintergedanke dabei ist, dass für jeden einzelnen Mitarbeiter zunächst nur die InformationüberInformation¨Informationüber den nächsten zu holenden Artikel von Bedeutung ist. Alle weiteren Artikel können bestimmt werden während der Mitar-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>29</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 5 : TimeSavingHeuristic</head><p>Input : eine Liste L bestellter Artikel a i Output : eine Menge von Mengen bestehend aus einzusammelnden Artikeln innerhalb von m Touren Data : Menge S von Mengen S i , mit i = 1 . . . m, von einzusammelnden Artikeln; m wird durch diesen Algorithmus bestimmt begin sortiere die Elemente in L nach dem spätesten Lieferdatum; S ← ∅ ; i ← 1 ;</p><formula xml:id="formula_17">S i ← ∅ ; foreach a ∈ L do if a passt nicht in S i then S ← S ∪ {S i } ; i ← i + 1 ; S i ← ∅ ; füge a zu S i hinzu ; S ← S ∪ {S i } ; return S ; end</formula><p>beiter mit den ersten Artikeln beschäftigt ist. Damit hat das System Zeit, um weitere Rechenschritte durchzuführen und verbesserte Lösungen für dië ubrigen Routen zu finden. Artikel, die bereits eingesammelt wurden, müssen fix in den jeweiligen Touren eingeplant bleiben und nur nachfolgende Artikel sind in der Reihenfolge der Abholung noch variabel.</p><p>Auch wenn die Lösung x, gefunden von CAH oder TSH, gültig ist, heißt das noch nicht, dass deren Güte f (x), im Speziellen also die Länge aller dadurch errechneten Touren insgesamt, die bestmögliche ist. Generell kann man aber davon ausgehen, dass dermaßen erzeugte Lösungen relativ schlechte Bewertungen haben werden. Der Grund dafür sind die Bestrafungen, die durch ein¨Uberfüllenein¨ ein¨Uberfüllen von Kommissionierungs- wagen entstehen. Sobald die Kapazitätsgrenze eines solchen erreicht wird, bestraft der Algorithmus dies so stark, dass es auf alle Fälle eine günstigere Lösung ist einen zusätzlichen Wagen zu verwenden. Es wird also unerlässlich sein mit Verbesserungs- heuristiken weiterzuarbeiten.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Reparatur-und Verbesserungsheuristik</head><p>Zentraler Bestandteil des Programms ist die Umsetzung einer Variablen Nachbar- schaftssuche (VNS) <ref type="bibr" target="#b13">[12]</ref> mit Verwendung des Variable Neighborhood Descent (VND) als lokale Verbesserungskomponente, welche sowohl als Reparatur-als auch als Ver-besserungsheuristik eingesetzt werden kann. Zur Reparatur ist das Verfahren ein- setzbar, weil durch hohe Bestrafung von ungültigen Lösungen stets eine bessere, also kostengünstigere und gleichzeitig vor allem gültige Lösung gefunden werden kann. Wesentlich hierbei ist die Veränderung der Artikelauswahlen, die in weiterer Folge erst die Tourberechnung beeinflusst. Die nachfolgende Auflistung bezieht sich also stets auf eine Adaptierung von Artikelauswahlen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Folgend den bereits in Kapitel 5 dargelegten</head><note type="other">Erläuterungen, kommen die anschließend vorgestellten Nachbarschaftsstrukturen zum Einsatz. Da diese Strukturen auf Basis von grundlegenden Moves definiert werden, folgt zuvor eine Auflistung eben dieser:</note><formula xml:id="formula_18">SwapMove(i, j, k, l) Dieser Schritt tauscht die Artikel k ∈ S i und l ∈ S j , mit S i , S j ∈ S, 1 ≤ i &lt; j ≤ m und k = l.</formula><p>Das bedeutet, dass nach Anwendung dieses Schrittes Artikel k von Tour S i entfernt und Artikel l eingefügt wurde. Analog wurde Artikel l von Tour S j entfernt und Artikel k eingefügt.</p><formula xml:id="formula_19">ShiftMove(i, j, k) Wird dieser Schritt durchgeführt, so bedeutet dies, dass Artikel k ∈ S i aus S i entfernt und in S j eingefügt wird, wobei 1 ≤ i, j ≤ m und i = j.</formula><p>MergeMove(i, j) Bei diesem Schritt werden zwei Touren S i und S j zu einer neuen Tour S i zusammengeführt. Es werden also all jene Artikel, die zuvor von S i und S j eingesammelt wurden, von einer neuen Tour bearbeitet, wodurch S i und S j aus der Menge S entfernt werden können und stattdessen S i in S eingefügt wird. Es vermindert sich dadurch also die Anzahl der Touren um eins.</p><p>SplitMove(i, R) Die Anwendung dieses Schrittes bringt die Tour S i zu einer Auftei- lung in zwei neue Touren S i und S i , indem alle in R enthaltenen Artikel von S i nach S i verschoben werden. S i muss dann natürlich zu S hinzugefügt werden und somit erhöht sich die Gesamtzahl an Touren um eins.</p><p>Formal betrachtet hat man hier 2 s Möglichkeiten die ursprüngliche Tour zu zerlegen, wenn die Anzahl an Elementen in S i mit s bezeichnet wird, also |S i | = s. Die Zerlegungen berechnen sich dann aus der Potenzmenge von S i , nämlich P(S i ), beziehungsweise ergibt das |P(S i )| = 2 s verschiedene Möglichkeiten.</p><p>SwapPositionMove(i, k, l) Dieser Move nützt die Tatsache aus, dass Artikel an mehr als nur einer Position im Lager verfügbar sein können. Sollte an einer weiteren Position im Lager ein bestimmter Artikel in der benötigten Menge vorhanden sein, so kann die Position vertauscht werden. Es wird dann der Ort des Artikels k ∈ S i auf den neuen Ort l geändert. Um den Ablauf hierbei ein- fach zu halten, wird der Artikel aus der Tour S i entfernt und eine neue Tour S i gebildet, die zunächst nur diesen einen Artikel k mit der neuen Lagerplatz- information enthält. Durch die spätere Anwendung eines MergeMove könnte diese Tour mit einer anderen wieder zusammengelegt werden.</p><p>SplitPositionMove(i, k, l, q) Dieser Schritt ermöglicht es in etwas anderer Form als bei den beiden bisherigen Varianten einen Artikel von anderer Stelle einzusam-meln. Es ist generell natürlich nicht nur möglich die komplette Menge eines angeforderten Artikels von einem anderen Lagerplatz zu holen, sondern bei Bedarf auch nur eine Teilmenge davon. Diese Tatsache erlaubt die Definiti- on eines Moves, durch den aus der Tour S i eine bestimmte Teilmenge q für den Artikel k von einer zusätzlichen Position l im Lager innerhalb einer neuen Tour S </p><note type="other">i eingesammelt wird und gleichzeitig eine bleibende Restmenge von der ursprünglichen Position zu holen bleibt. Aus diesen grundlegenden Moves werden nun folgende Nachbarschaftsstrukturen de- finiert, wobei S die Menge an Selektionen (Touren) bezeichnet, s max die maximale (größte vorkommende) Anzahl an Artikeln einer Tour angibt und l max für die maxi- male (größte vorkommende) Anzahl an alternativen Lagerplätzen eines Artikels aus dem Lager steht: Swap Grundlage für diese Nachbarschaftsstruktur ist der zuvor eingeführte Swap- Move.</note><formula xml:id="formula_20">begin l ← 1 ; repeat x ← durchsuche Nachbarschaft N l (x) ; if f (x ) &lt; f (x) then x ← x ; l ← 1 ; else l ← l + 1 ;</formula><p>until l &gt; l max oder eine vordefinierte Zeit wurde erreicht ; end tung einer Lösung x und einer daraus abgeleiteten möglichen Verbesserung x . Da die Güte einer Lösung im Wesentlichen von der Summe der Längen aller Touren abhängt, ist es also hier von Bedeutung sämtliche benötigte Touren einer Lösung so zu berechnen, dass diese auf kürzestem Weg durch das Lager führen. Kapitel 7.3 wird zeigen wie es möglich ist entsprechende Touren unter Berücksichtigung der speziellen Eigenschaften des Lagers in polynomieller Zeit zu berechnen.</p><p>Die Nachbarschaftsstrukturen zur Durchführung von Shaking-Phasen (also zufälligen Veränderungen einer Lösung) basieren auf den zuvor vorgestellten, jedoch werden hierbei anstelle eines Schrittes mehrere zufällig ausgewählte Schritte auf die entspre- chende Lösung angewendet. In der letzten Version des Algorithmus kam dafür Swap zum Einsatz. Die zufälligen Veränderungen aus der Nachbarschaft N k (x) in Alg. 2 kommen daher jeweils nur aus Swap. Gleichermaßen wäre aber auch die Verwendung von Shift, Split oder Merge sowie jede Kombination dieser möglich gewesen, jedoch konnten keine klaren Vorteile für eine der Varianten im Vorfeld ausgemacht werden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Durchsuchen der Nachbarschaften</head><p>Beim Durchsuchen der einzelnen Nachbarschaften unterscheidet man zwei Methoden zur¨Ubernahmezur¨ zur¨Ubernahme einer neuen und besseren Lösung, nämlich Next Improvement und Best Improvement (siehe auch Kapitel 5). Wird Next Improvement verwendet, so ist das gleichbedeutend mit einem Abbruch der Suche, sobald eine bessere Lösung gefun- den wurde. Konkret auf ShiftMove bezogen wird also die Nachbarschaft systematisch durchsucht und beginnend mit dem ersten bis zum letzten Artikel versucht diesen einer anderen Tour zuzuordnen. Bei diesem Vorgehen sind aber jene Artikel klar bevorzugt, welche in der Liste am Anfang stehen. Daher wurde eine zufällige Durch- suchungsreihenfolge implementiert, sodass jede Lösung im Nachbarschaftsraum mit gleicher Wahrscheinlichkeit zu einer Verbesserung beitragen kann.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.4">Dynamische Reihenfolge der Nachbarschaften</head><p>Eine große Herausforderung bei der Umsetzung mittels VNS stellt die Reihung der definierten Nachbarschaftsstrukturen dar. Nachdem die Anwendung einer Nachbar- schaftsstruktur durchaus auch Auswirkungen auf die Effizienz nachfolgender Nach- barschaftsstrukturen hat, ist diese Entscheidungsfindung nicht trivial. Aus diesem Grund wurde entschieden, eine Adaptierung der in <ref type="bibr" target="#b15">[14]</ref>  Das Konzept ist in Alg. 7 ersichtlich, wobei eine kleine Anpassung zum in <ref type="bibr" target="#b15">[14]</ref> vor- gestellten Algorithmus durchgeführt wurde, um zu vermeiden, dass Nachbarschaften ausgelassen werden können. Das kann vorkommen, da dort vor jeder Umreihung ge- speichert wird mit welcher Nachbarschaft fortgesetzt werden soll und diese dann wei- ter hinten gereiht werden könnte als andere noch nicht besuchte. Außerdem soll ver- hindert werden, dass die Nachbarschaften ständig umgereiht werden. Dies geschieht im ursprünglich vorgestellten Verfahren viel häufiger, da auch dann eine Umreihung passieren kann, wenn keine Verbesserung der Lösung erzielt wurde. Der tatsächlich verwendete Algorithmus verändert die Reihenfolge der Nachbarschaften erst dann, wenn gerade eine verbesserte Lösung gefunden werden konnte.</p><p>Getestet wurde der gesamte Algorithmus sowohl mit dynamischer als auch mit stati- scher Nachbarschaftsreihenfolge. Die Ergebnisse dazu werden in Kapitel 8 präsentiert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 7 : VND mit dynamischer Nachbarschaftsreihenfolge</head><p>Input : eine Startlösung x Data : Zähler i, Anzahl k der zu untersuchenden Nachbarschaften</p><formula xml:id="formula_21">begin w 1 ← w 2 ← . . . ← w k ← W ; w min ← w max ← W ; λ = (1, 2, . . . , k) ; i ← 1 ; repeat x ← durchsuche Nachbarschaft N i (x) mit Zeitaufwand t λ i ; if f (x ) &lt; f (x) then x ← x ; w λ i ← w λ i 2 + t λ i α ; if (w λ i &lt; w min ) ∨ (w λ i &gt; w max ) then Sortiere λ 1 , . . . , λ k , sodass w λ 1 ≤ w λ 2 ≤ . . . ≤ w λ k ; w min ← w λ 1 ; w max ← w λ k ; i ← 1 ; else w λ i ← w λ i + t λ i ; i ← i + 1 ; until i &gt; k ; end</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 8 : Berechnung einzelner Touren</head><p>Input : Menge an Zuordnungen S Data : m = |S| Output : Menge von Touren T begin foreach S i ∈ S do T i ← kürzeste Tour für S i ; T ← T ∪ {T i } ; return T ; end</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Berechnung einzelner Touren</head><p>Die nachfolgende Phase des Algorithmus, wie in Alg. 3 vorgestellt, betrifft das Auffin- den von Touren ausgehend von den zuvor festgelegten Artikelzuordnungen. Weiters ist die Berechnung von kürzesten Wegen ein Teilproblem des VNS, wie in Kapi- tel 7.2.2 beschrieben.</p><p>Zur effizienten Berechnung dieser Touren ist es zunächst notwendig das Lager in eine passende Struktur zu dessen Repräsentation zu bringen, was durch einen ungerichte- ten, zusammenhängenden Graphen G = (V, E) passiert. Ausgehend davon kann nun ein Verfahren basierend auf Dynamischer Programmierung nach optimalen Touren suchen. Die dabei entscheidende Idee ist die Definition so genannter Module, wel- che entsprechend ihrer Verbindungsmöglichkeiten aneinander angeschlossen werden können. Der nun im Detail erläuterte Algorithmus berechnet für jede Zuordnung S i eine konkrete Tour T i . Diese Vorgehensweise ist im Pseudo-Code in Alg. 8 ersichtlich.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">Repräsentation als Graph</head><p>Die Repräsentation des Lagers geschieht also mittels eines ungerichteten, zusam- menhängenden Graphen G = (V, E), wobei die Kantenmenge E die Gänge innerhalb des Lagers bildet. Unterschieden werden dabei Regalgänge und Hauptgänge. Während erstere jene Gänge sind, die sich zwischen den Lagerregalen befinden und parallel zu diesen sind, verbinden zweitere Regalgänge und wieder andere Hauptgänge miteinan- der (siehe auch Abb. 1.1 in Kapitel 1). Jeder Knoten v ∈ V entspricht einem Punkt mit speziellen Eigenschaften. Das können die Verdichtungszone (VZ), Kreuzungen von Gängen und Positionen innerhalb von Regalen sein. Es kommt sehr häufig vor, dass mehrere Positionen im Lager (Lagerplätze) ¨ ubereinander liegen, solche Vorkom- men werden dann aber zusammengefasst in einem Knoten, der darüber hinaus den gesamten Regalgang enthält.</p><p>Man kann nun sehen, dass jeder Knoten v ∈ V höchstens vier Nachbarn hat, das Unter Ausnützung dieser Eigenschaften kann man den Graphen G einschränken und die Anzahl an Knoten stark reduzieren, indem für jeden Gang höchstens drei Knoten existieren (siehe Abb. 7.1). Dort repräsentiert der Knoten in der Mitte die (lineare Liste der) Lagerplätze und die beiden Knoten am Beginn und am Ende des Ganges bezeichnen die Kreuzungspunkte mit dem jeweiligen Hauptgang.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.2">Ein Dynamisches Programm</head><p>Ohne Einschränkung der Allgemeinheit und mit Bezug auf Abb. 7.1 soll angenommen werden, dass Regalgänge und Hauptgänge orthogonal zueinander liegen. Hauptgänge verlaufen hierbei von oben nach unten, Regalgänge stets von links nach rechts. Eine Menge von zwei Hauptgänge gemeinsam mit den dazwischen liegenden Regalgängen wird weiters auch als Block bezeichnet.</p><p>Im Folgenden wird ein Algorithmus aufbauend auf Dynamischer Programmierung gezeigt, welcher in polynomieller Zeit die Berechnung kürzester TourenüberTouren¨Tourenüber alle Knoten von Interesse, also all jene Lagerplätze mit einzusammelnden Artikeln, in-</p><formula xml:id="formula_22">(a) (b) (c) (d) (e) Abbildung 7.2: Grundlegende Gangoperationen. (a) (b) (c) (d) (e)</formula><p>Abbildung 7.3: Grundlegende Zwischen-Gangoperationen.</p><p>nerhalb eines Blocks durchführt.</p><p>Zu diesem Zweck werden so genannte Gangoperationen, sowie Zwischen-Gangopera- tionen eingeführt. Gangoperationen werden herangezogen, um die Möglichkeiten für Wege innerhalb eines Regalganges abzudecken, wohingegen Zwischen-Gangoperati- onen Bewegungen innerhalb der Hauptgänge beschreiben.</p><p>Gangoperationen In Abb. 7.2 ist die Menge an grundlegenden Gangoperationen, welche von Arbeitern durchgeführt werden können, grafisch dargestellt. Es ist offen- sichtlich, dass Gänge entsprechend von links oder rechts betreten werden können (sie- he Abb. 7.2a-7.2d), aber auch komplett ausgelassen werden können (siehe Abb. 7.2e). Ein Gang kann natürlich nur dann ausgelassen werden, wenn keine Artikel daraus benötigt werden. In diesem Fall ist eine solche Operation also auch gültig. Im im- plementierten Algorithmus kommt diese Operation nicht direkt zum Einsatz, da hier Gänge weggelassen werden, wenn sie nicht betreten werden müssen. Es werden dann einfach die Gänge davor und danach direkt miteinander verbunden.</p><p>Zwischen-Gangoperationen Zusätzlich zu den eingeführten grundlegenden Gang- operationen werden Zwischen-Gangoperationen benötigt. Diese wiederum beschrei- ben welche Möglichkeiten für die Arbeiter bestehen, um sich zwischen zwei aufein- ander folgenden Gängen zu bewegen (siehe Abb. 7.3). Diese Aktionen lassen einen Wechseï uber die Hauptgänge zu (siehe Abb. 7.3a-7.3d). Natürlich kann es auch vor- kommen, dass kein weiterer Gang besucht werden muss, dann ist kein Gangwechsel mehr nötig, wie in Abb. 7.3e zu sehen ist. Die Umsetzung im Programm erfolgt auch hier durch Weglassen nicht benötigter Gänge, die theoretisch gültigen Gangoperati- onen sind dann nicht nötig. Gangmodule Letztlich ist es hiermit möglich eine Menge an so genannten Gang- modulen zu definieren, welche wiederum auf den vorgestellten grundlegenden Ope- rationen aufbauen. Daraus kann man nun jede erdenkliche Kombination erstellen, jedoch ist nicht jede davon auch gleichzeitig gültig. Abb. 7.4a und 7.4b zeigen zwei gültige Module. Das in Abb. 7.4c gezeigte Modul ist jedoch von vornherein ungültig, da der rechte Knoten, der die Kreuzung von Regalgang und Hauptgang repräsentiert zweimal verlassen aber nur einmal betreten wird. Das Modul in Abb. 7.4d ist im Prinzip gültig, aber vom Programm zu verwerfen, weil die Lagerplätze, von denen Artikel eingesammelt werden sollen (in der Abb. dunkelgrau markiert), gar nicht besucht werden.</p><p>Es sei nun definiert, dass zwei Module j und j für die Gänge i und i unterein- ander kompatibel sind, wenn die Module j und j basierend auf ihren Zwischen- Gangoperationen verbunden werden können. Weiters ist Modul j mit Modul j " von oben" kompatibel, wenn die Zwischen-Gangoperationen von j um " nach unten" be- ziehungsweise " nach oben" zu gehen mit den entsprechenden Zwischen-Gangoperatio- nen von j zusammenpassen. Im Folgenden bezeichnet M komp (j) die Menge aller Module j , die " von oben" kompatibel mit j sind.</p><p>Einige Beobachtungen Generelles Ziel ist immer noch das Einsammeln aller ange- forderten Artikel. Nachdem bereits Selektionen an Artikeln getroffen wurden, welche jeweils innerhalb einer Tour einzusammeln sind, wird mit dem Berechnen jeder dieser Touren ein Teilziel erreicht. Zusätzlich dazu suchen wir aber nach Touren durch das Lager, die insgesamt ein Minimum an Zeit benötigen sollen, weshalb eine entspre- chende Bewertung jeder Tour erfolgen muss. Diese Bewertung kann auf den zuvor eingeführten Modulen zur Tourkonstruktion passieren, indem die Kosten c i (j) &gt; 0 für jedes Modul j basierend auf den Aktionen, die ein Arbeiter in Gang i durchführt, berechnet werden. Transformiert auf den erwähnten Dekodierungsgraph G bedeutet das eine einfache Umlegung auf die Kosten für jede einzelne Kante e ∈ E gemäß den jeweiligen Längen derselben.</p><p>In Bezug auf die Anzahl von Modulen, die zur Zusammenstellung einer Tour relevant sein können, muss zum einen nocheinmal erwähnt werden, dass nicht alle Kombina- tionen an Gangoperationen und Zwischen-Gangoperationen gültige Module bilden. Zum anderen ist es aber darüber hinaus wesentlich zu beachten, dass auch gültige Module teilweise auszuschließen sind beziehungsweise manche gültige Module durch weitaus effizientere Module mit gleichen Möglichkeiten ersetzt werden können. Als Abbildung 7.5: Ein gültiges Modul (a) kann durch ein effizienteres Modul (b) ersetzt werden.</p><formula xml:id="formula_23">T 3 T 3 v w VZ T 1 T 2 v w VZ T 1 T 2 T 5 T 4 T 5 T 4 (a) (b)</formula><p>Abbildung 7.6: Konstuktion einer Tour T aus einer Tour T unter der Annahme, dass T zweimal Knoten w direkt nach v besucht.</p><p>Beispiel für einen solchen Austausch im Sinne der Effizienzsteigerung soll Abb. 7.5 dienen. Dort verlangt Modul 7.5a das Erreichen und sofortige Verlassen des Ganges von links oben, weshalb diese beiden Kanten und damit auch nicht notwendiger Weg eingespart werden könnten.</p><p>Zu beachten ist außerdem, dass eine Tour, wie sie im Rahmen dieser Arbeit ver- standen wird, sich von Touren in Zusammenhang mit dem Travelling Salesman Pro- blem oder dem Vehicle Routing Problem unterscheidet. Die etwas andere Auffassung kommt daher, dass Knoten, wie zum Beispiel Kreuzungspunkte von Gängen oder die Verdichtungszone, mehr als nur einmal besucht werden dürfen. Das ist notwendig, da meistens keine direkte Verbindung zwischen zwei Knoten des Lagergraphs besteht. Somit können Pfade zwischen zwei Knoten mehrfach zurückgelegt werden, allerdings kann man die Anzahl an Verwendungen des selben Wegs von oben beschränken. Beweis. Angenommen der Weg zwischen v und w wird zweimal in der gleichen Rich- tung durchlaufen, dann kann man die Tour T in fünf Teil-Touren T 1 , T 2 , T 3 , T 4 und T 5 aufteilen, wie in Abb. 7.6a zu sehen, wobei VZ für die Verdichtungszone steht. Man kann nun eine neue Tour T erzeugen, welche beginnend bei VZ entlang von T 1 nach v verläuft, dann T 3 von v nach w folgt, um schließlich T 5 folgend von w aus zu VZ zurückzukehren (siehe Abb. 7.6b). Da v und w adjazent sind, also kein anderer Punkt auf dem Weg von v nach w passiert werden muss, besucht T dieselben Punkte wie die Tour T . Weiters werden T 2 und T 4 innerhalb von T ausgelassen, wodurch T kürzer ist als T und das wiederum einen Widerspruch zu der Annahme darstellt,</p><formula xml:id="formula_24">(a) (b) (c) (d) (e) (f) (g)</formula><p>Abbildung 7.7: Sieben gültige und potentiell verwendete Gangoperationen.</p><formula xml:id="formula_25">(a) (b) (c) (d) (e) (f) (g) (h) (i) (j) (k) (l) (m) (n) (o) (p)</formula><p>Abbildung 7.8: 16 gültige und potentiell verwendete Zwischen-Gangoperationen.</p><p>dass T optimal ist. Rekursive Update Funktion Folgend aus den zuvor erwähnten Beobachtungen, sollen zwei (n + 1) × (ν) Matrizen σ und τ eingeführt werden, wobei n die Anzahl an Gängen mit einzusammelnden Artikeln und ν die Anzahl an verwendbaren Modulen sind. Ein Eintrag σ ij , mit 1 ≤ i ≤ n und 1 ≤ j ≤ ν, steht für die Länge einer gültigen Tour T , welche alle Gänge 1, . . . , i besucht, das heißt alle benötigten Artikel aus den Gängen 1 bis i einsammelt und Modul j für Gang i verwendet. Analog dazu steht ein Eintrag τ ij für die Länge einer Tour T , welche wiederum die Gänge 1, . . . , i besucht und Modul j für Gang i verwendet. Im Gegensatz zu Tour T besteht aber bei Tour T die Möglichkeit durch Verwendung bestimmter Module in den Gängen i + 1 bis n, ungültig zu werden.</p><p>Die Einträge für σ und τ berechnen sich mittels folgender rekursiver Funktion: σ 0µ = 0 (7.1) τ 0µ = 0 (7.2) σ 0j = ∞ für j ∈ {1, . . . , ν} \ {µ} (7.3)</p><formula xml:id="formula_26">τ 0j = ∞ für j ∈ {1, . . . , ν} \ {µ} (7.4) σ ij = c i (j) + min {σ i−1j : j ∈ M g (j)} ∪ {τ i−1j : j ∈ M g (j)</formula><p>} für i ∈ {1, . . . , n} für j ∈ {1, . . . , ν} (7.5)</p><formula xml:id="formula_27">τ ij = c i (j) + min {σ i−1j : j ∈ M komp (j)} ∪ {τ i−1j : j ∈ M komp (j)} für i ∈ {1, . . . , n} für j ∈ {1, . . . , ν} (7.6)</formula><p>In diesem Fall repräsentiert Modul µ die Verdichtungszone. Wenn ein Modul j für Gang i nur ungültige Touren bilden oder nicht kompatibel nach unten sein würde, so wird σ ij = ∞, beziehungsweise τ ij = ∞ gesetzt.</p><p>Dekodierung einer optimalen Tour Sind nun die beiden Matrizen σ und τ wie beschrieben initialisiert worden, dann kann man die optimale Tour einfach daraus ableiten. Zuerst muss das Modul für Gang n in der optimalen Tour gewählt werden, welches jener Eintrag σ nj repräsentiert, der minimal ist für alle j. Um die bereits gemachten¨Uberlegungengemachten¨ gemachten¨Uberlegungen zu ergänzen, sind alle gültigen Module in Gang n solche, die zwar mittels Zwischen-Gangoperationen zum Gang n − 1 verbinden, nicht aber zu Gang n + 1.</p><p>Zur Vereinfachung nehmen wir an dieser Stelle an, dass σ nJ das Modul für Gang n in einer optimalen Tour bezeichnet. Es ist dann leicht zu zeigen, dass so ein Eintrag existieren muss. Nun kann man einfach innerhalb der Matrix zurückverfolgen, dass das Modul für Gang n − 1 jenes Modul j ist, für das die Gleichung (7.7) erfüllt ist:</p><formula xml:id="formula_28">σ nJ − c i (j) = σ i−1j τ i−1j (7.7)</formula><p>Für alle weiteren Gänge lässt sich die optimale Tour entsprechend ableiten. Sollte der Fall eintreten, dass mehr als ein Modul die Gleichung (7.7) erfüllt, so ist das gleichbedeutend damit, dass es mehrere optimale Touren gibt. Aus diesen Touren ist dann eine beliebige wählbar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.3">S-Shape-Heuristik</head><p>Wie bereits in Kapitel 3.4 erwähnt, gibt es Arbeiten, welche zur Berechnung von Touren auf die so genannte S-Shape-Heuristik zurückgreifen. Das Verfahren folgt ei- nem einfachen Prinzip, wonach sich die Arbeiter auf S-förmigen Touren durch das 45 VZ Abbildung 7.10: Veranschaulichung der S-Shape-Heuristik</p><p>Lager bewegen. Dabei wird ein Gang durchquert sobald er betreten wurde. Natürlich werden Gänge, aus denen kein Artikel geholt werden muss, ausgelassen. Zur Veran- schaulichung dieser Vorgehensweise soll Abb. 7.10 dienen. Laut den bereits referen- zierten Arbeiten <ref type="bibr" target="#b5">[4]</ref> sowie <ref type="bibr" target="#b6">[5]</ref> kann man auf diese Weise Lösungen finden, die für viele Probleminstanzen nahe am Optimum liegen. Das ist der Grund dafür, weshalb diese Heuristik in Kombination mit TSH im Rahmen dieser Arbeit als Referenzver- fahren eingesetzt wurde. Damit kann man einen Vergleich zu den mittels des entwi- ckelten hybriden Verfahrens berechneten Ergebnissen anstellen und deren Qualität einschätzen. Hierbei sollte darauf hingewiesen werden, dass es sich bei den mittels S- Shape-Heuristik gefundenen Werten nur um Richtwerte handelt. Im Gegensatz zum vorgestellten Algorithmus werden keine Nebenbedingungen geprüft. Daher werden beispielsweise weder Kollisionen vermieden und Artikel stets vom ersten gefundenen Lagerplatz geholt anstatt nach alternativen Lagerplätzen zu suchen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Zuordnung von Arbeitern zu Touren</head><p>Zusätzlich zu den bisherigen Schritten ist es noch wichtig eine Aufteilung aller be- rechneten Touren auf die verfügbaren Lagerarbeiter zu erstellen. Das bedeutet, dass jedem Arbeiter eine Liste von Touren zugewiesen wird, die von diesem dann abgear- beitet werden muss. Nachdem sich aber alle Arbeiter gleichzeitig im Lager bewegen, müssen entsprechende Maßnahmen getroffen werden, um gegenseitige Behinderungen auszuschließen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Zuordnung von Arbeitern zu Touren</head><p>Algorithmus 9 : Initiale Arbeiter-Zuordnung Input : eine Menge T von Touren T i , mit i = 1 . . . m; die Anzahl an Arbeitern</p><formula xml:id="formula_29">w Data : Menge W von Mengen W i , mit i = 1 . . . m, von abzuarbeitenden Touren, Zähler l begin foreach W i ∈ W do W i ← ∅ ; j ← 1 ; foreach T i ∈ T do W j ← W j ∪ {T i } ; if l &lt; m then l ← l + 1 ; else l ← 1 ; return W ; end</formula><p>Eine Zuordnung von Arbeitern zu Touren soll also genau dann gültig sein, wenn es zu keinem Zeitpunkt zu Kreuzungen der Touren zweier Arbeiter innerhalb von Re- galgängen kommt. Des weiteren sind¨Uberholmanöversind¨ sind¨Uberholmanöver in Gängen nicht zulässig. Um das berücksichtigen zu können, muss die Geschwindigkeit der Kommissionierungswa- gen genauso beachtet werden, wie auch die Zeit, die notwendig ist, um die jeweiligen Artikel auszufassen.</p><p>Trotz all dieser formalen¨Uberlegungenformalen¨ formalen¨Uberlegungen darf man nicht vergessen, dass immer noch Menschen in diesem Lager arbeiten, weshalb man entsprechende Zeitpuffer einplanen muss. Die Arbeitsgeschwindigkeit ist eben abhängig von sehr vielen Faktoren, wie etwa Alter und Erfahrung der Arbeiter, oderäußerenoderäußeren Einflüssen aus dem Umfeld des Lagers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.1">Konstruktionsheuristik</head><p>Zur Erzeugung einer Startlösung für weitere Berechnungen muss zunächst eine in- itiale Zuordnung von Arbeitern zu Touren erfolgen, indem die vorhandenen Touren gleichmäßig auf alle Arbeiter verteilt werden. Der einfache Ansatz einer First-Fit Heuristik wird zum Auffinden einer solchen Initiallösung herangezogen (siehe Alg. 9). Jedenfalls stellt eine solche erste Lösung keinerlei Anspruch auf Korrektheit. Zum einen können Kollisionen der Arbeiter innerhalb von Regalgängen auftreten, zum anderen kann nicht garantiert werden, dass alle angeforderten Artikel innerhalb des zulässigen Zeitrahmens zur Verdichtungszone gebracht werden. Es müssen also noch weitere Schritte folgen, um eine Zuordnung gültig zu machen. Auch hier hilft wieder 47 die Umsetzung einer VNS weiter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.2">Reparatur-und Verbesserungsheuristik</head><p>Zusätzlich zur Entscheidung, ob eine Zuordnung von Arbeitern zu Touren gültig ist, wird versucht eine Aufteilung zu finden, bei der alle Arbeiter mit ihren Arbeitsschrit- ten so früh wie möglich fertig werden. Zu diesem Zweck bietet sich eine Zielfunktion an, die den letzten Endzeitpunkt aller Arbeiter auswertet. </p><formula xml:id="formula_30">WorkerShiftTourMove(i, j, k) Bei diesem Schritt wird Tour j, mit j ∈ W i , um k Positionen verschoben, wobei |k| &lt; |W i | und 1 ≤ j + k ≤ |W i |.</formula><p>Eine solche Umreihung kann in Bezug auf die termingerechte Abwicklung hilfreich sein.</p><p>WorkerSplitMove(i, R) Bei der Anwendung dieses Schrittes werden alle Elemente in R aus W i entfernt und in eine neue Zuordnung W i eingefügt, welche dann einem neuen Arbeiter zugewiesen werden kann. Dieser Schritt kann natürlich nur angewendet werden, solange noch freie Arbeiter zur Verfügung stehen.</p><p>Aus diesen Moves ergeben sich die Nachbarschaftsstrukturen WorkerSwap, WorkerS- hift, WorkerShiftTour und WorkerSplit.</p><p>Nachdem das Hauptziel dieser VNS Prozedur das Auffinden einer gültigen Zuordnung von Touren zu Arbeitern ist, werden nur Moves berücksichtigt, deren Resultat eine gültige Lösung darstellt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Erweiterter Algorithmus</head><p>Da die hier vorgeschlagenen Methoden insgesamt dafür ausgelegt sind in vergleich- bar kurzer Zeit relativ gute Lösungen zu erzeugen, ist es durchaus wahrscheinlich, dass die gefundenen Lösungen noch weiter verbessert werden könnten. Zudem sind</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Erweiterter Algorithmus</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 10 : Erweiterter Algorithmus</head><p>Input : Bestellungen mit Listen aller einzusammelnder Artikel Output : Eine Zuordnung von Arbeitern zu fertigen Touren begin repeat</p><formula xml:id="formula_31">(1)</formula><p>Erstelle Partitionierung vorhandener Bestellungen ; repeat repeat <ref type="bibr" target="#b3">(2)</ref> Berechne Zuordnung von Artikeln zu Touren ;</p><p>Berechne optimale Touren für die oben erstellte Zuordnung ; until keine Verbesserung konnte erzielt werden ; <ref type="bibr" target="#b5">(4)</ref> Erstelle eine Zuordnung von Arbeitern zu Touren ; return die aktuelle Zuordnung von Arbeitern zu Touren ; until ein definiertes Abbruchkriterium ist erfüllt ; until keine weiteren Bestellungen sind abzuarbeiten ; end zu dem Zeitpunkt, zu dem der Algorithmus zu arbeiten beginnt, noch nicht alle Bestellungen bekannt, die im Laufe des Tages zu bearbeiten sein werden. Deshalb empfiehlt es sich eine erweiterte Variante des Alg. 3 wie in Alg. 10 beschrieben zu verwenden. Anstelle eines Abbruchs, sobald eine Zuordnung von Touren zu Arbeitern gefunden wurde, soll der Algorithmus hier wieder von vorne beginnen, allerdings un- ter Berücksichtigung von bereits bearbeiteten Aufteilungen. Das bedeutet etwa, dass bereits eingesammelte Artikel natürlich nicht mehr vertauscht werden können, oder, dass Arbeiter, die bereits auf dem Weg zu einem Artikel sind nicht mehr anders geschickt werden können. Sonstigë Anderungen können natürlich noch durchgeführt werden, solange sie eine Verbesserung der Gesamtlösung bringen. Der Algorithmus sollte dann arbeiten, bis alle Bestellungen anforderungsgemäß bearbeitet wurden.</p><p>Um den Algorithmus möglichst effizient zu gestalten, müssen natürlich auch die dar- unterliegenden Datenstrukturen entsprechend gewählt werden und Bewertungsfunk- tionen oder im Speziellen die Funktion zur Berechnung optimaler Touren möglichst schnell arbeiten. <ref type="bibr">49</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Testergebnisse</head><p>Um die Verwendbarkeit der vorgestellten Methode im industriellen Umfeld abschät- zen zu können, wurden zahlreiche Testläufe durchgeführt. Als Hardware wurde ein zur Zeit aktuelles Arbeitsplatzsystem gewählt -konkret ein Dual Xeon mit 2.6 GHz und 8 GB RAM. Leider war es nicht möglich Echtdaten zu bekommen, da zum Zeitpunkt der Fertigstellung dieser Diplomarbeit noch keine hardwaremäßige Reali- sierung im Ersatzteillager unseres Industriepartners vorgenommen wurde, weswegen auf statistische Parameter, die im Laufe des vergangenen Jahres gesammelt wur- den, zurückgegriffen werden musste, um zufällige Testinstanzen zu generieren. Hierzu wurde das Lager modelliert und die einzusammelnden Artikel den Parametern ent- sprechend zufällig im Lager verteilt. Zusätzlich wurden typische Kundenbestellungen erzeugt. Variable Parameter waren dabei die Summe der insgesamt bestellten Arti- kel und die Anzahl der Kundenbestellungen. Nach Rücksprache mit den Lagerleitern wurde festgesetzt, dass Rechenzeiten bis 20 Minuten als akzeptabel gelten, weswegen die maximal verfügbare Rechenzeit auf diese 20 Minuten gesetzt wurde.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Wahl der Konstruktionsheuristik</head><p>In einem ersten Vortest wurde untersucht wie die beiden Konstruktionsheuristiken zur Findung einer Ausgangslösung den gesamten Algorithmus beeinflussen. Die ver- wendeten Testinstanzen sind nicht ident mit jenen der späteren Testläufe, da durch die im Laufe der Entwicklung entstandenen Erweiterungen des Programms auch die TestdatenüberarbeitetTestdaten¨Testdatenüberarbeitet werden mussten. Deshalb sind die Ergebnisse dieses Vortests nicht direkt mit den späteren vergleichbar. In Tab. 8.1 sind die gesammelten Ergeb- nisse ersichtlich. Sie zeigen die absoluten Werte der Summe aller Tourlängen für die in Kapitel 7.2.1 vorgestellten Konstruktionsheuristiken CAH und TSH.</p><p>Natürlich sind diese Werte für sich noch nicht sehr aussagekräftig, vergleicht man sie allerdings miteinander, so lassen sich gewisse Beobachtungen machen. Zunächst fällt auf, dass die errechneten Werte der Tourlängen nicht in unmittelbarem Zu- sammenhang mit der gewählten Methode zur Erzeugung einer Startlösung gebracht werden können. Es gibt in beiden Fällen an manchen StellenüberdurchschnittlichStellen¨Stellenüberdurchschnittlich große Abweichungen. Abgesehen von wenigen Ausnahmen schwanken die Werte für die Tourlängen im direkten Vergleich zwischen den beiden Konstruktionsheuristiken kaum. Das legt die Vermutung nahe, dass die Wahl der Konstruktionsheuristik, wennüberhaupt wenn¨wennüberhaupt, nur einen vernachlässigbaren Einfluss auf die endgültige Lösung hat. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Effizienz einzelner Nachbarschaften</head><p>Neben den im vorigen Abschnitt erläuterten Ergebnissen, wurde auch das Verhal- ten der Nachbarschaften im Verlauf des Algorithmus ausgewertet. In <ref type="table">Tab</ref> Sofort fallen viele Einträge mit " 0.0%" auf. Vor allem Nachbarschaft N 7 ist hier sehr dominant, was aber durchaus zu erklären ist, da ein verteiltes Einsammeln eines Ar- tikels von mehreren Positionen bedeutet, eine Position mehr im Lager anfahren zu müssen. Es ist zwar vorstellbar, dass in manchen Szenarien solch eine Aufteilung von Nutzen ist, die Tests haben allerdings gezeigt, dass damit nicht sehr viel verbes- sert werden kann. Das Verhalten im Echtbetrieb kann leider nur schwer eingeschätzt werden, denn hierzu müsste man auf Basis von echten Daten entsprechende Aus- wertungen erstellen. Weiters sind die Nachbarschaften N 5 und N 6 nur dann sinnvoll, wenn auch alternative Positionen von Artikeln im Lager verwendet werden, deshalb wurden die entsprechenden Einträge mit " -" markiert. Zusätzlich dazu beeinflusst die dynamische Reihung der Nachbarschaften deren Effizienz entscheidend, was sehr deutlich bei N 8 zu sehen ist. Da bei statischer Reihenfolge der Nachbarschaften schon N 3 viele ShiftMoves durchführt, so bleiben für N 8 natürlich kaum mehr Möglichkei- ten zur Verbesserung. Anders bei dynamischer Reihenfolge, wo die Nachbarschaften einigermaßen gleichmäßig verteilt zum Einsatz kommen. Eine weitere Beobachtung kann hinsichtlich N 2 gemacht werden. Der Prozentsatz ist hier vor allem bei größeren Instanzen sehr klein, was darauf zurückzuführen ist, dass Merge nur dann sinnvoll verwendet werden kann, wenn Kommissionierungswagen weit unter ihrer Kapazität ausgelastet sind, was lediglich zu Beginn des Algorithmus sehr wichtig ist, mit zu- nehmender Laufzeit aber kaum mehr vorkommen dürfte. Besonders effizient hinge- gen verhält sich N 1 , wo ein sehr hoher Prozentsatz an erzeugten SplitMoves auch tatsächlich zu einer Verbesserung der Gesamtlösung führt. Dabei steht vor allem das Beseitigen vonüberfülltenvon¨vonüberfüllten Kommissionierungswagen und damit ungültigen Touren im Vordergrund.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Rechenzeit der Nachbarschaften</head><p>Repräsentativ für das Laufzeitverhalten der einzelnen Nachbarschaften soll Tab. 8.5 (Testlauf 1) zeigen, wie hoch der Rechenaufwand der einzelnen Nachbarschaften ausfällt.</p><p>Vor allem N 8 schlägt hier mit besonders hohem Aufwand zu Buche, was durch die ei- nigermaßen hohe Effizienz bei Verwendung dynamisch veränderbarer Nachbarschafts- 57         </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Rechenzeit der Nachbarschaften</head><p>Tabelle 8.5: Rechenzeit -Durchschnittswertë uber 20 Testläufe mit 25, 50, 100 und 200 einzusam- melnden Artikeln. Zu sehen ist der prozentuelle Anteil (alle Werte in Prozent <ref type="bibr">[%]</ref>) an Rechenzeit der jeweiligen Nachbarschaft in Relation zur Rechenzeit für alle Nachbarschaften für Instanzen oh- ne bzw. mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit Umkehren innerhalb eines Ganges und dynamischer Nachbarschaftsreihenfolge.</p><p>(N 1 : Split; N 2 : Merge; N 3 : Shift; N 4 : Swap; N 5 : SwapPosition; N 6 : SwapPositionMerge; N 7 : SplitPositionMerge; N 8 : DoubleShift; N 9 : ShiftSplit; N 10 : SwapSplit; N 11 : MultipleSwap; N 12 : MultipleSplit; N 13 : SplitMerge.)  strukturen durchaus vertretbar ist. Bei statischer Nachbarschaftsreihenfolge hingegen macht die Verwendung dieser Nachbarschaft keinen Sinn und sollte ausgelassen wer- den. Wie intuitiv außerdem zu erwarten war, benötigen N 3 und N 4 deutlich mehr Aufwand zum Durchsuchen, als dië ubrigen Nachbarschaften. Sind es bei kleinen In- stanzen noch je etwa 10% der Rechenzeiten, so steigt der Anteil für große Instanzen auf 30-40% an.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Laufzeit und Lösungsverbesserung</head><p>Ein wesentlicher Aspekt des entwickelten Algorithmus ist das Auffinden von guten Lösungen innerhalb möglichst kurzer Zeit, da im Echtbetrieb nicht uneingeschränkt viel Zeit zur Verfügung stehen kann. Aus diesem Grund ist eine Visualisierung des Verlaufs der Lösungsverbesserung durchaus interessant, was anhand von Instanz M3 bei Berechnung mit alternativen Lagerplätzen und dynamischer Nachbarschaftsrei- henfolge in Abb. 8.1 dargestellt wird. Es ist dabei eindeutig zu erkennen, dass in- nerhalb der ersten 100 Iterationen des VND bereits eine sehr gute Lösung erreicht wird, welche im weiteren Verlauf zwar noch geringfügig verbessert wird, aber nicht mehr in so hohem Maß wie zu Beginn. Es sollte darauf hingewiesen werden, dass die Verbesserungen innerhalb der zweiten 100 Iterationen bei weitem nicht so gravierend sind, da hier die veränderte Skalierung der y-Achse für die Tourlänge zwischen 0 und 50000 beachtet werden muss.</p><p>Dieses Verhalten istäußerstistäußerst günstig für die Verwendung im realen Umfeld, wo vor allem schnelle Antwortzeiten von Bedeutung sind. In manchen Fällen wird es dort nötig sein, schon nach kurzer Zeit den Algorithmus abzubrechen und die bis dahin vorliegende Lösung zu verwenden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften</head><p>Um das Verhalten des Algorithmus bei der Verwendung zusätzlicher Nachbarschaften beobachten zu können, wurde ein weiterer Testlauf durchgeführt, der unter den glei- chen Voraussetzungen wie der in Kapitel 8.2 beschriebene durchgeführt wurde. Hier- bei wurde allerdings nur mehr mit dynamischer Nachbarschaftsreihenfolge gerechnet, es kamen aber weitere Nachbarschaften zum Einsatz. Verwendet wurden hier neben Split, Merge, Shift, Swap, SwapPositionMerge, SplitPositionMerge und DoubleShift auch ShiftSplit, SwapSplit, MultipleSwap, MultipleSplit und SplitMerge. Diese Auf- listung entspricht wieder gleichzeitig der Anfangsreihenfolge der Nachbarschaften. Weiters wurde SwapPosition ausgelassen, da diese bereits durch SwapPositionMerge abgedeckt ist. In Tab. 8.2 und Tab. 8.3 sind die in diesem Test (Testlauf 2) erzielten Ergebnisse und Laufzeiten des Algorithmus zu sehen. Diese Tabellen enthalten auch die Ergebnisse aus Testlauf 1, was die Gegenüberstellung erleichtert. Es ist zu erkennen, dass von allen berechneten 80 Instanzen nur 11 nicht besser gelöst werden konnten und die Summe aller Zielfunktionswerte bei Instanzen ohne Umkehren innerhalb von Gängen um rund 20% und bei Instanzen mit Umkehren sogar um etwa 22% verbessert wer- den konnte. Gleichzeitig muss aber auch gesagt werden, dass die Berechnungen zum Teil mehr als die doppelte Laufzeit bei kleineren Instanzen benötigten. Dennoch konnten auch die Zielfunktionswerte großer Instanzen, deren Bearbeitung nach dem Grenzwert von 1200 Sekunden abgebrochen wurde, in derselben Zeit wie im vorigen Testlauf deutlich verbessert werden.</p><p>Die Auswertung der Effizienz der Nachbarschaften in Tab. 8.6 zeigt einähnlicheseinähnliches Bild, wie in Tab. 8.4. Zur besseren¨Ubersichtbesseren¨ besseren¨Ubersicht wurden nur die Werte für Berechnungen mit Umkehren innerhalb eines Ganges herangezogen. Zusätzlich ist hier ersichtlich, dass die neu hinzugekommenen Nachbarschaften N 9 -N 13 eine durchwegs hohe Verbesse- rungsquote aufweisen.</p><p>Die Rechenzeiten aus Testlauf 2, wie in Tab. 8.5 zu sehen ist, weisen Parallelen zu den in Testlauf 1 erhaltenen Werten auf. Im Wesentlichen bestätigt das Ergebnis die be- reits zuvor ermittelten Zahlen, wobei es zu leichten Verschiebungen gekommen ist, da die neu hinzugefügten Strukturen mit Kombinationen aus zuvor einzeln angewandten arbeiten. Hier sind die Berechnungen für kombinierte und damit komplexere Struk- turen natürlich auch aufwändiger, aufgrund des Erfolgs ist deren Anwendung aber wünschenswert. Besonders auffällig ist der hohe Rechenaufwand für SplitMergeCom- bine, wo im Vergleich dazu im vorangegangenen Testlauf DoubleShift den größten Anteil an Rechenzeit benötigte.</p><p>Es hat sich also gezeigt, dass die neu eingebundenen Nachbarschaftsstrukturen ein durchwegs positives Resultat bringen und die Lösung tatsächlich verbessern konnten. Teilweise konnten die Zielfunktionswerte sogar um 50% verringert werden und nur in wenigen Fällen wurden geringfügig schlechtere Ergebnisse erzielt, als beim vorherigen Testlauf.</p><p>Abschließend ist zu den Testergebnissen zu sagen, dass durchwegs positive Resultate erzielt werden konnten. Auch im Vergleich zur Lösung mittels S-Shape-Heuristik konnten mehrheitlich bessere Werte berechnet werden. Zusätzlich dazu sollte noch einmal darauf hingewiesen werden, dass unter der Verwendung der S-Shape-Heuristik keine Nebenbedingungen, wie etwa Kollisionen zwischen Arbeitern, geprüft werden konnten. Es wurde damit lediglich eine Referenzlösung erzeugt.</p><p>Es bleibt nun noch zu erwähnen, dass die hiermit geschilderten Beobachtungen darauf schließen lassen, dass weitere Verbesserungen etwa in Zusammenhang mit Anpassun- gen der Nachbarschaftsstrukturen durchaus möglich sind. In jedem Fall bietet sich ein Einsatz im Echtbetrieb an, um die Leistungsfähigkeit des entwickelten Ansatzes unter realen Bedingungen zu ermitteln.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>21 22 Die vorliegende Problemstellung macht es unmöglich ein konstruktives Verfahren zu entwickeln, dass in polynomieller Zeit zur optimalen Lösung führt, weshalb eine Alter- native gefunden werden muss. Die Herausforderung dabei stellen die Probleminstan- zen dar, durch welche bei einer Größenordnung, die im Echtbetrieb vorstellbar wäre, die Anzahl der gültigen Lösungen sehr groß wird. Würde man alle möglichen Lösun- gen untersuchen wollen oder mit exakten Verfahren wie Branch &amp; Bound arbeiten, so würde dies zu nicht akzeptablen Rechenzeiten führen. Man kann davon ausgehen, dass es sich dabei um mehrere Stunden handeln würde, man im Echtbetrieb je nach Situation aber bei einer vertretbaren Zeitspanne im Bereich von Sekunden bis zu maximal wenigen Minuten liegen muss.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>:</head><label></label><figDesc>Abbildung 7.1: Lagerrepräsentation (a) als Graph (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Abbildung 7.4: Gültige und ungültige Module.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Gegeben ist eine Tour T von kürzester Länge in Bezug auf eine Menge an Punkten, die von T besucht werden. Weiters wird angenommen, es gibt zwei adjazente Punkte v und w, welche in T zweimal unmittelbar hintereinander besucht werden. Der Weg zwischen v und w wird dann in T einmal von v nach w passiert und einmal umgekehrt.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Für</head><label></label><figDesc>ein sinnvolles VNS Verfahren muss nun noch eine Anzahl an Nachbarschaften (hier anhand von Moves) definiert werden. Sei W = w i=1 {W i } die Menge aller Zu- ordnungen W i von Arbeitern zu Touren. Weiters nehme man an, dass T = m i=1 {T i } die Menge aller zuvor berechneter Touren beschreibt. Folgende Moves bilden die Basis für die verwendeten Nachbarschaften: WorkerSwapMove(i, j, k, l) Dieser Schritt definiert einfach den Austausch von Tour k ∈ W i und l ∈ W j , mit 1 ≤ i &lt; j ≤ m und k = l. Das bedeutet schlicht, dass zwischen zwei Arbeitern je eine Tour ausgetauscht wird. WorkerShiftMove(i, j, k) Hier wird lediglich eine Tour k ∈ W i aus W i entfernt und in W j an letzter Stelle angefügt, wobei 1 ≤ i, j ≤ m und i = j. Das kommt einem Verschieben einer Tour von einem Arbeiter zu einem anderen gleich.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Testläufe mit 25, 50, 100 und 200 einzusammelnden Artikeln (Ar</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Abbildung 8.1: Verlauf der Zielfunktion im Vergleich zur Anzahl der gefundenen Verbesserungen (Achtung: Unterschiedliche Skalierung der y-Achse für [0; 50000] und (50000; 2000000])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Generalized Traveling Salesman Problem [10] behandelt die leicht abgeänderte Variante des eigentlichen Problems, welche alle zu besuchenden Orte in Gruppen einteilt und verlangt, dass genau ein Ort aus jeder Gruppe besucht werden muss. Welcher das ist, kann frei gewählt werden. Es sind dafür also zwei miteinander ver</head><label></label><figDesc></figDesc><table>-
knüpfte große Schritte notwendig, nämlich einerseits die Auswahl einer Teilmenge von 
Knoten des zugrunde liegenden Graphen, wobei aus jeder Gruppe von Orten jeweils 
genau einer in dieser Teilmenge enthalten ist und andererseits die Bestimmung einer 
Tour mit minimalen Kosten innerhalb des Teilgraphen, der aus den ausgewählten 
Knoten entstanden ist. 

3.4 Bekannte Lösungsansätze 

Zur Lösung des Vehicle Routing Problem gibt es einige Ansätze, die unter anderem 
Variable Nachbarschaftssuche oder Tabu-Suche einsetzen. Hierbei wird der Einsatz 
solcher heuristischer Verfahren gewählt, da aufgrund der Problemstellung bereits für 
kleine Probleminstanzen eine Vielzahl an möglichen Lösungen existiert, gleichzeitig 
aber kein Algorithmus bekannt ist, der in polynomieller Zeit eine optimale Lösung 
konstruiert. 

In [13] wird etwa beschrieben, wie mittels Tabu-Suche nach einer Lösung für ein 
SDVRP kombiniert mit einem VRPTW gesucht werden kann, für die die Anzahl 
der verwendeten Fahrzeuge sowie die Länge der insgesamt zurückgelegten Strecke 
minimiert werden. 

Auch exakte Verfahren wie Ganzzahlige Lineare Optimierung (engl.: Integer Linear 
Programming) (ILP) und Branch &amp; Bound beziehungsweise Branch &amp; Cut werden 
häufig zur Lösung herangezogen. Ausgehend von einer ILP-Formulierung beschreibt 
etwa [15] einen solchen Ansatz zur Lösung von CVRP-Instanzen mittels Branch &amp; 
Cut. 

In Zusammenhang mit Warenlagern, deren Anordnung in klassischer rechteckiger 
Form vorliegt, ist auch das Aufsuchen von Touren ein interessantes Teilproblem im 
Zuge der Optimierung von Lagerabläufen. In [5] wird ein Verfahren, die sogenannte 
S-Shape-Heuristik, betrachtet, das der Erstellung solcher Touren dient. Dabei be-
wegen sich die Lagerarbeiter S-förmig durch das Lager, das heißt, dass ein Gang 
komplett durchquert wird, sobald er einmal betreten wurde. Interessant ist dieser 
Ansatz besonders deshalb, da er später für Vergleiche zu dem in dieser Arbeit vor-
gestellten Verfahren herangezogen wird. Betrachtungen der S-Shape-Heuristik, sowie 
Varianten davon finden sich auch in [4], wo außerdem auf die Komplexität solcher La-
gerabläufe hingewiesen wird und klar hervorgeht, dass entsprechende Probleme stets 
sehr speziell sind. Es gibt also kein Konzept und kein globales Optimierungsmodell 
für eine systematische BehandlungähnlicherBehandlungähnlicher Situationen. 

13 

14 Unter dem Begriff der Dynamischen Programmierung versteht man ein algorithmi-
sches Verfahren, bei dem in mehreren voneinander abhängigen Schritten Entschei-
dungen getroffen werden, die zur optimalen Lösung eines Problems führen. Dabei ist 
stets die Lösung eines Problems unter Ausnützung des WissensüberWissens¨Wissensüber bereits gelöste 
Teilprobleme ein wesentlicher Bestandteil. Die in den einzelnen Berechnungsschrit-
ten zu lösenden Teilprobleme sind außerdem immer abhängig von den zuvor schon 
gelösten. Sobald zu einem Teilproblem eine Lösung berechnet wurde, wird diese mit-
protokolliert, um für die spätere Verwendung abgerufen werden zu können und nicht 
wiederholt berechnet werden zu müssen. So arbeitet man sich schrittweise anhand 
optimaler Teillösungen zur Lösung des Gesamtproblems vor. 

Der Ansatz der Dynamischen Programmierung basiert auf folgendem ursprünglich 
von Bellman formulierten Postulat [3]: 

" 
Ein optimales Verfahren hat die Eigenschaft, dass, wie auch immer 
der Anfangszustand und die erste Entscheidung ausfielen, die folgenden 
Entscheidungen für eine optimale Lösung sich auf den Zustand, der aus 
der ersten Entscheidung resultiert, beziehen müssen." 

Wesentlich dabei ist, dass alle Entscheidungen des Algorithmus von bereits zuvor 
getroffenen abhängen. Das bedeutet, dass die Lösung eines Teilproblems als Aus-
gangspunkt stets die Lösung eines vorangehenden Teilproblems heranziehen muss. 
Folgt man diesem Prinzip, dann versucht man das Problem derart zu zerlegen, dass 
jedes der entstehenden Teilprobleme optimal gelöst werden kann. Am Ende wird die 
optimale Lösung des initial formulierten Problems erreicht und kann durch die zuvor 
durchgeführten Schritte zusammengesetzt werden. 

EinähnlicherEinähnlicher Ansatz, der ebenso das Zerlegen eines Problems in Teilprobleme ver-
folgt, ist Divide &amp; Conquer. Dieses Verfahren unterscheidet sich allerdings wesentlich 
von Dynamischer Programmierung, da hier per Definition keine Abhängigkeit zwi-
schen den einzelnen Teilproblemen bestehen muss. 

Kürzeste Wege in einem Graphen 

Ein gutes Beispiel für Dynamische Programmierung bietet der Algorithmus für kür-
zeste Wege in einem Graphen, welcher 1959 von Dijkstra [6] vorgestellt wurde. Ge-

15 </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>1 .</head><label>1</label><figDesc></figDesc><table>Aufteilung des Problems in kleinere, voneinander abhängige Probleme 

2. Finden einer optimalen Lösung für die Teilprobleme 

3. Kombinieren der optimalen Teillösungen zur Berechnung der optimalen Lösung 
für das Gesamtproblem 

Es sei hier nochmals auf den wesentlichen Aspekt der Abhängigkeit von Teilproble-
men hingewiesen, welcher etwa bei Divide &amp; Conquer nicht Teil des Konzepts ist. 

16 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>1 .Lösung haben. Das bedeutet, dass eine schlechte Lösung durch kleine Adaptionen schnell zu einer sehr guten Lösung werden kann. Da dies alleine noch nicht ausreicht um die notwendigen Kommissionierungstouren bereitzustellen, ist als weiterer Bestandteil die Berechnung von optimalen Touren notwendig. Zu diesem Zweck schien es aufgrund der eingrenzbaren Möglichkeiten für einzelne</head><label>1</label><figDesc></figDesc><table>Partitionierung vorhandener Bestellungen -Der erste Schritt soll aus al-
len vorhandenen Bestellungen jene auswählen, die im Weiteren bearbeitet wer-
den. Dabei wird einerseits berücksichtigt welche Priorität eine Bestellung auf 
Basis ihres Liefertermins hat und andererseits welche Kapazitätsbeschränkun-
gen in der Verdichtungszone vorherrschen. Es soll bereits durch diesen Schritt 
sichergestellt sein, dass Artikel aus einer Bestellung stets im selben Bereich der 
Verdichtungszone gelagert werden (siehe auch Kapitel 2). 

2. Berechnung von Artikelauswahlen -In einem zweiten Schritt werden dann 

23 die einzusammelnden Artikel in so genannte Artikelauswahlen zerlegt. Das heißt 
es werden Listen von Artikeln erstellt, die dazu dienen, die innerhalb einer 
Tour abzuarbeitenden Artikel zu definieren. Dieser Schritt wird durch eine VNS 
abgedeckt, die viele verschiedene solcher Artikelauswahlen erzeugt, um später 
konkrete Touren daraus zu berechnen. 

3. Berechnung von Kommissionierungstouren -Wie bereits im vorange-
gangenen Schritt beschrieben, geht es hierbei um das Finden konkreter Tou-
ren durch das Lager. Für jede einzelne Artikelauswahl kann nun mittels eines 
Dynamischen Programms sehr schnell die optimale Tour in Bezug auf deren 
Länge berechnet werden. Die Summe der Längen aller Touren stellt dabei die 
Güte der gesamten Lösung in dieser Konstellation dar. Sobald dieser Schritt 
abgeschlossen ist, kann entschieden werden, ob das vorhandene Ergebnis an 
die LagerarbeiterübergebenLagerarbeiter¨Lagerarbeiterübergeben werden soll, oder nochmals zum vorigen Schritt 
zurückgegangen werden soll, um durch neue Artikelauswahlen ein möglicher-
weise besseres Gesamtergebnis erzielen zu können. 

4. Zuweisen der Touren zu Arbeitern -Im letzten Schritt werden die vor-
handenen Touren an die verfügbaren Lagerarbeiter vergeben. Hier wird wieder 
mittels einer weiteren VNS versucht eine möglichst optimale Aufteilung zu er-
reichen, damit die letzte Tour zum frühest möglichen Zeitpunkt beendet werden 
kann. Sollten nach diesem Schritt noch weitere Bestellungen im System vor-
handen sein, beginnt einfach ein neuer kompletter Durchlauf des Algorithmus. 

Zur Veranschaulichung dieses Ablaufs dienen sowohl die schematische Darstellung in 
Abb. 6.1, als auch die Skizzierung durch Alg. 3. Dabei ist zu beachten, dass die Aus-
wertung der Zielfunktion des ersten Schritts abhängig ist von den Berechnungen des 
zweiten Schritts, wodurch ein starkes Zusammenspiel dieser beiden Phasen gegeben 
ist. Das endgültige Ergebnis aller Berechnungen soll allen verfügbaren Arbeitern des 
Lagers Touren so zuweisen, dass der Endzeitpunkt aller Touren so früh wie möglich 
ist. 

6.2 Variable Nachbarschaftssuche und Dynamische 
Programmierung 

Wie bereits erwähnt, handelt es sich bei dem Algorithmus um einen hybriden Ansatz, 
bestehend aus VNS und Dynamischer Programmierung. Dabei wird der durchsuchte 
LösungsraumLösungsraum¨Lösungsraumüber die zuvor angesprochene Einteilung in Artikelauswahlen definiert 
und dieser Schritt des Algorithmus auf Basis von VNS durchgeführt. Ausgehend 
von einer ersten Auswahl werden also alle weiteren auf bessere Zielfunktionswerte 
hin untersuchten Artikelzusammenstellungen durch stete leichte Abänderungen, defi-
niert durch das System an Nachbarschaften, generiert. Hierbei kann eine geringfügige 
Veränderung einer Artikelzusammenstellung gleichzeitig große Auswirkungen auf die 6.2 Variable Nachbarschaftssuche und Dynamische Programmierung 

Bestellungen durch 
Kunden 
Partitionierung 
vorhandener 
Bestellungen 

! 

Berechnung von 
Artikelauswahlen 
Berechnung von 
Kommissionierungstouren 
Zuweisen der Touren 
zu Arbeitern 

Abbildung 6.1: Schematische Darstellung des grundsätzlichen Ablaufs 

Algorithmus 3 : Grundsätzlicher Algorithmus 
Input : Bestellungen mit Listen aller einzusammelnder Artikel 
Output : Eine Zuordnung von Arbeitern zu fertigen Touren 

begin 
repeat 

(1) 

Erstelle Partitionierung vorhandener Bestellungen ; 
repeat 

(2) 

Berechne Zuordnung von Artikeln zu Touren ; 

(3) 

Berechne optimale Touren für die oben erstellte Zuordnung ; 
until keine Verbesserung konnte erzielt werden ; 

(4) 

Erstelle eine Zuordnung von Touren zu Arbeitern ; 
return die Zuordnung von Touren zu Arbeitern ; 
until keine weiteren Bestellungen sind abzuarbeiten ; 
end 

25 dadurch erhaltene Wegstrecken innerhalb des Lagers sinnvoll, mittels Dynamischer Program-
mierung nach einer Lösung zu suchen. Dabei werden für Auswahlen von zu besu-
chenden Lagergängen optimale Teiltouren berechnet, auf deren Basis die kürzeste 
Gesamttour erstellt werden kann. 

26 

7 Der Algorithmus im Detail 

Die in Kapitel 6 beschriebene Struktur des in dieser Arbeit entwickelten Verfahrens 
verlangt nun noch nach einer konkretisierten Beschreibung. In diesem Kapitel möchte 
ich nun die genaue Funktionsweise des Algorithmus vorstellen und im Detail auf die 
zuvor vorgestellten einzelnen Schritte eingehen. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>steht hier einem durchsuchten Raum der Größe O(1) ge- genüber (siehe auch bei DoubleShift). MultipleSplit Wie der Name bereits andeutet, werden hier einige SplitMoves mit- einander verknüpft, was die Aufspaltung mehrerer Touren auf einmal zur</head><label></label><figDesc>Dieser markante Unterschied entsteht hier, da entschieden wurde jeweils 1000 zufällig generierte Lösungen zu testen, um die Komplexität der Nachbarschafts- struktur zu umgehen. Das komplette Durchsuchen dieser, wie auch einiger der folgenden Nachbarschaftsstrukturen würde zu lange dauern. Es schien durchaus vertretbar an dieser Stelle mit einer Zufallskomponente zu arbeiten.SwapSplit Wie auch hier bereits aus dem Namen hervorgeht, wird zuerst ein Swap- Move durchgeführt und anschließend eine Zuordnung durch einen SplitMove zerlegt. Hierbei ergibt sich ein Ausmaß an Lösungen von O(|S| 3 · s SplitMerge Diese Nachbarschaftsstruktur wurde in der Form umgesetzt, dass sie in Anlehnung an den SplitMove entsprechend durchsucht wird und nach ei- ner Aufsplittung versucht wird beide neu erzeugten Touren mit allen anderen verfügbaren zu kombinieren. Dies geschieht in mehreren Schritten. Zunächst wird versucht den ersten Teil der Tour mit allen weiteren verfügbaren Touren zu kombinieren. Anschließend wird dies auch mit dem zweiten Teil probiert. Ein weiterer Schritt versucht den ersten und zweiten Teil gleichzeitig mit je- weils unterschiedlichen Touren zu kombinieren. Es entstehen hier also gleich drei unterschiedliche Ansätze pro Aufsplittung. Die Vorgehensweise unterliegt dabei weitaus weniger dem Zufall, viel eher wird versucht eine komplette Abde- ckung zu erreichen. Lediglich das Aufsplitten von Touren erfolgt nach wie vor eingeschränkt, da sonst für ein geringes Maß an Verbesserung ein unverhält- nismäßig hoher Aufwand betrieben werden müsste. Außerdem sind bei dieser Nachbarschaftsstruktur die einzelnen Moves abhängig voneinander.</figDesc><table>Ausgehend von einer konkreten Lösung sind dadurch alle Lösungen defi-
niert, welche mittels eines SwapMoves erreichbar sind. Sollen also Artikel zwi-
schen je zwei Touren vertauscht werden, so liegt die Anzahl an Möglichkeiten 
dafür in O(|S| 
2 · s 

2 

max ). 
Shift Diese Nachbarschaftsstruktur basiert auf dem ShiftMove und somit kann die 
Anzahl an möglichen Alternativen zu einer konkreten Lösung mit O(|S| 
2 · s max ) 
abgeschätzt werden. 

Merge Auch diese Struktur leitet sich aus nur einem Move ab, nämlich dem Merge-
Move. Hier kommt man für eine Lösung auf O(|S| 
2 ) mögliche neue Lösungen. 
In dieser Nachbarschaftsstruktur sind alle Lösungen enthalten, die aus einer ge-
gebenen Lösung durch Anwendung eines MergeMoves erzeugt werden können. 

Split In der Anwendung hat es sich bewährt bei dieser auf dem SplitMove basieren-
den Nachbarschaftsstruktur beim Durchsuchen auf eine komplette Abdeckung 
zu verzichten. Die insgesamt möglichen Adaptierungen können mit O(|S|·2 
smax ) 
abgeschätzt werden. Tatsächlich werden nur jene Fälle berücksichtigt, bei denen 
die Anzahl an Artikeln in einer Tour auf die Hälfte reduziert werden. Bei einer 
geraden Anzahl an Artikeln kann genau in die Hälfte geteilt werden, bei unge-
rader Anzahl entsteht dementsprechend eine Tour mit einem Artikel mehr als 
bei der anderen. Somit bleibt ein stark verminderter Umfang von O(|S| · s max ) 
¨ 
ubrig. 

SwapPosition Diese Nachbarschaftsstruktur stützt sich auf den vorgestellten Swap-
PositionMove und umfasst daher eine geschätzte Anzahl von O(|S| · s max · l max ) 
möglicher Nachbarlösungen zu einer konkreten Lösung. 

SwapPositionMerge Hier handelt es sich um eine Struktur, dië ahnlich wie Swap-
Position aufgebaut ist. Allerdings wird versucht eine jeweils durch einen Swap-
PositionMove neu entstehende Tour mit denübrigenden¨denübrigen verfügbaren Touren zu 
kombinieren. Es kommt hierbei zur Kombination mit einem MergeMove. Da-her entsteht eine Größe des in Frage kommenden Lösungsraumes von O(|S| 
2 · 
s max · l max ). 

SplitPositionMerge Grundlage für diese Nachbarschaftsstruktur bilden der Split-
PositionMove sowie der MergeMove, welche nacheinander angewendet werden. 
Konkret wird versucht etwa die Hälfte der angeforderten Menge eines Artikels 
von einem alternativen Lagerplatz zu holen. Dabei entstehen für eine Lösung 
durch O(|S| 
2 · s max · l max ) beschränkte weitere gültige Lösungen. 

Die nun aufgelisteten Nachbarschaftsstrukturen sind im Wesentlichen aus mehreren 
Moves (deren Anzahl wird im Folgenden mit m bezeichnet) zusammengesetzt und 
benötigen daher weit mehr Rechenzeit, um durchsucht zu werden. Um dem entge-
genzuwirken, wurde der durchsuchte Bereich teilweise eingeschränkt beziehungsweise 
mit einer vorgegebenen Anzahl an zufällig erzeugten Lösungen innerhalb der Struktu-
ren gearbeitet. Daher gibt es in solchen Fällen deutliche Unterschiede zwischen dem 
theoretischen und dem praktisch durchsuchten Nachbarschaftsbereich einer Lösung. 

Der Vorteil bei der Kombination von mehreren Moves ist, dass schlechtere Lösungen 
vorerst beibehalten werden können und erst nachdem alle definierten Moves durch-
geführt wurden eine Bewertung erfolgt. Weiters ist auch zu beachten, dass die ein-
zelnen dabei verwendeten Moves in keiner Abhängigkeit zueinander stehen müssen, 
nur¨Uberschneidungennur¨ nur¨Uberschneidungen müssen beachtet werden. Es kann ein Artikel beispielsweise 
nicht zweimal hintereinander aus einer Tour genommen werden. Die Strukturen sind 
also wie folgt definiert: 

DoubleShift Hier wird einfach die Anwendung von ShiftMoves aneinander gereiht 
und somit zweimal verschoben, um eine neue Lösung zu erzeugen. Die Menge 
an möglichen Lösungen hat dabei eine Mächtigkeit in der Größenordnung von 
O(|S| 
4 · s 

2 

max ). Durch die zufällige Generierung von entsprechenden Moves und 
einer fix vorgegebenen Anzahl an Versuchen ergibt sich eine Laufzeitkomple-
xität von O(1). 

MultipleShift¨AhnlichMultipleShift¨ MultipleShift¨Ahnlich wie beim zuvor beschriebenen DoubleShiftMove, ist auch hier 
eine Aneinanderreihung von Elementen aus ShiftMoves Gegenstand der Defini-
tion, allerdings ist die Anzahl an Verschiebungen hier frei definierbar. Dement-
sprechend definiert sich die Größenordnung der möglichen Lösungen hier als 
O((|S| 
2 · s max ) 
m ), die Laufzeit liegt aber auch hier wieder in O(1) (siehe auch 
bei DoubleShift). 

MultipleSwap Hierbei handelt es sich um die Kombination mehrerer SwapMoves, 
welche in ihrer Gesamtheit dann zu mehrfachen Vertauschungen von Artikeln innerhalb einer gesamten Veränderung führen. Ein Lösungsraum der Größe 
O((|S| 
2 · s 

2 

max ) 
m ) Folge 
hat. Hier bewegen wir uns bei der Anzahl der möglichen Alternativen im Be-
reich von O((|S| · 2 
smax ) 
m ). Durch die auch hier wieder gewählte Beschränkung 
auf zufällig erzeugte Kombinationen ergibt sich eine Laufzeit von O(1) (siehe 
auch bei DoubleShift). 

ShiftSplit Dieser Schritt soll die Vorzüge eines SplitMoves mit denen eines Shift-
Moves kombinieren. Dem Verschieben eines Artikels folgt hier unmittelbar die 
Zerlegung einer Zuordnung. Damit ergeben sich O(|S| 
3 · s 

2 

max ) Möglichkeiten, 
die wiederum in O(1) durchsucht werden (siehe auch bei DoubleShift). 

Es ergibt 
sich hier eine Komplexität von O(|S| 
2 · s max ). 

Manche Situationen machen es nötig, eine schnelle Verbesserung einer gegebenen 
Lösung x zu errechnen, zum Beispiel wenn ein einzusammelnder Artikel nicht an 
der zugeteilten Stelle aufzufinden ist, weshalb die standardmäßige Abfolge bei VND 
durch eine Laufzeitbeschränkung limitiert wurde. Es kann dann nach Bedarf eine 
zeitliche Grenze geben, nach deren Erreichen keine neue Nachbarschaft durchsucht 
wird. Der Pseudo-Code in Alg. 6 soll diese Umsetzung andeuten. 

Wie bereits zuvor erwähnt, kann dieser hier vorgestellte VND Ansatz als Reparatur-
und auch als Verbesserungsverfahren verwendet werden. Dies erfordert die Bewer-Algorithmus 6 : VND mit zeitlicher Einschränkung 
Input : eine Startlösung x 
Data : Zähler l, Anzahl l max der zu untersuchenden Nachbarschaften 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head></head><label></label><figDesc>vorgestellten Methode zur dynamischen Reihung vorzunehmen. Im Folgenden gilt es stets eine Permutation λ = (λ 1 , . . . , λ k ) der Nachbarschaftsstrukturen {N 1 , . . . , N k } zu berechnen, wobei der Nachbarschaftsstruktur N i , i = 1, . . . , k, ein Prädikat w i &gt; 0 zugeordnet wird, welches zu Beginn mit einem konstanten Wert W belegt wird. Während nun die Nachbarschaft N λ i (x) einer Lösung x durchsucht wird, wird w λ i in Abhängigkeit von Rechenzeit t λ i und Sucherfolg aktualisiert. Wurde eine verbesserte Lösung gefunden, so wird w λ i halbiert und t λ i α hinzugefügt, wobei α ein Parameter ist, der den Einfluss der Auswertung auf die eigentliche Rechenzeit repräsentiert. Sollte keine bessere Lösung gefunden werden, so wird die Nachbarschaftsstruktur durch Hinzufügen der unverminderten Rechenzeit t λ i zum bestehenden Wert w λ i mit höheren Kosten belastet. Die Permutation λ wird erst neu erzeugt, wenn ein gerade aktualisierter Wert w λ i kleiner als das bisher kleinste, min j=1,...,k w j , oder größer als das bisher größte, max j=1,...,k w j , solcher Prädikate ist. Dann wird anhand der aufsteigenden Werte w i eine neue Reihenfolge bestimmt.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head>und SwapMove sind abhängig von der Anzahl der Touren insgesamt, weshalb vor diesen beiden noch Merge durchsucht wird. Das ermöglicht das Zusam- menführen mancher Touren, falls dies eine Verbesserung bringt. Erst im Anschluss an diese vier Nachbarschaften folgen jene, deren Komplexität größer ist, wobei die Reihenfolge hier auf Basis von kleineren Vortests so gewählt wurde.</head><label></label><figDesc></figDesc><table>. 8.4 ist 
zu sehen wie hoch der Anteil an Verbesserungen gegenüber allen getesteten Schrit-
ten einer Nachbarschaft ist. Wurden also beispielsweise 100 Schritte innerhalb einer 
Nachbarschaft getestet und führten 80 davon zu einer Verbesserung, so würde in der 
Tabelle ein Wert von 80% vermerkt werden. Die ersten vier Nachbarschaften stellen 
grundlegende Operationen zur Lösungsverbesserung dar, weshalb sie auch zu Beginn 
gereiht werden. SplitMove ist an erster Stelle, um aus anfänglich meist großen Touren 
zunächst mehrere kleinere zu erzeugen. Die Laufzeiten der folgenden Nachbarschaf-ten ShiftMove Es folgen also 
noch SwapPosition, SwapPositionMerge, SplitPositionMerge und DoubleShift. Selbst-
verständlich wirkt sich diese Reihenfolge nur direkt bei Verwendung von statischer 
Nachbarschaftsreihenfolge aus. Das Durchsuchen der Nachbarschaften erfolgte außer-
dem unter Verwendung der Strategie Next Improvement (siehe dazu auch Kapitel 5). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>Tabelle 8 .4: Effizienz der Nachbarschaften in Testlauf 1 ohne bzw. mit Artikeln auf alternativen Lagerplätzen -Durchschnittswertë ohne alternative Lagerplätze mit alternativen Lagerplätzen In S1 S2 S3 S4 S5 S1 S2 S3 S4 S5</head><label>8</label><figDesc></figDesc><table>Ar 

ohne Umkehren 

N 1 N 2 N 3 

25 46.9 49.2 49.4 45.6 

25 44.0 46.1 60.8 37.2 

25 100.0 6.9 77.3 67.6 

25 100.0 15.6 71.6 58.2 

25 67.5 38.6 44.3 55.9 

M1 50 100.0 2.3 47.2 96.0 

M2 50 100.0 2.4 54.5 95.6 

M3 50 100.0 2.2 62.3 94.7 

M4 50 100.0 2.1 57.1 94.5 

M5 50 100.0 2.1 57.5 95.0 

L1 100 100.0 2.2 48.7 96.2 

L2 100 100.0 2.9 47.7 97.3 

L3 100 100.0 2.6 54.6 96.3 

L4 100 100.0 2.7 50.8 96.0 

L5 100 100.0 3.1 53.1 96.5 

X1 200 100.0 1.1 74.9 100.0 

X2 200 100.0 0.9 78.4 99.4 

X3 200 100.0 0.9 74.5 99.6 

X4 200 100.0 1.1 76.2 99.4 

X5 200 100.0 1.1 73.0 99.9 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17" validated="false"><head>). Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In) ohne bzw. mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit und ohne Umkehren innerhalb eines</head><label></label><figDesc></figDesc><table>Ganges und bei statischer und 
dynamischer Nachbarschaftsreihenfolge. (N 1 : Split; N 2 : Merge; N 3 : Shift; N 4 : Swap; N 5 : SwapPosition; N 6 : SwapPositionMerge; N 7 : SplitPositionMerge; N 8 : DoubleShift.) 

N 4 N 5 N 6 N 7 N 8 

-50.1 

-48.6 

-39.3 

-51.1 

-42.8 

-28.9 

-34.0 

-40.6 

-34.6 

-35.6 

-55.4 

-55.9 

-58.4 

-62.2 

-63.0 

-94.9 

-91.5 

-97.4 

-90.7 

-91.4 

40.6 33.5 71.7 74.8 12.9 16.7 0.0 58.5 

41.3 36.1 79.9 69.5 10.9 16.6 0.0 62.3 

25 100.0 8.1 77.9 64.0 0.0 0.0 0.0 0.0 100.0 10.5 74.4 63.8 0.0 0.0 0.0 0.8 100.0 7.2 76.9 89.2 0.0 0.0 0.0 35.5 100.0 6.4 75.0 87.4 0.0 0.0 0.0 37.3 

97.8 14.7 76.9 82.1 0.0 0.0 0.0 47.6 

52.2 38.8 80.1 77.2 25.2 19.1 0.0 68.3 

99.6 1.0 87.5 98.1 74.0 72.3 0.0 66.8 

98.8 2.0 71.7 98.7 62.1 33.7 0.0 75.2 
L5 100 100.0 2.2 54.4 96.4 0.0 0.0 0.0 0.0 100.0 1.6 54.4 99.2 0.0 0.0 0.0 0.0 100.0 1.2 67.1 96.9 49.4 52.9 0.0 58.4 100.0 0.1 76.2 98.8 44.5 55.6 0.0 59.1 
X1 200 100.0 1.3 75.4 99.1 0.0 0.0 0.0 0.0 100.0 1.1 84.1 100.0 0.0 0.0 0.0 0.0 100.0 8.8 75.5 98.5 69.3 87.0 0.0 82.8 100.0 1.7 91.1 100.0 65.7 93.0 2.6 90.8 
X2 200 100.0 0.8 76.4 98.9 0.0 0.0 0.0 0.0 100.0 0.7 86.1 100.0 0.0 0.0 0.0 0.0 100.0 8.2 83.3 98.6 72.1 85.5 0.0 86.4 100.0 2.9 96.1 100.0 65.9 91.7 0.0 88.8 
X3 200 100.0 0.8 70.8 99.8 0.0 0.0 0.0 0.0 100.0 0.4 85.7 100.0 0.0 0.0 0.0 0.0 100.0 7.4 66.1 98.6 64.8 84.7 0.0 82.4 100.0 4.3 89.8 100.0 65.2 91.5 0.0 88.7 
X4 200 100.0 1.1 76.8 99.0 0.0 0.0 0.0 0.0 100.0 0.5 85.5 100.0 0.0 0.0 0.0 0.0 100.0 2.4 60.7 98.5 58.1 49.9 0.0 89.5 100.0 1.9 86.6 100.0 61.2 53.3 0.0 92.0 
X5 200 100.0 1.3 74.0 99.8 0.0 0.0 0.0 0.0 100.0 0.5 86.6 100.0 0.0 0.0 0.0 0.0 

99.0 18.9 68.5 98.9 88.0 99.1 0.0 92.1 100.0 24.2 83.4 100.0 80.7 99.6 0.0 95.6 

58 

</table></figure>

			<note place="foot" n="3"> max ), das Durchsuchen selbst ist wieder auf O(1) reduziert (siehe auch bei DoubleShift).</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Fazit</head><p>Inhalt dieser Arbeit war die Vorstellung eines hybriden Verfahrens, welches zum Lösen von Problemen der Tourenplanung im Echtbetrieb eines Ersatzteillagers ein- gesetzt werden kann. Das Grundgerüst bildet dabei eine Variable Nachbarschafts- suche mit integriertem Variable Neighborhood Descent (VND) als lokale Verbesse- rungsstrategie. Zum Lösen von Teilproblemen innerhalb dieses Algorithmus wird ein eigens entwickeltes Dynamisches Programm verwendet, mit dessen Hilfe es möglich ist, konkrete Touren optimal in polynomieller Zeit abhängig von der Anzahl der be- stellten Artikel zu berechnen. Um abschließend eine Zuweisung von Lagerarbeitern zu den im vorhergehenden Schritt berechneten Touren zu berechnen, wird eine zweite VNS verwendet.</p><p>Aus den präsentierten Ergebnissen der Tests lässt sich ableiten, dass der gefunde- ne Ansatz prinzipiell funktionstüchtig ist und schnell akzeptable Lösungen erzeugt. Sind die Arbeiter des Lagers erst einmal damit beschäftigt den ersten ihnen zuge- wiesenen Artikel auszufassen, kann die Gesamtlösung weiter optimiert werden. Dies ist möglich, da zu jedem Zeitpunkt eine gültige Lösung verfügbar ist. Von Bedeu- tung ist dies eventuell auch, wenn eine Erweiterung des Verfahrens zu einem Online- Algorithmus durchgeführt wird. Als solcher muss dieser auf laufend hinzukommende und im Vorhinein nicht bekannte Bestellungen reagieren können. Die Adaptierung von bereits ausgegebenen Touren würde in so einem Algorithmus einen wesentlichen Beitrag zur Flexibilität liefern. Dadurch, dass viele der zu liefernden Artikel erst im Laufe des Tages bestellt werden und zwischen den einzelnen Ausfassungsoperatio- nen der Lagerarbeiter entsprechend viel Berechnungszeit zur Verfügung steht, wird die kontinuierliche Verbesserung einer anfangs schnell generierten Lösung möglich. Weiters scheint eine Aufteilung des Lagers inörtlichinörtlich voneinander getrennte Berei- che, basierend auf der Lage der Verpackungszone, sinnvoll, wodurch die Größe der so entstehenden (Teil-)Instanzen entsprechend gering ist.</p><p>Obwohl die in dieser Arbeit präsentierten Testergebnisse implizieren, dass die Größe der tatsächlichen Instanzen mit bis zu 5000 bestellten Artikeln pro Tag zu kom- plex ist, kann man vermuten, dass nach weiterer¨Uberarbeitungweiterer¨ weiterer¨Uberarbeitung und Erweiterung der Nachbarschaftsstrukturen oder Anpassungen der Durchsuchungsstrategie die Ergeb- nisse weiter verbessert und selbst Instanzen von solcher Größe qualitativ hochwertig gelöst werden können.</p><p>Leider war es im Rahmen dieser Arbeit nicht möglich, die Auswirkungen von unvor- hergesehenen Vorkommnissen (ein Artikel ist nicht in gewünschter Menge verfügbar, Verspätung eines Arbeiters auf seiner Tour, etc.) aussagekräftig zu testen, da auf- grund des erst neu eingeführten Verwaltungssystems die Testdaten nicht dem Echt- betrieb entnommen werden konnten. Daher musste versucht werden, beim Gene- rieren der Testdaten alle bekannten Aspekte und Eigenschaften der Lagerstruktur bestmöglichst zu berücksichtigen.</p><p>Anzumerken ist noch, dass die Methode zum Berechnen von optimalen Kommis- sionierungstouren teilweise auf der Annahme basiert, dass ein Mitarbeiter in einem Gang jederzeit umdrehen kann. Je nach Beschaffenheit des Lagers und der verwen- deten Fahrzeuge kann es durchaus vorkommen, dass eine solche Richtungsänderung nicht, beziehungsweise nur schwer möglich ist. Sollte dies der Fall sein, kann das Dynamische Programm einfach angepasst werden. Die grundlegende Struktur des AnsatzesändertAnsatzesändert sich dadurch nicht.</p><p>Im Rahmen der Tests hat sich gezeigt, dass die gefundenen Lösungen im Vergleich zu ebenfalls berechneten Referenzlösungen von guter Qualität sind und zusätzlich dazu alle Nebenbedingungen erfüllt werden konnten. Aber auch die Laufzeit des Verfahrens und vor allem die raschen Verbesserungen zu Beginn eines Durchlaufs vermitteln einen positiven Eindruck.</p><p>In Hinblick auf eine Beschleunigung des Algorithmus gäbe es die Möglichkeit auf die Berechnung exakter Touren zu verzichten. Natürlich würde man in diesem Fall zwar Geschwindigkeit gewinnen können, müßte aber bei der Lösungsqualität Einbu- ßen hinnehmen. Auch ein nochmaliges¨Uberarbeitennochmaliges¨ nochmaliges¨Uberarbeiten der Nachbarschaftsstrukturen könnte die eine oder andere Verbesserung bringen. Es sollte aber erwähnt werden, dass der präsentierte Ansatz bereits mit stabilem Verhalten und vielversprechender LeistungüberzeugenLeistung¨Leistungüberzeugen kann.</p><p>Als Fazit lässt sich sagen, dass der Einsatz eines computerunterstützten Entschei- dungssystems zur Planung von Kommissionierungstouren durchaus sinnvoll scheint, wenngleich aufgrund der Problemkomplexität auf eine besonders effiziente Imple- mentierung geachtet werden muss. Besonders berücksichtigt werden muss dabei die Tatsache, dass dies ein System sein soll, dass darauf abzielt Menschen in gewisser Hinsicht Befehle zu erteilen, was einerseits soziale Schwierigkeiten mit sich bringt und andererseits aber auch bedeutet, dass Zustände erreicht werden können, die im Vorhinein nur schwer vorherzusehen sind. Das System sollte also nur als Entschei- dungsunterstützung eingesetzt werden und kann die Kontrolle und Betreuung durch einen qualifizierten Lagerarbeiter nicht ersetzen.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Lagerplätzen-Durchschnittswertë uber 20 Testläufe mit 25, 50, 100 und 200 einzusammelnden</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In) ohne bzw. mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit Umkehren innerhalb eines Ganges und bei dynamischer Nachbarschaftsreihenfolge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Artikeln (ar</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>N 1 : Split; N 2 : Merge; N 3 : Shift; N 4 : Swap; N 5 : SwapPosition; N 6 : SwapPositionMerge; N 7 : SplitPositionMerge; N 8 : DoubleShift</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The Traveling Salesman Problem: A Computational Study (Princeton Series in Applied Mathematics)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Applegate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Bixby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Chvatal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Cook</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-01" />
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A tabu search algorithm for the split delivery vehicle routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Archetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Speranza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hertz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="73" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Dynamic Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Bellman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Dover Publications, Incorporated</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Design and control of warehouse order picking: A literature review</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Le-Duc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Roodbergen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">182</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="481" to="501" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Routing orderpickers in a warehouse: a comparison between optimal and heuristic solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Van Der</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Poort</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IIE Transactions</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="469" to="480" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A note on two problems in connexion with graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="269" to="271" />
			<date type="published" when="1959" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Savings by split delivery routing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dror</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Trudeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="141" to="145" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dror</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Trudeau</surname></persName>
		</author>
		<title level="m">Split delivery routing. Naval Research Logistics</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="383" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Generalized network design problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Feremans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Labbe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">148</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The symmetric generalized traveling salesman polytope</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fischetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Salazar Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="113" to="123" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A tutorial on variable neighborhood search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mladenovi´cmladenovi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C D</forename><surname>Gerad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">HEC Montreal and GERAD</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
	<note>Les Cahiers du GERAD</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Variable neighborhood search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mladenovi´cmladenovi´c</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Metaheuristics</title>
		<editor>F. W. Glover and G. A. Kochenberger</editor>
		<imprint>
			<biblScope unit="page" from="145" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A tabu search heuristic for the vehicle routing problem with time windows and split deliveries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Haugland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1947" to="1964" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Variable neighborhood descent with self-adaptive neighborhood-ordering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level Metaheuristics</title>
		<editor>C. Cotta, A. J. Fernandez, and J. E. Gallardo</editor>
		<meeting>the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level Metaheuristics</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A new branch-and-cut algorithm for the capacitated vehicle routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lysgaard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">N</forename><surname>Letchford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Eglese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Programming</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="423" to="445" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A variable neighborhood algorithm-a new metaheuristic for combinatorial optimization. Abstracts of papers presented at Optimization Days</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mladenovi´cmladenovi´c</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page">112</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the capacitated vehicle routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ralphs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kopman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Pulleyblank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">T</forename><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Programming Series</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="issue">B</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Vehicle Routing Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Vigo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Monographs on Discrete Mathematics and Applications</title>
		<meeting><address><addrLine>SIAM, Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Heuristics for vehicle routing problem with time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">Q</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Windows, 6th AI and Math</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
