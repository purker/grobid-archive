<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FROM STATIC TO DYNAMIC PROCESS TYPES</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franz</forename><surname>Puntigam</surname></persName>
							<email>Email: franz@complang.tuwien.ac.at</email>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universität Wien</orgName>
								<address>
									<addrLine>Argentinierstr. 8</addrLine>
									<postCode>1040</postCode>
									<settlement>Vienna</settlement>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">FROM STATIC TO DYNAMIC PROCESS TYPES</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Process types</term>
					<term>synchronization</term>
					<term>type systems</term>
					<term>race-free programs</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Process types-a kind of behavioral types-specify constraints on message acceptance for the purpose of synchronization and to determine object usage and component behavior in object-oriented languages. So far process types have been regarded as a purely static concept for Actor languages incompatible with inherently dynamic programming techniques. We propose solutions of related problems causing the approach to become useable in more conventional dynamic and concurrent languagues. The proposed approach can ensure message acceptability and support local and static checking of race-free programs.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Process types (Puntigam, 1997) represent a behav- ioral counterpart to conventional object types: They support subtyping, genericity, and separate compila- tion as conventional types. Additionally they spec- ify abstractions of object behavior. Abstract behav- ior specifications are especially desirable for software components, and they can be used for synchroniza- tion. Both concurrent and component-based program- ming are quickly becoming mainstream programming practices, and we expect concepts like process types to be important in the near future. However, so far process types are not usable in mainstream languages:</p><p>and show how dynamic type checking can deal with the first issue.</p><p>We introduce the basic static concept of process types for a conventional (Java-like) object model in Section 2. Then, we add support of dynamic synchro- nization in Section 3 and of shared variables with late type checking in Section 4. Local and static checking of race-free programs is rather easy in our setting as discussed in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">STATIC PROCESS TYPES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.</head><p>Their basis are active objects communicating by message passing (Agha et al., 1992). Variables are accessible only within single threads. In main- stream languages like Java, threads communicate through shared (instance) variables; one thread reads values written by another. To support such languages we must extend process types with sup- port of shared variables.</p><p>2. Process types are static. Object state changes must be anticipated at compilation time. We must adapt process types to support dynamic languages like Smalltalk (using dynamic process type checking).</p><p>Figure 1 shows the grammar of TL1 (Token Lan- guage 1) -a simple Java-like language we use as showcase. We differentiate between classes and types without implementations. To create a new object we invoke a creator new in a class. Type annotations fol- low after ":". Token declarations (names following the keyword token), tokens occurring within square brackets in types, and with-clauses together deter- mine the statically specified object behavior.</p><p>The first example shows how tokens allow us to specify constraints on the acceptability of messages:</p><p>Support of dynamic languages turns out to be a good basis for supporting communication through shared variables. Hence, we address mainly the second issue type Buffer is token empty filled put According to the with-clause in put we can invoke put only if we have an empty; this token is removed e | v = e | e | return <ref type="bibr">[e]</ref>opt | fork e e ::= this | v | c | n | e.m( e* ) | null c ∈ class and type names x ∈ token names m ∈ message selectors v ∈ variable names n ∈ natural number literals on invocation, and filled is added on return. For x of type Buffer <ref type="bibr">[empty]</ref> -a buffer with a single token empty -we invoke x.put(..). This invo- cation changes the type of x to Buffer <ref type="bibr">[filled]</ref>. Next we invoke x.get(), then x.put(..), and so on. Static type checking enforces put and get to be invoked in instances of Buffer <ref type="bibr">[empty]</ref> in al- ternation. Type checking is simple because we need only compare available tokens with tokens required by with-clauses and change tokens as specified by with-clauses <ref type="bibr" target="#b20">(Puntigam, 1997)</ref>.</p><p>The type Buffer[empty.8 filled.7] de- notes a buffer with at least 8 filled and 7 empty slots. An instance accepts put and get in all sequences such that the buffer never contains more that 15 or less than zero elements as far as the client knows.</p><p>In the next example we show how to handle tokens in parameter types similarly as in with  <ref type="bibr">[empty.2]</ref> b.put(e) --b:Buffer <ref type="bibr">[empty filled]</ref> b.put(e) --b:Buffer <ref type="bibr">[filled.2]</ref> Let y be of type Buffer <ref type="bibr">[empty.2 filled.2]</ref> and x of type Test. We can invoke x.play(y) since y has the required token filled. This rou- tine gets an element from the buffer, assigns it to the local variable e (declared in the first statement), as- signs a different element to e, and puts this element into the buffer. Within play the buffer is known to have a single filled slot on invocation and on re- turn. For the type of b specified in the formal pa- rameter list it does not matter that the buffer has been empty meanwhile and the buffer contents changed.</p><p>After return from play variable y is still of type Buffer <ref type="bibr">[empty.2 filled.2]</ref>. Invocations of copy change argument types: On return from x.copy(y) variable y will be of type Buffer <ref type="bibr">[empty filled.3]</ref>. Removing tokens to the left of -&gt; on invocation causes the type to be- come Buffer <ref type="bibr">[empty filled]</ref>, and adding the tokens to the right on return causes it to become Buffer <ref type="bibr">[empty filled.3]</ref>.</p><p>Parameter passing does not produce or consume to- kens. Tokens just move from the argument type to the parameter type on invocation and vice versa on return. Only with-clauses can actually add tokens to and re- move them from an object system. This is a basic principle behind the idea of tokens: Each object can produce and consume only its own tokens. A statement 'fork x.copy(y)' spawns a new thread executing x.copy(y). Since the execution continues without waiting for the new threads, in- voked routines cannot return tokens. The type of y changes from Buffer <ref type="bibr">[empty.2 filled.2]</ref> to Buffer[empty filled]. The type of y is split into two types -the new type of y and the type of b. Both threads invoke routines in the same buffer with- out affecting each other concerning type information.</p><p>Assignment resembles parameter passing in the case of spawning threads: We split the type of an assigned value into two types such that one of the split types equals the current static type of the vari- able, and the remaining type becomes the new type of the assigned value. Thereby, tokens move from the value's to the variable's type. If the statically evalu- ated type of v is Buffer <ref type="bibr">[empty.2]</ref> and y is of type Buffer <ref type="bibr">[empty.2 filled.2]</ref>, then v=y causes y's type to become Buffer <ref type="bibr">[filled.2]</ref>.</p><p>Local variables are visible in just a single thread of control. This property is important because it allows us to perform efficient type checking by a single walk through the code although variable types can change with each invocation. Because of explicit formal pa- rameter types we can check each class separately. If variables with tokens in their types were accessible in several threads, then we must consider myriads of possible interleavings causing static type checking to become practically impossible. Instance variables can be shared by several threads. To support instance vari- ables and still keep the efficiency of type checking we require their types to carry no token information. We address this restriction in Section 4. Buffer. An invocation of Buffer1.new() re- turns a new instance with a single token empty. No other token is initially available. Since invocations of put and get consume a token before they issue an- other one, there is always at most one token for this object. No empty buffer slot can be read and no filled one overwritten, and we need no further synchroniza- tion even if several threads access the buffer. The use of tokens greatly simplifies the implementation. However, this solution is inherently static and does not work in more dynamic environments.</p><p>we could use only dynamic tokens which is more common and provides easier handling of buffers. Static and dynamic tokens live in mostly indepen- dent worlds. Nonetheless we have possibilities to move tokens from the static to the dynamic world and vice versa as shown in the following example </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DYNAMIC TOKENS</head><p>The language TL2 (see Figure 2) slightly extends TL1 with dynamic tokens for synchronization. This concept resembles more conventional synchroniza- tion like that in Java. There is no need to anticipate such synchronization at compilation time. We associate each object with a multi-set of tokens (token set for short) to be manipulated dynamically. TL2 differs from TL1 by optional when-clauses in routines and optional initial dynamic tokens (follow- ing -&gt;) in creators. Tokens to the left of -&gt; in when- clauses must be available and are removed before ex- ecuting the body, and tokens to the right are added on return. Different from with-clauses, when-clauses require dynamic tokens to be in the object's token set and change this token set. If required dynamic tokens are not available, then the execution is blocked until they become available. Checks for token availabil- ity occur only at run time. The following variant of the buffer example uses static tokens to avoid buffer overflow and underflow, and dynamic tokens to en- sure mutual exclusion:</p><p>There always exists only a single token t for each instance, no matter how often and from how many threads we invoke beDynamic and beStatic.</p><p>The major advantage of our approach compared to concepts like semaphores and monitors is the higher level of abstraction. It is not so easy to "forget" to release a lock as often occurs with semaphores, and it is not necessary to handle wait queues using wait and notify commands as with monitors. For static tokens we need not execute any specific synchroniza- tion code at all. This synchronization is implicit in the control flow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DYNAMIC TYPING</head><p>class Buffer50 &lt; Buffer is token sync lst: List new(): Buffer50 <ref type="bibr">[empty.50]</ref> -&gt;sync do lst = List.new() put <ref type="bibr">(e:E with empty-&gt;filled)</ref> when sync-&gt;sync do lst.addLast(e) get(with filled-&gt;empty): E when sync-&gt;sync do return lst.getAndDeleteFirst()</p><p>The creator introduces just a single token sync. Both put and get remove this token at the begin and issue a new one on return. Clients need not know about the mutual exclusion of all buffer operations. Of course In TL1 and TL2 we constrained the flexibility of the language to get efficient static type checking: Types of instance variables cannot carry tokens. In this sec- tion we take the position that static type checking is no precondition for the token concept to be useful. We want to increase the language's flexibility (by sup- porting tokens on instance variables) and nonetheless ensure that synchronization conditions expressed in with-clauses are always satisfied. An error shall be reported before invocations if required tokens are not available. <ref type="table">Figure 3</ref> shows the grammar of TL3 that differs form TL2 just by missing type annotations on for- mal parameters and declarations. However, without type annotations there is no explicit information about available tokens. We handle this information dynam- ically. One kind of type annotation is left in TL3: Types of new instances returned by creators must be specified explicitly because tokens in this type to- gether with with-clauses determine which routines can be invoked. Such types are part of behavior spec- ifications. Except of type annotations the following example in TL3 equals Buffer50 and on return those to the right are added to the pool. An error is reported if the pool does not contain all required tokens. This approach is very flexible. Each thread can use all previously issued static tokens no matter which thread caused the tokens to be issued. A disadvantage is a low quality of error messages because there is no information about the control flow causing tokens not to be available. Furthermore, there is a high probabil- ity for program runs not to uncover synchronization problems. Thus, program testing is an issue.</p><p>The following example gives an intuition about the use of static tokens in a dynamic language. An open window is displayed on a screen or shown as icon Some state changes (directly from an icon to closed, etc.) are not supported. Class WManager specifies actions to be performed when users press buttons. Under the assumption that a displayed window has only Button 1 and 2 and an icon only Button 3 the constraints on state changes are obviously satisfied. Since the assumption corresponds to the existence of at most one token for each window we need nothing else to ensure a race-free program. We express the assumption by with-clauses and dynamically ensure them to be satisfied. The variable win must be asso- ciated with a (static) token specifying the window's state. In TL1 and TL2 we cannot express such type information that is implicit in TL3. TL3 deals with dynamic tokens in the same way as TL2. To dynamically handle information about available static tokens we consider two approaches -TL3flex as a simple and flexible approach, and TL3strict as a more restrictive and safer approach.</p><p>TL3flex. In TL3flex we tread static tokens in a sim- ilar way as dynamic tokens: Each objects contains a pool of static tokens. On invocations tokens to the left of -&gt; in with-clauses are taken from the pool, TL3strict. To improve error messages and the prob- ability of detecting problems we dynamically sim- ulate static type checking: Instead of storing static tokens centralized in the object we distribute them among all references to the object. On invocation we check and update only tokens associated with the cor- responding reference. We must find an appropriate distribution of tokens among references. In TL1 and TL2 the programmer had to determine the distribution by giving type annotations. In TL3strict we distribute tokens lazily as needed in the computation.</p><p>Instead of splitting a token set on parameter passing or assignment we associate the two references with pointers to the (unsplit) token set as well as with a new empty token set for each of the two references. Whenever required tokens are not available in the (af- ter assignment or parameter passing empty) token set of a reference we follow the pointers and take the to- kens where we find them. New tokens are stored in the references' own token sets. This way all refer- ences get the tokens they need (if available) and we need not foresee how to split token sets. Repeated application leads to a tree of token sets with pointers from the leaves (= active references) toward the root (= token set returned by creator). We report an error only if tokens required at a leaf cannot be collected from all token sets on the path to the root. On return of invocations we let actual parameters point to token sets of corresponding formal parameters.</p><p>Figure 4 shows an example: Immediately after cre- ating a window there is only one reference n to it (a). The box contains the single token in the correspond- ing token set. When invoking new in WManager us- ing n as actual parameter we construct new token sets for n and for the formal parameter w (b). When the creator assigns w to win we add new token sets for w and win (c). An invocation of setup on win re- moves the token closed and adds displ. On re- turn from the creator we let the token set of n point to that of w (d). Now only win carries the single to- ken. We cannot change the window's state through n. Therefore, TL3strict is safer and less flexible than TL3flex.</p><p>We can build large parts of the structures shown in stract interpretation. Most checks for the availability of tokens can be performed statically. In fact we need dynamic checks of token availability only for tokens associated with instance variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RACE-FREE PROGRAMS</head><p>It is possible to ensure race-free programs just by ana- lyzing the tokens in classes. We use only a single suf- ficient (but not always necessary) criterion: No two preconditions in with-clauses and when-clauses of routines accessing the same variable (where an access is a write) can be satisfied at the same time. To check this criterion we compute upper bounds on the token sets that can be constructed from the tokens of new instances. We analyze each class separately.</p><p>In the following description of the algorithm to de- termine upper bounds of token sets we first consider only static tokens as in TL1. We start with the set of token sets declared in the result types of the ana- lyzed class' creators (one token set per creator). For each with-clause in the class we repeatedly construct new token sets by removing tokens to the left of -&gt; and adding those to the right from/to each token set constructed so far containing all required tokens. If a token set contains all tokens occurring in another to- ken set, then we remove the smaller token set. And if a token set differs from the token set from which it was constructed just by containing more tokens, then we increment the token numbers that differ to the spe- cial value ∞ indicating infinite grow. Because of this treatment the algorithm always reaches a fixed point. The algorithm is accurate in the sense that • the token set produced for an instance of the class is always a subset of a token set returned by the algorithm,</p><p>• if a token set returned by the algorithm does not contain ∞, then there exists a sequence of invoca- tions producing exactly this token set, • and if a token set returned by the algorithm contains ∞, then there exist invocation sequences producing corresponding tokens without upper bounds. In TL2 and TL3 we must consider static and dy- namic tokens together to get most accurate results. Since the static and the dynamic world are clearly separated, static and dynamic tokens must not be in- termixed. We have to clearly mark each token as ei- ther static or dynamic (for example, by an index) and regard differently marked tokens as different. The al- gorithm starts with one token set for each creator con- taining both static and dynamic tokens. A new token set is constructed by simultaneously removing and adding tokens as specified in the with-and when- clause of a routine. The result shows which dynamic tokens can exist together with static tokens. For ex- ample, applied to StaticAndDynamic (see Sec- tion 3) the algorithm returns two token sets, one con- taining only a static token t and the other only a dy- namic token t; in this case no dynamic token can exist at the same time as a static one.</p><p>Once we know the upper bounds it is easy to per- form our check of race-free programs as shown in the following pseudo-code: let U be the upper-bound set of token sets of class c; for each instance variable v of c for each routine r write-accessing v for each routine s (read or write) accessing v let p be the union of the token sets to the left of -&gt; in r and s; if there is a u ∈ U containing all tokens in p then issue a warning about a potential race; otherwise c is race-free As an example we apply this check to Buffer1 (see Section 2). As upper-bound set of token sets S we have {{empty}, {filled}}; there is always at most one token empty or filled. The only in- stance variable s is written in put and read in get. Hence, r ranges just over put, s over put and get, and p over {empty.2} and {empty, filled}. The class is race-free because no token set in S contains two empty or an empty and a filled.</p><p>The set S can become quite large because of com- binatorial explosion. For example, S constructed for Buffer50Dyn contains 51 different token sets -all possibilities of summing up tokens of two names to 50 tokens. Fortunately, a simple change in the algo- rithm to compute upper bounds can reduce the size of S considerably: When computing the fixed point we replace all token numbers larger than 2 · n 2 · i by ∞, where n is the largest total number of tokens to the left of -&gt; in the with-and when-clause of the same routine, and i is the number of different token names in the class. For Buffer50Dyn we have n = 2, i = 3, 2 · n 2 · i = 24, and S contains just a sin- gle token set {sync, empty.∞, filled.∞}. This optimization does not change the output of the race- freeness check: Soundness is not affected because the multi-set of supposedly reachable tokens in a system can just get larger. No token set p (as in the algorithm) can contain more than 2 · n tokens, and a single token of some name can be generated from no more than n·i tokens of another name. Therefore, more than 2 · n 2 · i tokens of one name can be ignored for our purpose. Probably there are more accurate estimations, but we expect this simple one to be sufficient because token numbers to the left of -&gt; are usually small.</p><p>All information needed to check race-free classes is explicit in TL1, TL2, and TL3. We need no infor- mation about formal parameter types and no aliasing information. No global program analysis is necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DISCUSSION, RELATED WORK</head><p>The idea of integrating process types into dynamic languages is new and at a first glance unexpected be- cause such types were developed to move dynamic aspects like synchronization to the static language level whenever possible <ref type="bibr" target="#b18">(Puntigam, 1995;</ref><ref type="bibr" target="#b20">Puntigam, 1997;</ref><ref type="bibr" target="#b22">Puntigam, 2000)</ref>. In some sense the integration of more advanced static concepts into dynamic lan- guages is a consistent further development allowing us to use the appropriate (static or dynamic) concept for each task. Such integration helps us to deepen our understanding of related concepts.</p><p>We usually regard synchronization of concurrent threads as a purely dynamic concept: If there is a dependence between two control flows, then one of the corresponding threads must wait until the other thread has caught up to meet the synchronization point. Since threads usually run asynchronously and at statically unpredictable speed, it is only possible to decide at run time whether a thread must wait at a syn- chronization point. However, these considerations are valid only at a very low level (close to the hardware) point of view. From the programmers' higher level point of view it is quite often not clear whether there exist dependences between threads or not. Using ex- plicit synchronization as with monitors, semaphores, rendezvous communication, etc. programmers must add much more synchronization points than are ac- tually necessary. There are optimization techniques that can statically eliminate up to about 90% (about 60% in average) of all locks from Java programs and thereby considerably improve program performance (von Praun and Gross, 2003). Probably even more synchronization points are actually not necessary. techniques may lead to further increase of unnecessary synchronization because no approach can accurately decide between necessary and unnec- essary locks. Nonetheless, these techniques are very useful because races are an important practical prob- lem in concurrent programming. Process types were developed as abstractions over expressions in process calculi (Puntigam, 1995). These abstractions specify acceptable messages of active objects and allow the acceptability to change over time (thereby specifying synchronization con- straints). Static type checking ensures that only ac- ceptable messages can be sent and enforces all syn- chronization constraints to be satisfied. In this sense type checking in process types has a similar purpose as ensuring race-free programs. However, process types allow us to specify arbitrary constraints on mes- sage acceptability, not just synchronization necessary to avoid races. In fact, the underlying calculi do not support shared data that could suffer from races.</p><p>There is a clear tendency toward more and more complex interface specifications going far beyond simple signatures of available routines <ref type="bibr" target="#b1">(Arbab, 2005;</ref><ref type="bibr" target="#b13">de Alfaro and Henzinger, 2001;</ref><ref type="bibr" target="#b17">Heuzeroth and Reussner, 1999;</ref><ref type="bibr" target="#b19">Jacobsen and Krämer, 1998;</ref><ref type="bibr" target="#b25">Lee and Xiong, 2004;</ref><ref type="bibr" target="#b6">Mezini and Ostermann, 2002;</ref><ref type="bibr" target="#b14">Nierstrasz, 1993;</ref><ref type="bibr" target="#b16">Plasil and Visnovsky, 2002;</ref><ref type="bibr" target="#b33">Yellin and Strom, 1997)</ref>. We consider such interfaces to be partial specifications of object behavior (Liskov and Wing, 1993). They are especially valuable to specify the behavior of software components as far as needed for component composition. Process types are use- ful as partial behavior specifications <ref type="bibr" target="#b24">(Puntigam, 2003;</ref><ref type="bibr" target="#b28">Südholt, 2005)</ref>. We regard behavior specifications as the major reason for using process types.</p><p>Pre-and postconditions in with-clauses allow us to specify a kind of contracts between components <ref type="bibr" target="#b34">(Meyer, 1997;</ref>. Such contracts clearly specify responsibilities of software and help us to move responsibilities from one component to another. For example, we move the responsibility of proper synchronization from the server to the client if we use with-clauses instead of when-clauses.</p><p>Behavioral types and synchronization of concur- rent threads are related topics: Specifications of ob- ject behavior cannot ignore necessary synchroniza- tion if we expect components composed according to their behavioral types to work together in concurrent environments, and constraints on message acceptabil- ity specify a kind of synchronization. There are good reasons for using locking only for local synchronization: Uncoordinated locking easily leads to deadlocks and other undesirable behavior, and it is much easier to coordinate locking within a single unit. The monitor concept supports just lo- cal locking for similar reasons. Furthermore, it is very difficult to deal with globally visible locking at the presence of subtyping and inheritance (Mat- suoka and Yonezawa, 1993). Process types express just synchronization conditions in interfaces, they do not provide for locking. Another approach directly expresses locking conditions in interfaces <ref type="bibr" target="#b7">(Caromel, 1993;</ref>. As experience shows, that ap- proach easily leads to undesirable locking where it would be more appropriate to raise exceptions.</p><p>There are several approaches similar to process types. Nierstrasz <ref type="bibr" target="#b14">(Nierstrasz, 1993</ref>) and Nielson and Nielson (Nielson and Nielson, 1993) define behav- ioral types where subtypes show the same deadlock behavior as supertypes, but message acceptability is not ensured. Many further approaches consider dy- namic changes of message acceptability, but do not guarantee message acceptability in all cases <ref type="bibr" target="#b7">(Caromel, 1993;</ref><ref type="bibr" target="#b11">Colaco et al., 1997;</ref><ref type="bibr" target="#b23">Kobayashi and Yonezawa, 1994;</ref><ref type="bibr" target="#b26">Ravara and Vasconcelos, 1997)</ref>. Well known in the area of typed π-calculi (Milner et al., 1992) is the work of Kobayashi, Pierce and Turner on linearity (Kobayashi et al., 1999) which ensures all sent messages to be acceptable. Work of Najm and Nimour (Najm and Nimour, 1997) is very similar to process types except that in their approach at each time only one user can interact with an ob- ject through an interface (no type splitting). These approaches specify constraints on the acceptability of messages in a rather direct way and do not make use of a token concept. The use of tokens in be- havior specifications gives us high expressiveness and flexibility, allows us to express synchronization in a way similar to well-known concepts like monitors and semaphores, and is easily understandable.</p><p>sible for proper synchronization. Process types use simple token sets as abstractions over object states.</p><p>In this paper we explored how to add process types to rather conventional object-oriented programming languages. As a showcase we developed the lan- guages TL1 to TL3. Static type checking in TL1 en- sures that all conditions in with-clauses are satisfied, this is, all required tokens are available. We can syn- chronize concurrent threads just by waiting for mes- sages. To overcome the restriction, TL2 adds a new dynamic concept of synchronization based on token sets. Neither TL1 nor TL2 can deal with static token sets associated with instance variables because of pos- sible simultaneous accesses by concurrent threads. In TL3 we dispense with static types and apply one of two methods to dynamically ensure the availability of required tokens -a flexible method and one with bet- ter error messages and partial support of static type checking. All variables in TL3 have only dynamic types that can implicitly carry tokens. In the three lan- guages we can ensure race-free programs by check- ing each class separately, without any need of global aliasing information.</p><p>Our approach uses token sets for several related purposes -synchronization of concurrent threads and statically and dynamically checked abstract behavior specifications. It is a major achievement to integrate these concepts because of complicated interrelations. The integration is valuable because it gives software developers much freedom and at the same time clear contracts and type safety.</p><p>Much work on this topic remains to be done. For example, currently our algorithm can issue warnings about potential races even in purely sequential pro- gram parts. Many other approaches to ensure race- free programs put much effort into detecting sequen- tial program parts. By integrating such approaches into our algorithm we expect to considerably improve the accuracy. Most approaches to remove unneces- sary locking from concurrent programs also work on sequential program parts (Choi et al., 1999; von Praun and Gross, 2003; Vivien and Rinard, 2001). We ex- pect a combination of the techniques to improve run time efficiency.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>decl + decl ::= m( par* [with ctok]opt ) [: t]opt def ::= v : c | decl do s + | new( par* ): t do s + par ::= v : c [[ ctok ]]opt ctok ::= tok + -&gt; tok* | -&gt; tok + tok :</head><label></label><figDesc></figDesc><table>P ::= unit* 
unit ::= class c [&lt; c 
+ ]opt is [token x 
+ ]opt def 
+ | 
type c [&lt; c 
+ ]opt is [token x 
+ ]opt := x [.n]opt 
t ::= c [[ tok 
+ ]]opt 
s ::= v : t = </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Figure 1 : Syntax of TL1</head><label>1</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>def ::= v : c | decl [when ctok]opt do s + | new( par* ): t [-&gt; tok + ]opt do s + decl ::= m( v* [with ctok]opt ) def ::= v: | decl [when ctok]opt do s + | new( v* ): t [-&gt; tok + ]opt do s</head><label></label><figDesc></figDesc><table>Explicit result types of creators play a quite impor-
tant role for introducing tokens into the system: 

class Buffer1 &lt; Buffer is 
s:E 
--single buffer slot 
put(e:E with empty-&gt;filled) do s=e 
get(with filled-&gt;empty):E do return s 
new(): Buffer1[empty] do null 

Class Buffer1 inherits empty and filled from 

+ 

Figure 2: Syntax of TL2 (Differences to TL1) 

s ::= v := e | v = e | e | return [e]opt | fork e 

Figure 3: Syntax of TL3 (Differences to TL1-TL2) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>:</head><label></label><figDesc></figDesc><table>class StaticAndDynamic is 
token t 
beDynamic(with t-&gt;) when -&gt;t do null 
beStatic(with -&gt;t) when t-&gt; do null 
new(): StaticAndDynamic[t] do null 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>:</head><label></label><figDesc></figDesc><table>type BufferDyn is 
token empty filled 
put(e with empty-&gt;filled) 
get(with filled-&gt;empty) 

class Buffer50Dyn &lt; BufferDyn is 
token sync 
lst: 
new():Buffer50Dyn[empty.50]-&gt;sync do 
lst = List.new() 
put(e with empty-&gt;filled) 
when sync-&gt;sync do lst.addLast(e) 
get(with filled-&gt;empty) 
when sync-&gt;sync do 
return lst.getAndDeleteFirst() 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>:</head><label></label><figDesc></figDesc><table>type Window is 
token displ icon closed 
setup(with closed-&gt;displ) 
iconify(with displ-&gt;icon) 
display(with icon-&gt;displ) 
close(with displ-&gt;closed) 

class WindowImpl &lt; Window is 
new(): WindowImpl[closed] do ... 
... 

class WManager is 
win: 
new(w):WManager do win=w win.setup() 
onButton1() do win.iconify() 
onButton2() do win.close() 
onButton3() do win.display() 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards a theory of actor computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">A</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Talcott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings CONCUR&apos;92, number 630 in Lecture Notes in Computer Science</title>
		<meeting>CONCUR&apos;92, number 630 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="565" to="579" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Abstract behavior types: A foundation model for components and their composition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Arbab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="3" to="52" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Guava: A dialect of Java without data races</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Bacon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tarafdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A parameterized type system for race-free Java programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2001</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The grand challenge of trusted components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE-25 (International Conference on Software Engineering)</title>
		<meeting><address><addrLine>Portland, Oregon</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Press</publisher>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The programming language Concurrent Pascal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Brinch-Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="199" to="207" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Integrating independent components with on-demand remodularization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA 2002 Conference Proceedings</title>
		<meeting><address><addrLine>Seattle, Washington</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="52" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Toward a method of object-oriented concurrent programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Caromel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="90" to="101" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">A calculus of mobile processes (parts I and II). Information and Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="1" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Escape analysis for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Serrano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">C</forename><surname>Sreedhar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Midkiff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA&apos;99</title>
		<meeting><address><addrLine>Denver, Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A calculus of object bindings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Najm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nimour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings FMOODS&apos;97</title>
		<meeting>FMOODS&apos;97<address><addrLine>Canterbury, United Kingdom</addrLine></address></meeting>
		<imprint>
			<publisher>Chapman &amp; Hall</publisher>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A setconstraint-based analysis of actors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-L</forename><surname>Colaco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pantel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Salle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings FMOODS&apos;97</title>
		<meeting>FMOODS&apos;97<address><addrLine>Canterbury, United Kingdom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">From CML to process algebras</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings CONCUR&apos;93, number 715 in Lecture Notes in Computer Science</title>
		<meeting>CONCUR&apos;93, number 715 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="493" to="508" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Interface automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Alfaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth Annual Symposium on Foundations of Software Engineering (FSE)</title>
		<meeting>the Ninth Annual Symposium on Foundations of Software Engineering (FSE)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="109" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Regular types for active objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings OOPSLA&apos;93</title>
		<meeting>OOPSLA&apos;93</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Types for safe locking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ESOP&apos;99</title>
		<meeting>ESOP&apos;99<address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>The Netherlands</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Behavioral protocols for software components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Plasil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Visnovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1056" to="1076" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Meta-protocol and type system for the dynamic coupling of binary components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Heuzeroth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Reussner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OORASE&apos;99: OOSPLA&apos;99 Workshop on Reflection and Software Engineering</title>
		<meeting><address><addrLine>Bicocca, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Flexible types for a concurrent model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Puntigam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Object-Oriented Programming and Models of Concurrency</title>
		<meeting>the Workshop on Object-Oriented Programming and Models of Concurrency<address><addrLine>Torino</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A design pattern based approach to generating synchronization adaptors from annotated IDL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-A</forename><surname>Jacobsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">J</forename><surname>Krämer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Automated Software Engineering (ASE&apos;98)</title>
		<meeting><address><addrLine>Honolulu, Hawaii, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="63" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Coordination requirements expressed in types for active objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Puntigam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ECOOP&apos;97, number 1241 in Lecture Notes in Computer Science</title>
		<editor>Aksit, M. and Matsuoka, S.</editor>
		<meeting>ECOOP&apos;97, number 1241 in Lecture Notes in Computer Science<address><addrLine>Jyväskylä, Finland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="367" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Linearity and the pi-calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Turner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="914" to="947" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Concurrent Object-Oriented Programming with Process Types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Puntigam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Der Andere Verlag</publisher>
			<pubPlace>Osnabrück, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Type-theoretic foundations for concurrent object-oriented programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="31" to="45" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
	<note>Proceedings OOPSLA&apos;94</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">State information in statically checked interfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Puntigam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eighth International Workshop on Component-Oriented Programming</title>
		<meeting><address><addrLine>Darmstadt, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A behavioral type system and its application in Ptolemy II</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xiong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="210" to="237" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Behavioural types for a calculus of concurrent objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ravara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">T</forename><surname>Vasconcelos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Euro-Par&apos;97, number 1300 in Lecture Notes in Computer Science</title>
		<meeting>Euro-Par&apos;97, number 1300 in Lecture Notes in Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="554" to="561" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Specifications and their use in defining subtypes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings OOPSLA&apos;93</title>
		<meeting>OOPSLA&apos;93</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="16" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A model of components with nonregular protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Composition (SC 2005)</title>
		<meeting><address><addrLine>Edinburgh, Scotland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Analysis of inheritance anomaly in object-oriented concurrent programming languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Yonezawa</surname></persName>
		</author>
		<editor>Agha, G.,</editor>
		<imprint>
			<date type="published" when="1993" />
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
	<note>editor, Research Directions in Concurrent Object-Oriented Programming</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Incrementalized pointer and escape analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Vivien</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;01</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Static conflict analysis for multi-threaded object-oriented programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Von Praun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">R</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;03</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="115" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Systematic concurrent objectoriented programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="56" to="80" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Protocol specifications and component adaptors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Yellin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="292" to="333" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Object-Oriented Software Construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
	<note>second edition edition</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Agha</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Arbab</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Brinch-Hansen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mezini</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Caromel</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Choi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">De</forename><surname>Alfaro</surname></persName>
		</author>
		<idno>15] Nierstrasz 1993 [16] Flanagan 1999</idno>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title/>
		<idno>29] Südholt 2005 [30] Matsuoka 1993</idno>
	</analytic>
	<monogr>
		<title level="j">Liskov</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Von</forename><surname>Praun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Von</forename><surname>Praun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">32</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
