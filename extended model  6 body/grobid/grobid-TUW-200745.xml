<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="de">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ein Lösungsarchiv mit Branch-and-Bound-Erweiterung für das Generalized Minimum Spanning Tree Problem DIPLOMARBEIT zur Erlangung des akademischen Grades Computational Intelligence eingereicht von</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Diplom-Ingenieur</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">im Rahmen des Studiums</orgName>
								<orgName type="department" key="dep2">Fakultät für Informatik</orgName>
								<orgName type="institution" key="instit1">Technischen Universität Wien</orgName>
								<orgName type="institution" key="instit2">Technische Universität Wien</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Gruber</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">im Rahmen des Studiums</orgName>
								<orgName type="department" key="dep2">Fakultät für Informatik</orgName>
								<orgName type="institution" key="instit1">Technischen Universität Wien</orgName>
								<orgName type="institution" key="instit2">Technische Universität Wien</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Ein Lösungsarchiv mit Branch-and-Bound-Erweiterung für das Generalized Minimum Spanning Tree Problem DIPLOMARBEIT zur Erlangung des akademischen Grades Computational Intelligence eingereicht von</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Betreuung Betreuer: Univ.-Prof Dr.Günther Raidl Mitwirkung: Univ.-Ass. Dr. Bin Hu Wien, September 5, 2011 (Unterschrift Verfasser) (Unterschrift Betreuer)</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>A-1040 Wien Karlsplatz 13 Tel. +43-1-58801-0 www.tuwien.ac.at Erklärung Christian Gruber Wachbergsraße 29 3382 Schollach Hiermit erkläre ich, dass ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen der Arbeit-einschließlich Tabellen, Karten und Abbildungen-, die an-deren Werken oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe. ii Kurzfassung In dieser Arbeit wird ein Algorithmus für das Generalized Minimum Spanning Tree-Problem (GMST) entwickelt. Beim GMST-Problem ist ein vollständiger Graph gegeben, bei dem die Knoten in Cluster partitioniert sind. Als Lösung wird ein Spannbaum gesucht, der von jedem Cluster genau einen Knoten beinhaltet und dessen Kosten minimal sind. Dieses Problem ist NP-schwierig. In dieser Arbeit wird eine Heuristik für dieses Problem entwickelt. Bei diesem Verfahren wird ein Evolutionärer Algorithmus (EA) mit zwei ver-schiedenen Lösungsarchiven verwendet. Die Lösungsarchive werden dazu benutzt Lösungen zu speichern, um Duplikate zu erkennen und diese in neue Lösungen umzuwandeln. Das eine Lösungsarchiv beruht auf einer Kodierung, bei der die ausgewählten Knoten der Cluster einer Lösung gespeichert werden, während das andere Archiv auf einer Kodierung beruht, bei der gespeichert wird, welche Cluster in der Lösung verbunden sind. Diese Archive werden in dieser Arbeit durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Dabei wird versucht im Archiv an günstigen Positionen geeignete Bounds zu berechnen, die Auskunft darüber geben, wie gut die Lösungen in diesem Bereich des Archivs höchstens sein können. Wird eine Bound gefunden, die schlechter als die beste gefunden Lösung ist, sind diese Lösungen im weiteren Verlauf des Algorithmus uninteressant und werden nicht mehr berücksichtigt. Das führt dazu, dass mehrere Lösungen von vornherein als schlecht erkannt werden können und somit nur Lösungen verfolgt werden, die auch Verbesserungen bringen können. Zusätzlich zu der Bounding-Strategie wird auch noch ein Nearest Neighbour Ansatz verwendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n näch-sten Nachbarcluster bevorzugt werden. Am Ende der Arbeit wurden Tests durchgeführt, bei denen die Bounding Strate-gie in den unterschiedlichen Archiven verwendet wurde. Diese Tests führten zu dem Ergebnis, dass die Bounding Strategie zu einer Verbesserung gegenüber den Archiven ohne Bounding Strategie führt. Der Vergleich zwischen den Archiven hat ergeben, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen beiden Varianten. iii Abstract In this work, an algorithm for the generalized minimum spanning tree problem (GMST) is developed. Given is a complete graph where the nodes are partitioned into clusters. A solution is a spanning tree which contains exactly one node of each cluster and its costs are minimal. This problem is NP-hard. In this work, a heuristic is developed for this problem. In this method, an evolutionary algorithm (EA) is used with two different solution archives. Using a solution archive, it is possible to store solutions generated by the EA in order to detect duplicates and converts duplicate solutions into new solutions. One solution archive based on an encoding in which the spanned nodes of each cluster in the solution are stored. The other archive is based on an encoding which characterizes the connections between the clusters. These archives are extended by a bounding strategy based on the branch-and-bound technique. They try to calculate appropriate bounds at a convenient positions which give information about how good the solutions in the respective area of the archive can be in the best case. If a bound was found which is worse than the best known solution, the solutions are unattractive in the course of the algorithm and will not be considered. Therefore inferior solutions can be detected at an early stage and only promising solutions that can bring improvements will be pursued. In addition to the bounding strategy a nearest neighbor approach is implemented in which a cluster attached to the spanning tree is preferred among the the n nearest neighboring clusters. Tests were carried out in which the bounding strategy was used in the different variants. These tests led to the conclusion that the bounding strategy leads to an improvement in comparison to the &quot;normal&quot; archives. The comparison between the archives shows that the pop version lead to better results than the gosh version. When both archives are used simultaneously, the results are better than the results of the other two variants.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="de">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kurzfassung</head><p>In dieser Arbeit wird ein Algorithmus für das Generalized Minimum Span- ning Tree-Problem (GMST) entwickelt. Beim GMST-Problem ist ein vollständiger Graph gegeben, bei dem die Knoten in Cluster partitioniert sind. Als Lösung wird ein Spannbaum gesucht, der von jedem Cluster genau einen Knoten beinhaltet und dessen Kosten minimal sind. Dieses Problem ist NP-schwierig. In dieser Arbeit wird eine Heuristik für dieses Problem entwickelt.</p><p>Bei diesem Verfahren wird ein Evolutionärer Algorithmus (EA) mit zwei ver- schiedenen Lösungsarchiven verwendet. Die Lösungsarchive werden dazu benutzt Lösungen zu speichern, um Duplikate zu erkennen und diese in neue Lösungen umzuwandeln. Das eine Lösungsarchiv beruht auf einer Kodierung, bei der die ausgewählten Knoten der Cluster einer Lösung gespeichert werden, während das andere Archiv auf einer Kodierung beruht, bei der gespeichert wird, welche Clus- ter in der Lösung verbunden sind.</p><p>Diese Archive werden in dieser Arbeit durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Dabei wird versucht im Archiv an günstigen Positionen geeignete Bounds zu berechnen, die Auskunft darüber geben, wie gut die Lösungen in diesem Bereich des Archivs höchstens sein können. Wird eine Bound gefunden, die schlechter als die beste gefunden Lösung ist, sind diese Lösungen im weiteren Verlauf des Algorithmus uninteressant und werden nicht mehr berücksichtigt. Das führt dazu, dass mehrere Lösungen von vornherein als schlecht erkannt werden können und somit nur Lösungen verfolgt werden, die auch Verbesserungen bringen können.</p><p>Zusätzlich zu der Bounding-Strategie wird auch noch ein Nearest Neighbour Ansatz verwendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n näch- sten Nachbarcluster bevorzugt werden.</p><p>Am Ende der Arbeit wurden Tests durchgeführt, bei denen die Bounding Strate- gie in den unterschiedlichen Archiven verwendet wurde. Diese Tests führten zu dem Ergebnis, dass die Bounding Strategie zu einer Verbesserung gegenüber den Archiven ohne Bounding Strategie führt. Der Vergleich zwischen den Archiven hat ergeben, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen beiden Varianten.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>iii</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract</head><p>In this work, an algorithm for the generalized minimum spanning tree problem (GMST) is developed. Given is a complete graph where the nodes are partitioned into clusters. A solution is a spanning tree which contains exactly one node of each cluster and its costs are minimal. This problem is NP-hard. In this work, a heuristic is developed for this problem.</p><p>In this method, an evolutionary algorithm (EA) is used with two different solu- tion archives. Using a solution archive, it is possible to store solutions generated by the EA in order to detect duplicates and converts duplicate solutions into new solutions. One solution archive based on an encoding in which the spanned nodes of each cluster in the solution are stored. The other archive is based on an encoding which characterizes the connections between the clusters.</p><p>These archives are extended by a bounding strategy based on the branch-and-bound technique. They try to calculate appropriate bounds at a convenient positions which give information about how good the solutions in the respective area of the archive can be in the best case. If a bound was found which is worse than the best known solution, the solutions are unattractive in the course of the algorithm and will not be considered. Therefore inferior solutions can be detected at an early stage and only promising solutions that can bring improvements will be pursued.</p><p>In addition to the bounding strategy a nearest neighbor approach is implemented in which a cluster attached to the spanning tree is preferred among the the n nearest neighboring clusters.</p><p>Tests were carried out in which the bounding strategy was used in the different variants. These tests led to the conclusion that the bounding strategy leads to an improvement in comparison to the "normal" archives. The comparison between the archives shows that the pop version lead to better results than the gosh version. When both archives are used simultaneously, the results are better than the results of the other two variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>iv</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inhaltsverzeichnis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Erklärung ii</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kurzfassung iii</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract iv</head><p>Inhaltsverzeichnis v <ref type="bibr">Tree-Problem . . . . . . . . . . . . . 1 1.2 Evolutionäre Algorithmen . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.3 Lösungsarchive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.4 Lösungsrepräsentationen . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.4.1 Gosh-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.4.2 Pop-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.5 Branch and Bound . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.6 Bisherige Ansätze . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 1.6.1 EA mit Gosh-Lösungsarchiv . . . . . . . . . . . . . . . . . . . 8 1.6.2 EA mit Pop-Lösungsarchiv . . . . . . . . . . . . . . . . . . . . 10 2 Algorithmus 12 2.1 Boundberechnung im Gosh-Archiv . . . . . . . . . . . . . . . . . . . . 13 2.1.1 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.1.2 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 17 2.2 Boundberechnung im Pop-Archiv . . . . . . . . . . . . . . . . . . . . . 19 2.2.1 Inkrementelle Boundberechnung . . . . . . . . . . . . . . . . . 23 2.2.2 Pop mit Nearest Neighbours Reduktion . . . . . . . . . . . . . 24 2.2.3 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 26 2.2.4 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 27 3 Ergebnisse 30 3.1 Vorgehensweise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 v 3.2 Tests mit fixer Laufzeit . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.2.1 Analyse der Cuts . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.2.2 Gosh-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 3.2.3 Nearest Neighbours . . . . . . . . . . . . . . . . . . . . . . . . 34 3.2.4 Pop-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 3.2.5 Beide Archive . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 3.3 Fixe Anzahl von Generationen . . . . . . . . . . . . . . . . . . . . . . 39 3.4 State of the Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Einleitung</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Generalized Minimum Spanning</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Zusammenfassung 45</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Literaturverzeichnis 47</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>vi</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Einleitung</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Generalized Minimum Spanning Tree-Problem</head><p>Das Generalized Minimum Spanning Tree-Problem (GMST) ist ein kombinatorisches Optimierungsproblem, das eine Verallgemeinerung des Minimum Spanning Tree Prob- lems (MST) ist. Für das MST-Problem ist ein vollständiger Graph G gegeben, bei dem jeder Kante Kosten zugeordnet sind. Eine Lösung des MST-Problems entspricht einer Teilmenge von Kanten, die einen minimalen Spannbaum bilden. Ein minimaler Spannbaum ist ein kreisfreier Teilgraph von G, der mit allen Knoten des Graphen ver- bunden ist und dessen Summe der Kantenkosten minimal ist. Beim GMST-Problem werden zusätzlich noch die Knoten des MST-Problems durch Cluster partitioniert. Die formale Definition des GMST-Problems sieht wie folgt aus <ref type="bibr" target="#b9">[4]</ref>:</p><p>Gegeben ist ein vollständiger gewichteter Graph G = (V, E, c), wobei V die Knoten- menge, E die Kantenmenge und c : E → R + die Kostenfunktion ist. Die Knotenmenge V ist partitioniert in m paarweise disjunkte Cluster V 1 , V 2 , . . . , V m , wobei i=1,...,m V i = V , V i ∩ V j = ∅ ∀i, j = 1, . . . , m, i = j. d i ist die Anzahl der Knoten in Cluster V i , i = 1, . . . , m. Eine Lösung für das GMST-Problem ist ein Graph S = (P, T ), wobei P = {p 1 , p 2 , . . . , p m } ⊆ V enthält genau einen Knoten von jedem Cluster (p i ∈ V i f or all i = 1, . . . , m). T ⊆ E ist ein Spannbaum auf die Knoten in P . Die Kosten von T ergeben sich aus den Kantenkosten, C(T ) = (u,v)∈T c(u, v). Die optimale Lösung ist dann ein Graph S = (P, T ) dessen Kosten C(T ) minimal sind. Ein Beispiel für eine solche Lösung ist in <ref type="figure" target="#fig_0">Abb. 1</ref> zu finden. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">1.2. Evolutionäre Algorithmen</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Evolutionäre Algorithmen</head><p>Ein Evolutionärer Algorithmus (EA) <ref type="bibr" target="#b14">[9]</ref> ist eine Metaheuristik, mit deren Hilfe Opti- mierungsprobleme gelöst werden können. Der EA macht sich die Eigenschaften der natürlichen Evolution zunutze, um ausgehend von einer Anfangspopulation im Laufe der Zeit immer bessere Lösungen zu finden. Dazu werden drei Operationen angewen- det: Selektion, Mutation und Rekombination.</p><p>Der EA arbeitet mit einer Population von Lösungen, wobei die einzelnen Lösungen in kodierter Form gespeichert werden. Diese kodierten Lösungen werden Genotyp genannt. Sie bestehen oft aus einem Bitstring. In dieser Arbeit werden die Lösungen aber als Integer-Vektor gespeichert. Auf die Kodierungsarten wird in Kapitel 1.4 noch genauer eingegangen. Um die Lösungen auswerten zu können ist es notwendig, die Lösungen auch wieder zu dekodieren. Die dekodierten Lösungen werden Phänotypen genannt.</p><p>Der Ablauf des EA ist wie folgt: Zunächst wird für jede Lösung der Population aus den dazugehörigen Phänotypen ein Fitnesswert berechnet. Dieser Fitnesswert ist ein Maß dafür wie gut die Lösung ist. Danach werden durch eine Selektionsfunktion mit Hilfe der Fitnesswerte, zwei Elternlösungen ausgewählt. Aus diesen beiden Elternlö- sungen wird dann durch eine Rekombination eine neue Lösung generiert. Die Idee dabei ist, dass die guten Teile der ausgewählten Lösungen zusammengesetzt werden und dadurch eine neue bessere Lösung entsteht. Danach wird eine Mutation angewen- det, in der die Lösung zufällig an einer bestimmten Stelle verändert wird, um nicht so schnell in einem lokalen Optimum festzustecken. Die Mutation wird aber nur mit einer bestimmten Wahrscheinlichkeit ausgeführt, da sonst der Zufall einen zu großen Einfluss auf die Lösungsfindung hat.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Lösungsarchive</head><p>Wie bei den meisten Metaheuristiken, ist die Definition der einzelnen Methoden all- gemein gehalten. Um den EA auf ein spezifisches Problem anzuwenden, müssen diese Methoden angepasst werden. Es gibt zwei unterschiedliche Arten von EAs:</p><p>• Steady-State-EA: Dabei wird in jedem Generationsschritt nur eine Lösung aus der Population ersetzt. Die restlichen Lösungen bleiben erhalten.</p><p>• generationalen-EA: Hier wird in jedem Generationsschritt die gesamte Population ersetzt.</p><p>In dieser Arbeit, genauso wie in den Arbeiten von Sonnleitner <ref type="bibr" target="#b19">[13]</ref> und Wolf <ref type="bibr" target="#b21">[15]</ref>, auf denen diese Arbeit aufbaut, wurde ein Steady-State-EA verwendet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Lösungsarchive</head><p>Bei einem EA werden neue Lösungen durch Kombination von alten Lösungen, die sich in der Population befinden, erzeugt. Das kann dazu führen, dass eine neu generierte Lö- sung sich schon in der Population befindet bzw. früher schon einmal untersucht wurde. Daraus können sich zwei Probleme ergeben. Zum einen führt es dazu, dass die sel- ben Lösungen mehrmals evaluiert werden und somit unnötig Laufzeit verbraucht wird, da die erneute Evaluierung keinen Sinn macht. Zum anderen kann das mehrfache be- trachten der selben Lösungen zu einem Diversitätsverlust führen, d.h. dass sich die Lösungen in der Population nach kurzer Zeit kaum mehr unterscheiden. Das führt dazu, dass der Lösungsraum nicht mehr so breit durchsucht wird und man so auch schneller in einem lokalen Optimum hängen bleibt.</p><p>Um diesen Problemen entgegen zu wirken, sollte bei jeder generierten Lösung überprüft werden, ob diese in früheren Generationen schon einmal erzeugt worden ist. Dazu rei- cht es aber nicht die Lösungen mit der aktuellen Population zu vergleichen, da hier nur ein kleiner Ausschnitt der bisher untersuchten Lösungen enthalten ist. Daher wird eine Speicherstruktur verwendet, die Lösungsarchiv <ref type="bibr" target="#b18">[12]</ref> genannt wird, in der jede generierte Lösung gespeichert wird und in angemessener Zeit danach gesucht werden kann.</p><p>Das Lösungsarchiv muss drei Eigenschaften erfüllen. Es muss in angemessener Zeit überprüft werden können ob eine Lösung im Archiv vorhanden ist. Außerdem soll aus einer Lösung, die im Archiv enthalten ist, schnell eine neue Lösung generiert werden können, die der alten möglichst ähnlich ist. Zusätzlich sollen die beiden Aufgaben mit einem angemessenen Speicherverbrauch realisiert werden.</p><p>Wie ein Lösungsarchiv in einem EA verwendet wird, ist in <ref type="table" target="#tab_11">Algorithmus 1</ref> dargestellt. Dieser Algorithmus wurde aus <ref type="bibr" target="#b19">[13]</ref> übernommen. Die Frage, welche Datenstruktur sich am besten für ein Lösungsarchiv eignet, wurde in den Arbeiten von Zaubzer <ref type="bibr" target="#b22">[16]</ref> und Šramko <ref type="bibr" target="#b20">[14]</ref> untersucht. Sie haben drei Daten- strukturen miteinander verglichen: Hashtabellen, Binärbäume und Tries. Das Einfü- gen einer Lösung und auch das Prüfen, ob eine Lösung schon enthalten ist, kann mit einer Hashtabelle in O(l) (l entspricht der Länge des Strings) gemacht werden. Das Finden einer neuen Lösung kann hingegen im schlimmsten Fall O(2 l ) Schritte benöti- gen. Beim Binärbaum können alle drei Operationen in O(l * log 2 (n)) durchgeführt werden. Der Nachteil dieser Datenstruktur ist, dass in jedem Knoten eine vollständige Lösung gespeichert wird, was zu einem hohen Speicherverbrauch führt. Bei einem Trie können alle Operationen in O(l) ausgeführt werden. Das führt zu dem Ergebnis, dass ein Trie die geeignetste Datenstruktur, für die vorhin erwähnten benötigten Eigenschaften, ist. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Lösungsrepräsentationen</head><p>In dieser Arbeit wurden zwei verschiedene Lösungsrepräsentationen verwendet: Die Kodierung von Gosh <ref type="bibr" target="#b1">[2]</ref> und die von Pop <ref type="bibr" target="#b17">[11]</ref>. Beide Lösungsrepräsentationen wur- den auch in den Arbeiten von Wolf <ref type="bibr" target="#b21">[15]</ref> und Sonnleitner <ref type="bibr" target="#b19">[13]</ref>, auf denen diese Arbeit aufbaut, verwendet. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">1.4. Lösungsrepräsentationen</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.1">Gosh-Kodierung</head><p>Bei der Gosh-Kodierung wird für jeden Cluster angegeben, welcher Knoten in diesem Cluster ausgewählt wurde. Die kodierte Lösung besteht somit aus einem Vektor P = {p 1 , p 2 , . . . , p m } wobei p i ∈ V für alle i = 1 . . . m. Um aus der kodierten Lösung den Phänotypen und den dazugehörigen Lösungswert zu bekommen, kann dazu ein MST- Algorithmus angewendet werden (z.B. Kruskal).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.2">Pop-Kodierung</head><p>Bei der Pop-Kodierung wird gespeichert, welche Cluster miteinander verbunden sind. Dazu wird ein globaler Graph definiert <ref type="bibr" target="#b12">[7]</ref>: G G = (V G , E G ), wobei V G den Clustern des ursprünglichen Graphen G entsprechen und E G den Kanten zwischen den Clustern, d.h. E G = V G ×V G . Auf diesen Graphen G G kann nun ein Spannbaum S G = (V G , T G ) gebildet werden, wobei T G ⊆ E G .</p><p>Die Pop-Kodierung wird nun mithilfe der Predecessor-Darstellung gemacht. Dazu wird ein Cluster als Wurzelcluster ausgewählt. In dem Spannbaum S G gibt es nun für jeden Cluster einen eindeutigen Pfad zum Wurzelcluster und somit auch einen eindeutigen Vorgänger. Für die Lösungsrepräsentation wird in einem Vektor oder Array für jeden Cluster (außer dem Wurzelcluster) der Vorgänger gespeichert. In <ref type="figure" target="#fig_1">Abb. 2</ref> ist ein Beispiel dazu angegeben.</p><p>Ein Problem dieser Kodierung ist, dass nicht jede Kodierung eine gültige GMST-Lösung darstellt. Dieser Faktor muss bei den EA-Operationen berücksichtigt werden, damit dadurch keine ungültigen Lösungen erstellt werden. Sonnleitner <ref type="bibr" target="#b19">[13]</ref> hat dazu in seiner</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5.">Branch and Bound</head><p>Arbeit einen Repair-Mechanismus entwickelt, mit dem ungültige Lösungen in gültige umgewandelt werden können. Mittels dynamischer Programmierung kann dann aus der kodierten Lösung die optimale Auswahl der Knoten innerhalb der Cluster erfolgen und somit der Phänotyp und den dazugehörigen Lösungswert ermittelt werden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Branch and Bound</head><p>Branch and Bound ist ein Verfahren, mit deren Hilfe man beweisbar optimale Lösungen für kombinatorische Optimierungsprobleme finden kann. Das Verfahren beruht auf der Idee der beschränkten Enumeration und basiert auf dem Divide &amp; Conquer Prinzip. Branch and Bound-Algorithmen bestehen prinzipiell aus zwei Bereichen: Abgrenzung (Bound) und Verzweigung (Branch).</p><p>• Verzweigung (Branch): Durch die Verzweigungsschritte wird das Problem in mehrere Teilprobleme zerlegt, die dann leichter zu lösen sind. Durch wieder- holte Anwendung des Verzweigungsschritts auf die Teilprobleme entsteht ein so- genannter Entscheidungsbaum, der den Lösungsraum widerspiegelt.</p><p>• Mit der Abgrenzung (Bound) wird versucht, Bereiche im Entscheidungsbaum schon früh als schlecht zu erkennen und diese Bereiche somit nicht weiter zu verfolgen, d.h. es werden schlechte Lösungen schon vorzeitig erkannt. Dazu werden zwei Schranken definiert. Eine untere und eine obere Schranke. Bei einem Minimierungsproblem entspricht die obere Schranke einer zulässigen Lö- sung während die untere Schranke dem Weg von der Wurzel des Entscheidungs- baums bis zum aktuellen Teilproblem entspricht. Ist nun die untere Schranke schlechter (größer) als die obere Schranke, wird dieser Teil des Entscheidungs- baums nicht weiter verfolgt. Falls sie kleiner als die obere Schranke ist, erfolgt ein weiterer Verzweigungsschritt. Ist die untere Schranke eine zulässige Lösung und ist sie besser als die aktuelle obere Schranke, so wird die untere Schranke die neue obere Schranke.</p><p>Wie das Branch and Bound Verfahren in dieser Arbeit verwendet wurde, wird in Kapitel 2 näher erläutert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6</head><p>Myung, Lee und Tcha <ref type="bibr" target="#b13">[8]</ref> haben in ihrer Arbeit das erste Mal das GMST-Problem for- mal definiert und haben auch gezeigt dass das Problem NP-schwierig ist.</p><p>Es gibt einige exakte Algorithmen, die aber nur Lösungen für relativ kleine Instanzen liefern. In <ref type="bibr" target="#b13">[8]</ref> wurde ein exakter Algorithmus verwendet mit mehreren Integer Linear Programming-Formulierungen und Branch and Bound Verfahren. Pop hat in <ref type="bibr" target="#b17">[11]</ref> eine etwas effizientere Mixed Integer Linear Programming-Formulierung verwendet. Damit konnten Instanzen mit bis zu 240 Knoten mit 30 Clustern oder 160 Knoten mit 40 Clus- tern optimal gelöst werden. In <ref type="bibr" target="#b0">[1]</ref> wurde ein Branch and Cut Algorithmus verwendet.</p><p>Um größere Instanzen zu lösen, müssen Metaheuristiken verwendet werden. Eine Meta- heuristik ist ein Algorithmus bei dem nicht garantiert werden kann, dass eine optimale Lösung gefunden wird. Man sucht vielmehr eine Lösung, die sich der optimalen Lösung so gut wie möglich annähert. Eine Methaheuristik wird so definiert, dass sie von den Optimierungsproblemen unabhängig sind. Eine auf ein bestimmtes Optimierungspro- blem zugeschnittenes Verfahren wird dann Heuristik genannt.</p><p>Für das GMST-Problem wurden auch einige Metaheuristiken angewandt. Gosh <ref type="bibr" target="#b1">[2]</ref> hat in seiner Arbeit einige Metaheuristik-Ansätze umgesetzt, die auf Tabusuche, Variable Neighborhood Descent und Variable Neighborhood Search basieren. Hu, Leitner und Raidl <ref type="bibr" target="#b2">[3]</ref> haben in ihrer Arbeit einen Variable Neighborhood Search Ansatz entwick- elt, der auf den Ansätzen von Gosh <ref type="bibr" target="#b1">[2]</ref> und Pop <ref type="bibr" target="#b17">[11]</ref> basieren. In <ref type="bibr" target="#b9">[4]</ref> haben sie diesen Ansatz durch eine zusätzliche Nachbarschaft, die Teillösungen mittels Mixed Integer Programming optimiert, erweitert und damit recht gute Ergebnisse erzielt.</p><p>Wolf <ref type="bibr" target="#b21">[15]</ref> und Sonnleitner <ref type="bibr" target="#b19">[13]</ref> haben in ihren Arbeiten einen EA mit Lösungsarchiv verwendet, wobei sie unterschiedliche Lösungsarchive angewendet haben. Wolf hat das Archiv auf Basis der Gosh-Kodierung erzeugt, während Sonnleitner ein Archiv auf Ba- sis der Pop-Kodierung verwendet hat. Außerdem hat Sonnleitner in seiner Arbeit noch eine Variante entwickelt, die beide Archive gleichzeitig verwendet. Wolf und Sonnleitner haben mit ihren Ansätzen beide Verbesserungen im Vergleich zu einem normalen EA erreicht. Wobei Sonnleitner mit der Variante, in der er beide Archive gleichzeitig verwendet, die besten Ergebnisse erzielt hat. Die Ergebnisse dieser beiden Arbeiten wurden dann in der Arbeit <ref type="bibr" target="#b10">[5]</ref> zusammengefasst und veröffentlicht.</p><p>Da in dieser Arbeit die beiden Archive von Wolf und Sonnleitner als Ausgangspunkt genommen wurden und durch ein Bounding Strategie basierend auf einem Branch and Bound Verfahren erweitert wurden, wird in den nächsten beiden Kapiteln auf die beiden Ansätze nochmal genauer eingegangen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6.1">EA mit Gosh-Lösungsarchiv</head><p>Wie vorher schon erwähnt, hat Wolf <ref type="bibr" target="#b21">[15]</ref> in seiner Arbeit das Lösungsarchiv auf Basis der Gosh-Kodierung aufgebaut. Bei der Gosh-Kodierung wird, wie in Kapitel 1.4.1 be- reits beschrieben, eine Lösung durch einen Vektor repräsentiert, bei dem jedes Element einem Cluster entspricht, in dem gespeichert ist, welcher Knoten im Cluster ausgewählt wurde. Das Gosh-Lösungsarchiv ist ein Trie, bei dem jede Ebene einem Cluster V i entspricht. Jeder Trie-Knoten enthält d i Pointer, d.h. für jeden Knoten im Cluster gibt es einen Pointer. Die Pointer können folgende Zustände annehmen:</p><p>• null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde.</p><p>• complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde oder alle Lösungen in den darunter liegenden Subtrie bereits complete sind.</p><p>• normaler Pointer: Pointer zum nächsten Trie-Knoten. <ref type="figure" target="#fig_2">Abb. 3</ref> zeigt ein Beispiel wie ein Lösungsarchiv nach dem Einfügen einer Lösung aussieht. In diesem Beispiel sind zwei Lösungen in dem Archiv bereits enthalten. Die Lösung &lt;321112&gt; wurde dem Archiv neu hinzugefügt. Wie in Kapitel 1.3 beschrieben werden für ein Lösungsarchiv zwei Funktionen benötigt. Eine Konvertierungs-und eine Einfüge-Methode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">1.6. Bisherige Ansätze</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Einfügen einer Lösung</head><p>Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Ist der Pointer null, wird ein neuer Trie-Knoten erzeugt und der Pointer wird auf diesen neuen Knoten gesetzt. Wenn er complete ist, wurde die Lösung früher schon einmal eingefügt und es kann abgebrochen werden. In diesem Fall wird im nächst- en Schritt die Konvertierungs-Methode aufgerufen. Bei einer erfolgreichen Einfüge- Operation, wird im untersten Trie-Knoten der jeweilige Pointer complete gesetzt. Da- nach wird untersucht, ob es entlang der Lösung Teilbäume im Archiv gibt, die voll- ständig untersucht wurden. Dazu wird beginnend in der untersten Ebene geprüft, ob alle Pointer im Trie-Knoten complete sind. Wenn das der Fall ist, kann der Trie-Knoten gelöscht werden und der dazugehörige Pointer im Eltern-Knoten auf complete gesetzt werden. Diese Überprüfung erfolgt, beginnend bei dem untersten Trie-Knoten bis zur Wurzel, für alle Trie-Konten entlang der Lösung.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Konvertieren einer Lösung</head><p>Um aus einer Lösung im Trie eine neue Lösung zu generieren, werden zunächst jene Trie-Knoten ermittelt, die für eine Änderung in Frage kommen. Das sind jene Trie- Knoten entlang der Lösung im Archiv, die nicht in einem als complete markierten Bereich liegen. Danach wird aus diesen Trie-Knoten einer zufällig ausgewählt, indem dann die Änderungen gemacht werden sollen. In diesem Trie-Knoten wird nach einem null-Pointer gesucht. Wenn ein solcher null-Pointer vorhanden ist, wird die Lösung dementsprechend abgeändert. Gibt es keinen, geht man im Trie entlang der Lösung zum nächsten Trie-Knoten und wiederholt die Suche. Ist der Pointer der Lösung aber complete wird ein anderer Pointer ausgewählt und zu diesem Trie-Knoten weiter gegan- gen.</p><p>Die Frage welche Ebene im Archiv welchem Cluster zugeordnet wird, wurde in <ref type="bibr" target="#b21">[15]</ref> näher betrachtet. Wenn die Trie-Knoten der i-ten Ebene im Archiv dem Cluster V i zu- geordnet werden, kommt es zu einem Problem. Es entsteht ein so genanntes Bias im Trie, d.h. die Wahrscheinlichkeit einer Lösungsänderung in einem Cluster ist nicht für alle Cluster gleich groß. Die Knoten in den unteren Ebenen des Archivs haben eine größere Chance verändert zu werden. Um dieses Problem zu umgehen, hat Wolf <ref type="bibr" target="#b21">[15]</ref> in seiner Arbeit eine zufällige Zuteilung der Cluster zu den Trie-Knoten verwendet, d.h. beim Erstellen eines neuen Trie-Knoten, wird diesem zufällig ein Cluster zugeord- net. Das hat zur Folge, dass nicht mehr einige Cluster bei der Veränderung der Lösung bevorzugt werden. Wie vorher schon erwähnt, hat Sonnleitner <ref type="bibr" target="#b19">[13]</ref> in seiner Arbeit das Lösungsarchiv auf Basis der Pop-Kodierung aufgebaut. Bei der Pop-Kodierung werden, wie in Kapitel 1.4.2 bereits beschrieben, die globalen Kanten zwischen den Clustern berücksichtigt. Dabei werden die Vorgänger der Cluster in dem Spannbaum des globalen Graphen, in einem Vektor gespeichert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6.2">EA mit Pop-Lösungsarchiv</head><p>Das Pop-Lösungsarchiv ist ein Trie, der aus m − 1 Ebenen besteht, wobei jede Trie- Ebene für ein Cluster steht. Außer für den Wurzelknoten, da dieser keinen Vorgänger hat. In jedem Trie Knoten gibt es m − 1 Pointer, da ein Cluster in einem Baum nicht sein eigener Vorgänger sein kann. In <ref type="figure" target="#fig_3">Abb. 4</ref> ist ein Beispiel zu sehen, wie eine Lösung in einem Pop-Lösungsarchiv gespeichert wird. In diesem Beispiel sind zwei Lösungen in dem Archiv schon enthalten. Die Lösung &lt;-65611&gt; wurde dem Archiv neu hinzuge- fügt. Da in dieser Kodierung auch Lösungen dargestellt werden können, die keinen Baum darstellen, gibt es in dem Pop-Lösungsarchiv, anders als im Gosh-Archiv, noch einen zusätzlichen Pointerzustand, der eine ungültige Lösung markiert. Die Pointer können daher folgende Zustände annehmen:</p><p>• null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde.</p><p>• complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde oder alle Lösungen in dem darunter liegenden Subtrie bereits complete sind.</p><p>• forbidden (f): Dieser Wert gibt an, dass diese Kodierung zu einer ungültigen Lö- sung führt, d.h. zu keinem Baum.</p><p>• normaler Pointer: Pointer zum nächsten Trie-Knoten.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Einfüge-und Konvertierungs-Funktionen</head><p>Die Einfüge-Funktion läuft im Prinzip genauso ab wie im Gosh-Lösungsarchiv. Der einzige Unterschied ist, dass beim Einfügen von neuen Trie-Knoten in den Trie die ver- botenen Felder im Trie berechnet werden. Dazu werden in dem aktuellen Trie-Knoten alle Cluster mit einem kleineren Index als dem aktuellen Cluster geprüft. Bei diesen Clustern wird nun überprüft, ob diese Cluster den aktuellen Cluster als Vorgänger haben. Ist das der Fall so kann dieser als forbidden markiert werden. Danach wird rekursiv überprüft, ob es bereits hinzugefügte Cluster gibt, dessen Vorgänger der nun verbotene Cluster ist. Diese werden ebenfalls als forbidden markiert.</p><p>Die Konvertierungs-Funktion arbeitet im Prinzip genauso wie im Gosh-Lösungsarchiv. Der Unterschied ist, dass hier bei jeder neu generierten Lösung nochmal geprüft werden muss, ob es einen Zyklus gibt und sie somit keine gültige Lösung ist. Das muss gemacht werden, da in der Einfüge-Funktion nicht alle möglichen Zyklen markiert werden kön- nen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">KAPITEL 2</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus</head><p>Zur Implementierung des Algorithmus wird ein Steady State EA gemeinsam mit einem Gosh-und einem Pop-Lösungsarchiv verwendet. Die beiden Archive wurden in den Arbeiten von Wolf <ref type="bibr" target="#b21">[15]</ref> und Sonnleitner <ref type="bibr" target="#b19">[13]</ref> bereits implementiert. Diese Archive wer- den als Ausgangsposition genommen und durch eine Bounding Strategie basierend auf einem Branch and Bound Verfahren erweitert.</p><p>Wie in Kapitel 1.5 bereits beschrieben, besteht das Branch and Bound Verfahren aus zwei Schritten, dem Verzweigen (Branch) und dem Abgrenzen (Bound). Der Branch- Schritt ergibt sich aus dem Lösungsarchiv. Das Archiv kann im Prinzip als Entschei- dungsbaum angesehen werden. In jedem Trie Knoten wird für einen bestimmten Clus- ter eine Entscheidung getroffen und somit entstehen dadurch die verschiedenen Teil- probleme. Im Gosh-Archiv bestehen die Entscheidungen in den Trie-Knoten aus der Auswahl eines Knoten innerhalb eines Clusters, während im Pop-Archiv entschieden wird, welchen Vorgänger der Cluster in dem Spannbaum hat. Für den Bound-Schritt muss eine untere und eine obere Schranke definiert werden. Als obere Schranke wird immer die bisher beste Lösung, die vom Evolutionären Algorithmus gefunden wurde, genommen. Die untere Schranke wird in den einzelnen Trie-Knoten berechnet. Wie die Berechnung genau erfolgt, wird in den Kapiteln 2.1 und 2.2 erläutert. Falls hier eine untere Schranke gefunden wird, die größer als die beste bisher gefundene Lösung ist, kann dieser Teil des Lösungsarchivs als complete markiert werden. Im weiteren Verlauf des Algorithmus werden diese Lösungen schon als besucht erkannt und somit im EA nicht mehr berücksichtigt.</p><p>Es gibt prinzipiell zwei Möglichkeiten wann eine Bound berechnet wird. Zum einen beim Einfügen der Lösung im Lösungsarchiv und zum anderen beim Konvertieren einer schon eingefügten Lösung zu einer neuen. In dieser Arbeit werden beide Varianten untersucht und auch miteinander kombiniert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Boundberechnung im Gosh-Archiv</head><p>Die Boundberechnung erfolgt immer für einen bestimmten Pointer in einem Trie-Knoten. Bei der Gosh-Kodierung wird, wie in Kapitel 1.4.1 bereits erläutert, für jeden Cluster gespeichert, welcher Knoten in dem Cluster ausgewählt wurde. Soll in einem bestimmt- en Trie-Knoten die Bound berechnet werden, bedeutet das, dass für alle Cluster vom aktuellen Trie-Knoten bis hin zur Wurzel schon eine Auswahl der Knoten in den Clus- tern getroffen wurde. Für alle Cluster in den darunterliegenden Trie-Ebenen wurde noch keine Auswahl getroffen.</p><p>Es ergeben sich also zwei Arten von Clustern. V 1 ist die Menge der Cluster für die bereits eine Knotenauswahl getroffen wurde und V 0 ist die Menge der Cluster für die noch keine Auswahl getroffen wurde.</p><p>Um in einem bestimmten Trie-Knoten eine Bound zu berechnen, wird zunächst der Graph G = (V , E ) definiert, wobei V = V 1 ∪ V 0 . Die Menge E setzt sich aus 3 verschiedenen Arten von Kanten zusammen:</p><p>• E 11 = V 1 × V 1 sind die Kanten zwischen allen Paaren von Clustern, für die bereits eine Auswahl getroffen wurde. Die Kantenkosten ergeben sich aus der Distanz zwischen den ausgewählten Knoten der Cluster.</p><p>• E 10 = V 1 × V 0 sind die Kanten zwischen allen Paaren von Clustern, bei de- nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht wurde. Die Kantenkosten zwischen den Clustern V i ∈ V 1 und V j ∈ V 0 lauten c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist.</p><p>• E 00 = V 0 × V 0 sind die Kanten zwischen allen Paaren von Clustern, für die noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern V i ∈ V 0 und V j ∈ V 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.</p><p>Die Definition der Kantenmenge lautet also E = E 11 ∪ E 10 ∪ E 00 . Die Berechnung der Kantenkosten wird in einem Preprocessing-Schritt durchgeführt, d.h. sie erfolgt einmal zu Beginn des Algorithmus und ist somit für die Laufzeit des Algorithmus nicht mehr relevant. Um die Bound zu berechnen, wird für den Graphen G ein mi- nimaler Spannbaum S = (V , T ) ermittelt, wobei T ⊆ E . Die Bound entspricht dabei den Kosten des Spannbaums T , C(T ) = (u,v)∈T c(u, v). Die Berechnung des Spannbaums erfolgt mit einem Kruskal Algorithmus mit Union-Find. Die Laufzeit dieses Algorithmus wird durch das Sortieren der Kanten bestimmt. Da der Graph G ein vollständiger Graph ist, entspricht die Anzahl der Kanten |E| = m * (m − 1). Dadurch ergibt sich eine Laufzeit von O(m 2 log(m 2 )) für die Berechnung der Bound. In <ref type="figure" target="#fig_4">Abb. 5</ref> wird illustriert wie eine Boundberechnung im Gosh-Lösungsarchiv funk- tioniert. In diesem Beispiel wird im Trie-Knoten des Cluster V 3 die Bound berechnet. An dieser Position wurden die Cluster V 1 , V 2 und V 3 schon in den oberen Ebenen einge- fügt und somit eine Knotenauswahl für die Cluster getroffen. In den darunter liegenden Clustern (V 4 , V 5 und V 6 ) wurde noch keine Auswahl getroffen. Für die Boundberech- nung bedeutet das, dass hier zwischen den Clustern V 1 , V 2 und V 3 als Kantenkosten der Abstand der ausgewählten Knoten genommen wird. Zwischen dem Cluster V 3 und V 4 wird als Kosten der Distanzen zwischen dem ausgewählten Knoten 1 (V 3 ) und dem Knoten 3 (V 4 ) genommen, da dieser die geringste Distanz zum Knoten 1 (V 3 ) hat. Zwi- schen den Clustern V 4 , V 5 und V 6 werden die minimalen Distanzen zwischen den Clus- tern verwendet. D.h. zwischen Cluster V 6 und V 4 wird die Kante zwischen Knoten 2 (V 6 ) und Knoten 1 (V 4 ) genommen und zwischen V 5 und V 4 wird die Kante zwischen Knoten 1 (V 5 ) und Knoten 4 (V 4 ) genommen.</p><p>Ist die berechnete Bound schlechter als die beste bisher gefundene Lösung, kann der Pointer 1 des Clusters V 3 als complete markiert werden. Das kann gemacht werden, da zwischen den Clustern V 4 , V 5 und V 6 immer der minimale Abstand genommen wurde. Wenn nun Knoten in den Clustern ausgewählt werden, bleiben die Kosten des Spannbaums gleich oder werden größer aber sie werden sicher nicht kleiner. Das führt dazu, dass alle Lösungen in diesem Subtrie mindestens so groß sind als die berechnete Bound und somit in diesem Fall auch größer sind als die beste bisher gefundene Lösung.</p><p>Wie vorhin schon erwähnt, ist eine Möglichkeit, wann die Boundberechnung durchge- führt werden kann, die Einfüge-Operation des Lösungsarchivs. Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Bei einer erfolg- reichen Einfüge-Operation werden also m Trie-Knoten durchlaufen. Eine Möglichkeit wäre, in jedem dieser m Trie-Knoten für den jeweiligen Pointer, der dem ausgewählten Knoten dieses Clusters in der Lösung entspricht, die Bound zu berechnen.</p><p>Das führt aber zu einem Problem. Die Berechnung der Bound hat eine Laufzeit von O(m 2 log(m 2 )). Wenn in jedem Trieknoten die Bound berechnet wird, müsste die Bound m-mal ermittelt werden. Das würde zu einer Laufzeit von O(m 3 log(m 2 )) führen, was eine erhebliche Verschlechterung gegenüber der normalen Einfüge-Operation ohne Boundberechnung, mit einer Laufzeit von O(m), wäre.</p><p>Eine Möglichkeit dieses Problem abzuschwächen ist es, die Bound nicht in jedem der m Trie-Knoten zu berechnen, sondern nur in einer bestimmten Auswahl von Knoten. Dazu wurde der Parameter branch_and_bound_prob eingeführt, mit dem angegeben werden kann, mit welcher Wahrscheinlichkeit eine Boundberechnung für einen Trie- Knoten durchgeführt wird. Als ein guter Wert für diesen Parameter hat sich 0, 05 her- ausgestellt. Das bedeutet, es wird für 5% der Trie-Knoten die Bound berechnet. Die Auswahl erfolgt dabei zufällig.</p><p>In <ref type="table" target="#tab_12">Algorithmus 2</ref> ist der Pseudocode für die Einfüge-Operation mit Boundberechnung dargestellt. Diese beruht auf der Einfüge-Operation von Wolf <ref type="bibr" target="#b21">[15]</ref>, nur dass diese durch die Bounding Strategie erweitert wurde. Zunächst wird der Vektor V 0 , in der alle Clus- ter gespeichert sind, die noch nicht in das Archiv eingefügt worden sind, initialisiert. Ausgehend vom Wurzelknoten wird nun immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Der Cluster wird dabei immer aus dem Vektor V 0 entfernt und dem Vektor V 1 hinzugefügt, indem alle Cluster gespeichert sind die schon eingefügt worden sind. Diese beiden Vektoren wer- den dann für die spätere Boundberechnung benötigt. Ist der Pointer gleich null, muss ein neuer Trie-Knoten angelegt werden. Dazu wird zufällig ein Cluster aus dem Vektor V 0 ausgewählt. Danach wird, mithilfe des Parameters branch_and_bound_prob, er- mittelt ob für diesen Trie-Knoten eine Bound berechnet werden soll. Wird eine Bound berechnet und ist sie schlechter als die beste bisher gefundene Lösung, werden alle Trie-Knoten in den darunterliegenden Sub-Trie gelöscht und der Pointer als complete markiert. Anschließend wird die Einfüge-Operation abgebrochen und f alse als Rück- gabewert zurück gegeben.</p><p>Das hat zur Folge, dass die Lösung so behandelt wird als wäre sie schon einmal einge- fügt worden und es wird eine neue Lösung generiert. Wenn das Einfügen erfolgreich war, wird von unten nach oben entlang von sol untersucht, ob bei einem Trie-Knoten alle Pointer complete sind. Ist das der Fall kann dieser gelöscht werden und der Pointer im Eltern Knoten auf complete gesetzt werden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Konvertierungs-Methode</head><p>Die zweite Möglichkeit, wann Boundberechnungen durchgeführt werden können, ist bei der Konvertierungs-Operation des Lösungsarchivs. Bei der Konvertierungs-Operation wird aus einer im Archiv enthaltenen Lösung eine neue Lösung gemacht, die der alten möglichst ähnlich ist. Die Boundberechnung erfolgt nach jeder Änderung, die in der alten Lösung gemacht wird. Ist diese Bound besser als die beste bisher gefundene Lö- sung, wird diese neue Lösung akzeptiert. Ist die Bound aber schlechter, so werden die Änderungen wieder rückgängig gemacht, die Lösung im Archiv als complete markiert und danach weiter nach einer anderen neuen Lösung gesucht.</p><p>In <ref type="table" target="#tab_13">Algorithmus 3</ref> ist dargestellt wie die Konvertierung mit Berücksichtigung der Bounds funktioniert. Zuerst wird ein zufälliger Trie-Knoten der Lösung sol ausgewählt. In Zeile 5 wird dann geprüft, ob es einen null-Pointer in dem ausgewählten Trie-Knoten gibt. Wenn es einen gibt, wird die Lösung geändert und überprüft ob die Bound der neuen Lösung an dieser Position schlechter ist als die beste bisher gefunden Lösung. Wenn sie besser ist, wird sie akzeptiert und es kann abgebrochen werden. Ist sie schlechter, wird die Änderung wieder rückgängig gemacht und der Pointer als complete markiert. Die Suche wird danach fortgesetzt. In den Zeilen 14-21 wird versucht, entlang der Lösung im Archiv eine Ebene nach unten zu gehen. Dieser Schritt erfolgt nur, wenn der Pointer nicht complete ist und die Bound besser ist als die beste Lösung. Wenn entlang von sol nicht nach unten gegangen werden kann, wird in den Zeilen 22-31 versucht einen anderen Pointer, der nicht complete ist, zu finden und an diesen eine Ebene nach unten zu gehen. Hier erfolgt wieder eine Überprüfung der Bound. Der ausgewählte Pointer wird nur weiter verfolgt, wenn die Bound besser ist als die beste Lösung.</p><p>Es kann vorkommen, dass in einem Trie-Knoten kein Pointer vorhanden ist, der zu einer guten Bound führt. Das hat zur Folge, dass alle Pointer als complete markiert werden und somit nicht mehr weiter nach unten gegangen werden kann. Deshalb muss bei jedem Schleifendurchlauf überprüft werden, ob es noch einen Pointer gibt, der nicht complete ist. Wenn nicht, wird dieser Trie-Knoten gelöscht und der zugehörige Pointer im Eltern-Knoten als complete markiert. Danach kann Abgebrochen werden und f alse zurück gegeben werden. Die Konvertierungs-Methode wird danach nochmal aufgerufen. Das kann zu einem Problem führen. Wenn die Ausgangslösung relativ schlecht ist, kann die Suche nach einer neuen Lösung recht lange dauern. Tests haben gezeigt, dass dieser Fall nicht sehr oft auftritt und in den meisten Fällen schon nach wenigen Versuchen eine neue Lösung gefunden werden kann. In wenigen Fällen wurde aber lange nach einer Lösung gesucht. Um dieses Problem zu umgehen, wurde ein Parameter num_conv eingeführt, mit dem die Anzahl der Konvertierungsversuche begrenzt werden kann. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Boundberechnung im Pop-Archiv</head><p>Die Boundberechnung erfolgt, genauso wie beim Gosh-Archiv auch, immer für einen bestimmten Pointer in einem Trie-Knoten. Bei der Pop-Kodierung wird, wie in Kapi- tel 1.4.2 erläutert, für jeden Cluster der Vorgänger des minimalen Spannbaums, der aus den globalen Graphen G G erzeugt wird, gespeichert. Wenn in einem bestimmten Trie- Knoten die Bound berechnet werden soll, bedeutet das, dass für alle Cluster vom ak- tuellen Trie-Knoten bis hin zur Wurzel der Vorgänger bereits ausgewählt wurde. Diese Menge wird als V 1 bezeichnet. Für alle Cluster in den darunterliegenden Trie-Ebenen wurde noch keine Auswahl getroffen. Sie sind noch mit keinem Cluster verbunden. Diese Menge wird als V 0 bezeichnet.</p><p>Dadurch ergibt sich ein Wald G . In <ref type="figure" target="#fig_5">Abb. 6</ref> wird illustriert, wie so ein Wald aussehen kann. Die Abbildung zeigt einen Graph G bei einer Boundberechnung im Trie-Knoten von Cluster 6.</p><p>Die Berechnung der Bound erfolgt nun in mehreren Schritten. In <ref type="table">Algorithmus 4</ref> wird in dem Pseudocode gezeigt, wie die Boundberechnung funktioniert. Zunächst wird ein Vektor data erzeugt, indem am Ende der Funktion die ausgewählten Knoten in den Clustern gespeichert werden. Die Elemente von data werden mit -1 initialisiert. Danach wird mit den Methoden calcClusters und generateList durch dynamische Programmierung für die einzelnen Bäume von G ermittelt, welche Knoten innerhalb  der Cluster ausgewählt werden sollen. Die Knoten werden so ausgewählt, dass die Kosten der daraus entstehenden Lösung minimal sind. Begonnen wird dabei mit dem Baum der vom Wurzelknoten des Lösungsarchivs ausgeht. Danach wird geprüft, ob es noch ein Cluster in C ∈ V 1 gibt, für den noch kein Knoten ausgewählt wurde, d.h. dessen Eintrag in data noch -1 ist. Falls es so einen Cluster gibt, wird für diesen Cluster C der Wurzelknoten des Baums, in dem er sich in G befindet, ermittelt. Von diesem Wurzelknoten wird nun wieder mit calcClusters und generateList eine Auswahl der Knoten für die Cluster des Baums getroffen. Das wird solange wiederholt bis für alle Cluster in V 1 eine Auswahl getroffen wurde.</p><p>Danach wird mit der Methode calculateBound mit einem angepassten Kruskal Algo- rithmus ein minimum Spanning-Tree ermittelt. Ähnlich wie bei der Boundberechnung im Gosh-Archiv, werden im Pop-Archiv auch drei Arten von Kanten zur Berechnung verwendet:</p><p>• E 11 = V 1 × V 1 ist die Menge aller Kanten von G . Die Kantenkosten ergeben sich aus dem Abstand zwischen den ausgewählten Knoten der Cluster.</p><p>• E 10 = V 1 × V 0 sind die Kanten zwischen allen Paaren von Clustern, bei de- nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht wurde. Die Kantenkosten zwischen den Clustern V i ∈ V 1 und V j ∈ V 0 lauten c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>20</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Boundberechnung im Pop-Archiv</head><p>• E 00 = V 0 × V 0 sind die Kanten zwischen allen Paaren von Clustern, für die noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern V i ∈ V 0 und V j ∈ V 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.</p><p>Im Kruskal-Algorithmus werden jetzt zunächst alle Kanten von E 11 eingefügt. Danach werden die restlichen Kanten E 10 ∪ E 00 , wie bei einem normalen Kruskal-Algorithmus, in der Reifenfolge ihrer Kantenkosten hinzugefügt, sodass kein Zyklus entsteht. Wie vorhin bereits erwähnt, wird mit den Methoden calcClusters und generateList die bestmögliche Auswahl von Knoten innerhalb der Cluster getroffen. Zunächst wird mit calcClusters ( <ref type="table" target="#tab_15">Algorithmus 5</ref>) für jeden Knoten der zu untersuchen- den Cluster die Kosten berechnet, die entstehen wenn dieser Knoten ausgewählt wird. Dazu wird calcClusters rekursiv aufgerufen, um, angefangen bei den Clustern in der untersten Ebene, die Kosten für die Knoten zu berechnen.</p><p>Die Kosten werden in der Methode calcClusterweights ( <ref type="table" target="#tab_16">Algorithmus 6</ref>) berechnet. Dazu wird für jeden Knoten p i ∈ C cur des jeweiligen Clusters C cur ∈ V 1 die mini- malen Kosten berechnet, die entstehen würden, wenn dieser ausgewählt werden würde. Das geschieht, indem für alle Nachfolgecluster C suc ∈ V 1 ein Knoten p j ∈ C suc ausgewählt wird. Der Knoten p j wird dabei so gewählt, dass die Summe der Kosten von p j und die Distanz von p i zu p j minimal ist. Die Kosten des Knoten sind also C(p i ) = p j ∈Psuc (C(p j ) + dist(p i , p j )), wobei P suc die Menge der minimalen Knoten der Nachfolgecluster von C cur ist. In der Datenstruktur nodes werden für alle Knoten deren Kosten C(p i ) gespeichert und berechnet und auch alle Knoten der Menge P suc gespeichert. Diese Datenstruktur wird für die spätere Auswahl der Knoten in den Clus- tern benötigt.</p><p>Mit der Methode generateList ( <ref type="table">Algorithmus 7</ref>) werden nun die ausgewählten Knoten innerhalb der Cluster ermittelt. Dazu wird beginnend beim Wurzelcluster der Knoten mit den geringsten Kosten in data gespeichert. Dazu wird die Datenstruktur nodes ver- wendet, in der für jeden Knoten die günstigsten Nachfolgeknoten gespeichert sind.  Die Laufzeit der Boundberechnung wird durch die Berechnung der Kosten für die einzel- nen Knoten bestimmt. Im schlimmsten Fall müssen für alle Knoten des Graphen die Kosten berechnet werden. Deshalb kommt es zu einer Laufzeit von O(n 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>22</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Boundberechnung im Pop-Archiv</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Inkrementelle Boundberechnung</head><p>In <ref type="bibr" target="#b9">[4]</ref> wurde eine Nachbarschaft verwendet, in der die neuen Lösungen inkrementell berechnet wurden. Derselbe Ansatz soll auch in dieser Arbeit verwendet werden. Beim Einfügen einer Lösung wird an verschiedenen Stellen entlang der Lösung im Trie die Bound berechnet. Dabei werden aber für manche Teile der Lösung Berechnungen mehrfach durchgeführt. Dasselbe gilt auch für das Berechnen von Bounds bei der Kon- vertierung von Lösungen.</p><p>Die Idee der inkrementellen Berechnung ist es, dass bei der ersten Berechnung der Bound innerhalb einer Einfüge-bzw. Konvertierungs-Methode die Bound, wie vorhin beschrieben, "normal" berechnet wird. Bei den nächsten Berechnungen der Bound müssen nicht mehr für alle Teile des Baums die Kosten der Knoten berechnet werden. Die Knotenkosten innerhalb eines Clusters V i können sich nur ändern, wenn V i einen neuen Nachfolgecluster im Graphen G bekommt oder die Kosten eines Nachfolgers von V i sich geändert haben.</p><p>Zur Umsetzung der inkrementellen Boundberechnung wurde ein Vektor valid verwen- det, indem für jeden Cluster angegeben wird, ob sich die Knotenkosten in den Cluster ändern. Die einzige Änderung die, gegenüber der "normalen" Boundberechnung zu machen ist, ist in der Methode calcCluster vorzunehmen. In <ref type="table" target="#tab_18">Algorithmus 8</ref> ist zu se- hen, wie die geänderte Methode aussieht. In der Methode wird der Vektor valid dazu verwendet, um festzustellen, ob die Bound berechnet werden soll oder nicht. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Pop mit Nearest Neighbours Reduktion</head><p>In <ref type="bibr" target="#b15">[10]</ref> wurde ein Ansatz verfolgt, indem für die Berechnung eines GTSP sogenannte "candidate lists" verwendet wurden, um den Suchraum einzuschränken. Dabei wurden für jeden Knoten die n nächsten Nachbarn in einer Liste gespeichert und nur diese als mögliche Nachfolger in der Tour betrachtet. Der Ansatz wird auch in dieser Arbeit ver- folgt. Dazu wird die Rekombinations-und Mutations-Methode des EAs entsprechend angepasst. Außerdem wird in der Konvertierungs-Methode des Pop-Lösungsarchivs die Nearest Neighbour Reduktion auch angewendet. Darauf wird später in Kapitel 2.2.4 genauer eingegangen werden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rekombination</head><p>Bei der Rekombinations-Methode wurde die in <ref type="bibr" target="#b19">[13]</ref> verwendete Methode als Grundlage genommen und durch den Nearest Neighbour Ansatz ergänzt. Die Rekombination wird dabei wie folgt durchgeführt: Für jedes Cluster C i wird über- prüft, ob es in den beiden Lösungen den gleichen Vorgänger hat. Wenn das der Fall ist, wird dieser Vorgänger in die neue Lösung übernommen. Hat der Cluster C i in den beiden Lösungen unterschiedliche Vorgänger, gibt es drei Möglichkeiten:</p><p>• Ein Vorgänger C j ist in der Menge der Nearest Neighbours von C i und der andere C k nicht: In diesem Fall wird C j in der neuen Lösung aufgenommen.</p><p>• Beide Vorgänger sind in der Menge der Nearest Neighbours von C i : Hier wird zufällig einer der beiden ausgewählt. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>24</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Boundberechnung im Pop-Archiv</head><p>• Beide Vorgänger sind nicht in der Menge der Nearest Neighbours von C i : Hier wird ebenfalls einer der beiden zufällig ausgewählt.</p><p>Beim Einfügen eines Clusters wird mittels Union Find überprüft, ob durch das Hinzufü- gen des Clusters ein Zyklus entsteht. Ist das der Fall, so wird der Vorgänger der anderen Lösung übernommen, d.h. der Cluster an dieser Stelle eingefügt. Führt das auch zu einem Zyklus, wird dieser Cluster als nicht eingefügt markiert. Diese markierten Clus- ter werden zum Schluss in den Baum hinzugefügt, indem zufällig ein Knoten aus der Nearest Neighbours Liste des jeweiligen Clusters ausgewählt wird und er dann an dieser Stelle eingefügt wird. Ist es nicht möglich den Cluster an einem Nearest Neighbour anzuhängen, ohne einen Zyklus zu erzeugen, wird er zufällig an einer Stelle im Baum angehängt. In <ref type="figure" target="#fig_6">Abb. 7</ref> ist ein Beispiel für eine solche Rekombination illustriert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mutation</head><p>Wie vorhin schon erwähnt, wurde in der Mutation-Methode der Nearest Neighbours Ansatz auch umgesetzt. Dazu wurde die in <ref type="bibr" target="#b19">[13]</ref> verwendete Methode als Grundlage genommen und durch den Nearest Neighbour Ansatz erweitert.</p><p>In der Mutations-Methode wird an einer zufällig ausgewählten Stelle in der Lösung eine Änderung vorgenommen. Der Ablauf der Mutations-Methode ist wie folgt: Zuerst wird zufällig ein Cluster C i in der Lösung ausgewählt, dessen Vorgänger geändert werden soll. Danach werden alle Nearest Neighbours ermittelt, deren direkten oder indirekten Vorgänger nicht C i ist. Im nächsten Schritt wird aus dieser Liste zufällig ein neuer Vorgänger ermittelt und in die neue Lösung gespeichert. Gibt es keinen solchen Nearest Neighbour, werden mit Hilfe eines Tiefensuche-Algorithmus alle möglichen Cluster, deren direkten oder indirekten Vorgänger nicht C i ist, ermittelt. Danach wird aus diesen Clustern einer zufällig ausgewählt und als neuer Vorgänger für C i genommen. In <ref type="table" target="#tab_19">Algo- rithmus 9</ref> wird gezeigt wie die Mutations-Methode funktioniert. cand ←all cluster where mutate is not the direct or indirect predeccessor in sol</p><note type="other">5: end if 6: pred new ← random element from cand 7: sol[mutate] ← pred new</note><p>Genau wie beim Gosh-Archiv wird auch beim Pop-Archiv die Bounding Strategie in die Einfüge-Methode integriert. Bei der Pop-Einfüge-Methode wird, wie auch in Kapi- tel 2.1.1, die Bound nicht in jedem Einfügeschritt berechnet, sondern nur für einen Teil der Trie-Knoten der einzufügenden Lösung. Dazu wird wieder der Parameter branch_and_bound_prob verwendet, der angibt mit welcher Wahrscheinlichkeit die Bound für einen Trie-Knoten berechnet wird. Der Ablauf der Insert-Methode wird in <ref type="table" target="#tab_11">Algorithmus 10</ref> gezeigt. Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Ist ein solcher Pointer noch null, wird ein Trie-Knoten erzeugt und an dieser Stelle in den Trie einge- fügt. Beim ersten Aufruf der Methode calcBoundByDynP rog wird die Bound mithilfe der "normalen" dynamischen Programmierung ermittelt. Für alle weiteren Aufrufe der Methode calcBoundByDynP rog innerhalb derselben Einfügeoperation wird die inkrementelle Boundberechnung, die in Kapitel 2.2.1 beschrieben wird, verwendet. Dazu müssen vorher alle Cluster, für die sich die Kosten der Knoten ändern, markiert werden. Deshalb wird vor der Boundberechnung die Methode invalidate aufgerufen. In dieser Methode werden alle Cluster, vom aktuellen Cluster bis hin zur Wurzel im Spannbaum der Lösung, markiert.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Konvertierungs-Methode</head><p>In der Konvertierungs-Methode des Pop-Archivs wird die Bounding Strategie ebenfalls angewendet. Die Konvertierungs-Methode mit Bounds funktioniert dabei ähnlich wie die des Gosh-Archivs. Bei jeder Änderung der Lösung wird die Bound berechnet und überprüft, ob diese besser als die beste bisher gefundene Lösung ist. Ist das nicht der Fall, wird die Änderung rückgängig gemacht und eine andere Lösung gesucht. Zusät- zlich zur Bounding Strategie wurde die Konvertierungs-Methode durch den Nearest Neighbour Ansatz erweitert.</p><p>In <ref type="table" target="#tab_10">Algorithmus 11</ref> wird der Ablauf der Konvertierungs-Methode gezeigt. Dabei wird zunächst zufällig ein Trie-Knoten curr aus den möglichen Startknoten entlang der Lö- sung ausgewählt. Im nächsten Schritt wird zuerst zufällig aus den Nearest Neighbours von curr ein null-Pointer ausgewählt. Ist keiner vorhanden wird aus den restlichen Pointern zufällig ein null-Pointer ausgewählt. Wurde ein null-Pointer gefunden, kann eine neue Lösung generiert werden. Bei dieser neuen Lösung erfolgt dann eine Bound- überprüfung. Die Boundberechnung wird mit Methode calcBoundByDynP rog durch- geführt. Ist die Bound schlechter als die beste bisher gefundene Lösung, wird die Än- derung der Lösung wieder rückgängig gemacht, der vorher ausgewählte Pointer auf complete gesetzt und mit der Suche fortgesetzt. Ist die Bound nicht schlechter, kann abgebrochen werden. Wurde kein null-Pointer gefunden, wird zunächst versucht, ent- lang der Lösung im Archiv eine Ebene nach unten zu gehen. Hierbei wird wieder eine Boundüberprüfung durchgeführt. Kann entlang der Lösung nicht weiter nach unten gegangen werden, wird im aktuellen Trie-Knoten zufällig ein Pointer aus den Nearest Neighbours von curr ausgewählt, der nicht complete ist. Wird so ein Pointer nicht gefunden, wird aus den restlichen Pointern zufällig ein Pointer ausgewählt, der nicht complete ist. Die Lösung wird dementsprechend geändert und es erfolgt wieder eine Boundüberprüfung.</p><p>Genauso wie bei der Insert-Methode in Kapitel 2.2.3, wird in dieser Methode beim er- sten Aufruf von calcBoundByDynP rog die Bound mittels "normalen" dynamischen Programmierung ermittelt. Bei allen weiteren Boundberechnungen innerhalb dersel- ben Konvertierungsoperation, wird die inkrementelle dynamische Programmierungs- Methode verwendet. Dazu wird vor jeder Boundberechnung die Methode invalidate aufgerufen, die alle Cluster markiert, für die die Kosten neu berechnet werden müssen. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Boundberechnung im Pop-Archiv</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="29">KAPITEL 3</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ergebnisse</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Vorgehensweise</head><p>Die folgenden Tests wurden mit 14 TSPLib-Instanzen 1 durchgeführt. Diese Instanzen sind ursprünglich für das Traveling Salesman Problem erzeugt worden und wurden für das GMST-Problem angepasst. Dazu wurden Cluster der Instanz hinzugefügt und die einzelnen Knoten mittels geografischem Clustering zugeordnet. Die verwendeten In- stanzen bestehen aus 150-442 Knoten und 30-89 Clustern. Im Schnitt hat also jedes Cluster 5 Knoten. Die erweiterten TSPLib-Instanzen wurden auch von Wolf <ref type="bibr" target="#b21">[15]</ref> und Sonnleitner <ref type="bibr" target="#b19">[13]</ref> verwendet, was einen Vergleich der Ergebnisse erleichtert.</p><p>Da der EA ein randomisierter Algorithmus ist, wurden für alle Tests 30 Runs gemacht und für die Auswertung der Mittelwert C avg (T ) = 1/n n i=1 C(T i ) und die Standard- abweichung S = 1/(n − 1) n i=1 (C(T i ) − C avg ) 2 genommen. Die Tests wurden auf dem Cluster des Institut für Computergraphik und Algorithmen der TU-Wien durchge- führt, welcher aus 14 Maschinen mit jeweils zwei QuadCore-CPUs und 24 GB Ar- beitsspeicher besteht.</p><p>Grundsätzlich wurden zwei Arten von Tests durchgeführt. Zum einen sind Testläufe gemacht worden, bei denen der EA nach einer fixen Laufzeit terminiert und zum an- deren Testläufe bei denen nach einer bestimmten Anzahl von Generationen der EA ter- miniert. Letztere wurden unter anderem dazu verwendet, um den Speicherverbrauch des Archivs genauer zu untersuchen.</p><p>Die folgenden Tests wurden mit einer fixen Laufzeit durchgeführt. Die Daten der ver- wendeten Testinstanzen und die Laufzeit werden in <ref type="table" target="#tab_11">Tabelle 1</ref> dargestellt. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Analyse der Cuts</head><p>Zum Beginn der Tests sollte die Frage geklärt werden, ob und wie viele Teilbereiche des Archivs abgeschnitten (als complete markiert) werden können. Außerdem sollte geklärt werden, in welchen Bereichen des Archivs Teilbereiche abgeschnitten werden, also Cuts gemacht werden. Cuts in den oberen Ebenen sind besser, da dadurch mehr Lösungen im vorhinein ausgeschlossen werden können als bei Cuts in den unteren Ebenen. Dieser Test wurde für beide Archive (Pop-und Gosh-Archiv) und für alle 14 Test-Instanzen durchgeführt. Dabei wurde der EA nach einer konstanten Zeit terminiert.</p><p>In <ref type="table" target="#tab_12">Tabelle 2</ref> werden die Ergebnisse dieses Tests dargestellt. In dieser Tabelle wird gezeigt in welchem Teil des Archivs wie viele Cuts durchgeführt wurden. Die Spalte 0 − 25% gibt an, wie viele Cuts in den oberen 25% der Ebenen im Archiv durchgeführt wurden, in der Spalte 25 − 50% für die nächsten 25%, usw. Hier ist zu sehen, dass im Gosh-Archiv in den ersten 50% keine Bound gefunden wird, die schlechter ist als die beste bisher gefunden Lösung, und somit auch kein Cut gemacht werden kann. Da in den ersten 50% keine Cuts gemacht werden, ist es auch nicht nötig die Bound in diesem Bereich zu berechnen, da das nur unnötig Laufzeit verbraucht. De- shalb wurde der Parameter skip_bound eingeführt, mit dem angegeben werden kann, in wie viel Prozent der oberen Ebenen die Bound nicht berechnet werden soll. Aufgrund der erhaltenen Ergebnisse, wurde für die folgenden Tests der Parameter skip_bound für das Gosh-Archiv auf 0, 5 gesetzt. Das bedeutet, dass für die oberen 50% des Archivs wird die Bound nicht berechnet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Tests mit fixer Laufzeit</head><p>Im Pop-Archiv sieht es hingegen anders aus. Hier kommt es auch in den oberen Ebenen zu Cuts. Die Frage, die sich jetzt stellt, ist: Wieso werden im Pop-Archiv in den oberen Ebenen Cuts gemacht aber im Gosh-Archiv nicht? Die Antwort auf die Frage findet sich in den unterschiedlichen Kodierungen der Lösung, die in den Archiven verwendet werden. Bei der Gosh-Kodierung wird für jeden Cluster gespeichert, welcher Knoten in dem Cluster ausgewählt wird. Wird ein Eintrag für einen Cluster geändert, d.h. ein anderer Knoten in dem Cluster ausgewählt, werden die Kosten der Gesamtlösung nicht stark ansteigen, da die Knoten innerhalb eines Clusters relativ nahe zusammen liegen. Bei der Pop-Kodierung wird für jeden Cluster der Vorgänger im Spannbaum des glob-alen Graphen gespeichert. Kommt es hier zu einer Änderung für einen Cluster, können die Kosten der Gesamtlösung stark ansteigen, falls die Cluster im Graphen weit au- seinander liegen. D.h. wenn in den oberen Ebenen schon ein Vorgänger für einen Clus- ter ausgewählt wird, der weiter entfernt liegt, kann das schon zu einer schlechten Bound führen. Die unterschiedliche Kodierung ist auch der Grund, warum im Pop-Archiv mehr Cuts gemacht werden als im Gosh-Archiv.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Gosh-Archiv</head><p>In den nächsten Tests wurde untersucht, wie sich die Bounding-Strategie auf das Gosh- Archiv auswirkt. Dabei wurden drei Varianten betrachtet: Bounding-Strategie innerhalb der Einfüge-Methode, Bounding-Strategie innerhalb der Konvertierungs-Methode und die Variante, in der sie in beiden Methoden gleichzeitig verwendet wird. Dabei wurde der Parameter skip_bound auf 0, 5 gesetzt. Für den Parameter branch_and_bound_prob wurden Tests gemacht, bei denen der Wert dieses Parameters variiert wurde, um fest- zustellen, welcher Wert die besten Ergebnisse liefert. Dabei hat sich heraus gestellt, dass bei branch_and_bound_prob &gt; 0, 1 die Anzahl der erzeugten Generationen zu stark abnimmt und somit schlechtere Ergebnisse geliefert werden. Auf die Ergebnisse der Tests mit den Werten 0, 1 und 0, 05 wurde ein Wilcoxon-Rangsummenstatistik- Test durchgeführt mit dem Resultat, dass beide Werte ähnliche Ergebnisse liefern, die sich statistisch nicht signifikant unterscheiden. Da mit einem Wert von 0, 05 aber in mehr Fällen bessere Resultate erzielt wurden, wurde für die folgenden Tests dieser Wert genommen.</p><p>Die Ergebnisse dieses Tests sind in <ref type="table" target="#tab_13">Tabelle 3</ref> zu sehen. In der Tabelle werden in der Spalte T rie die Ergebnisse des "normalen" Gosh-Archivs ohne Bounding-Strategie, unter T rie+insert−Bound die Variante mit Bounding-Strategie innerhalb der Einfüge- Methode, im Bereich T rie + convert − Bound die Bounding-Strategie innerhalb der Konvertierungs-Methode und unter T rie + ins&amp;conv − Bound bei der die Bounding- Strategie in beiden Methoden gleichzeitig verwendet wird dargestellt. C avg entspricht dem durchschnittlichen Lösungswert über alle Runs, darunter in Klammern steht die Standardabweichung und Gen ist die durchschnittliche Anzahl der erzeugten Genera- tionen.</p><p>In den Ergebnissen ist zu sehen, dass alle drei Bounding Varianten gegenüber des "nor- malen" Archivs bessere Ergebnisse liefern. Die Variante, in der die Bounding Strate- gie in beiden Methoden verwendet wurde, liefert jedoch gegenüber der beiden anderen Varianten schlechtere Ergebnisse. Dieses Resultat ist auf die geringere Anzahl von erzeugten Generationen zurück zu führen. In einigen Instanzen wurden nur halb so viele Generationen erzeugt als in den anderen Varianten. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Nearest Neighbours</head><p>Als nächstes wurde versucht herauszufinden, wie sich der Nearest-Neighbours-Ansatz, der in Kapitel 2.2.2 erläutert wurde, auf den Evolutionären Algorithmus auswirkt. Bei diesen Tests wurde der EA ohne Archiv verwendet. Dabei wurde der EA einmal mit und einmal ohne dem Nearest-Neighbours-Ansatz verwendet und miteinander verglichen. Bei diesem Test wurde der Parameter num_nearest_neighbour, der angibt, wie viele Nachbarn in der Nearest-Neighbour-List eines Clusters enthalten sind, auf 5 gesetzt. D.h. es werden für jeden Cluster die 5 nächsten Nachbarn bevorzugt. In <ref type="table">Tabelle 4</ref> sind die Ergebnisse dieses Tests dargestellt. Hier ist zu sehen, dass der EA mit dem Nearest- Neighbours-Ansatz für alle Instanzen eine Verbesserung liefert. Für die nachfolgenden Tests wurde daher der Nearest-Neighbours-Ansatz auch verwendet.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">Pop-Archiv</head><p>In diesem Kapitel wurde der Vergleich der verschiedenen Bounding-Strategien auch für das Pop-Archiv durchgeführt. In Kapitel 3.2.1 wurde in dem Test herausgefunden, dass Cuts in allen Ebenen des Tries vorkommen können. Deshalb wurde für den Vergleich der Bounding-Strategien der Parameter skip_bound hier nicht verwendet, d.h. die Bound wurde in jeder Ebene berechnet. Für den Parameter branch_and_bound_prob wurden für das Pop-Archiv, genau wie im Kapitel 3.2.2 für das Gosh-Archiv, Tests mit unterschiedlichen Werten für diesen Parameter gemacht. Mit dem Resultat, dass auch hier der Wert 0, 05 die besseren Ergebnisse liefert. <ref type="table" target="#tab_15">Tabelle 5</ref> zeigt die Ergebnisse für diesen Test. Hier ist zu sehen, dass die Varianten mit den Bounding-Strategien meistens besser sind als die Variante mit "normalem" Archiv. Außer für die Instanzen kroa150, pr226, pr264 und f l417 für die auch mit dem Archiv ohne Bounding-Strategie das Optimum erreicht wurde.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.5">Beide Archive</head><p>In <ref type="bibr" target="#b19">[13]</ref> wurde eine Variante getestet, bei der beide Archive gleichzeitig verwendet wur- den. In dieser Arbeit soll auch getestet werden, wie sich die Bounding-Strategie in den verschiedenen Varianten auswirkt, wenn beide Archive gleichzeitig verwendet werden. Der Parameter skip_bound wird auf 0, 5 gesetzt. Dieser hat aber nur Auswirkungen auf das Gosh-Archiv, d.h. im Pop-Archiv werden in allen Ebenen Bounds berechnet. Der Parameter branch_and_bound_prob wurde, genau wie bei den vorherigen beiden Tests, auf 0, 05 gesetzt.</p><p>In <ref type="table" target="#tab_16">Tabelle 6</ref> sind die Ergebnisse dieses Tests zu sehen. Dabei wurden wieder 4 Varianten miteinander verglichen: "normalen" Gosh und Pop Archive ohne Bounding-Strategie (T rie), die Variante mit Bounding-Strategie innerhalb der Einfüge-Methode (T rie + insert−Bound), die Bounding-Strategie innerhalb der Konvertierungs-Methode (T rie+ convert−Bound) und die Bounding-Strategie in beiden Methoden gleichzeitig (T rie+ ins&amp;conv − Bound). Hier ist zu sehen, dass bessere Ergebnisse bei den Varianten mit Bounding-Strategie erzielt werden, außer bei den Instanzen bei denen das Optimum schon mit den "normalen" Archiven erreicht wird. Außerdem ist zu sehen, dass in der Variante, in der in beiden Methoden die Bounding-Strategie verwendet wird, schlechtere Ergebnisse erreicht werden, als in den Varianten, wo die Bounding-Strategie nur bei der Einfüge-oder Konvertierungs-Methode verwendet wird. Das ist auf die geringere An- zahl von Generationen zurück zu führen, die oft nur halb so groß ist als bei den beiden anderen Varianten. In den bisherigen Tests ist zu sehen, dass durch die Verwendung der Bounding-Strategie die Anzahl der erzeugten Generationen geringer sind. Dadurch ist ein Vergleich des Speicherverbrauchs der beiden Varianten nicht möglich, da bei dem Archiv ohne Bound- ing mehr Lösungen in das Archiv eingefügt werden als beim Archiv mit Bounding. Um jetzt den Speicherverbrauch der unterschiedlichen Varianten miteinander zu ver- gleichen, wird als Abbruchbedingung für den EA eine fixe Anzahl von Generationen genommen. So werden bei allen Varianten gleich viele Generationen erzeugt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>37</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Tests mit fixer Laufzeit</head><p>Für diese Tests wurde die Abbruchbedingung des EAs auf 10.000 Generationen gesetzt. In den <ref type="table" target="#tab_18">Tabellen 7 und 8</ref> sind die Ergebnisse für diese Tests zu sehen. In der <ref type="table">Tabelle  7</ref> wurde das Gosh-Archiv untersucht, während in <ref type="table" target="#tab_18">Tabelle 8</ref> die Ergebnisse für das Pop-Archiv zu sehen sind. Es wurden jeweils das "normale" Archiv ohne Bounding- Strategie, das mit Bounding-Strategie in der Einfüge-Methode und das mit Bounding- Strategie in der Konvertierungs-Methode miteinander verglichen. Die Spalte C avg ent- spricht dabei wieder dem Durchschnitt der Lösungswerte über alle Runs, unter diesem Wert steht in Klammern die Standardabweichung, Zeit entspricht der durchschnittlich benötigten Zeit und M em den benötigten Speicher für das Archiv.</p><p>In diesen Ergebnissen ist zu sehen, dass die Varianten mit Bound immer mehr Spei- cher benötigen als die ohne Bound. Das kommt zunächst überraschend, da man zuerst annehmen würde, dass durch die Bounding-Strategie auch weniger Speicher verbraucht würde. Der Grund für den erhöhten Speicherverbrauch bei der Einfüge-Methode ist in <ref type="figure">Abb. 8</ref> zu sehen. In diesem Beispiel wird zunächst versucht, im Gosh-Archiv die Lösung &lt;321112&gt; (in der Grafik rot dargestellt) einzufügen. In Knoten V 5 wird eine Bound festgestellt, die schlechter ist als die beste bisher gefundene Lösung, und somit der Pointer 1 als complete markiert. Danach wird die Einfügeoperation abgebrochen und f alse zurück geben. Für den EA sieht es daher so aus, als wäre die Lösung im Archiv schon enthalten. Im nächsten Schritt wird mit der Konvertierungsmethode eine neue Lösung &lt;341112&gt; erzeugt. Diese wird nun erfolgreich in das Archiv eingefügt. Würde die Bounding-Strategie nicht verwendet werden, wäre die Lösung &lt;321112&gt; beim ersten Mal eingefügt worden. Da die Bounding-Strategie verwendet wurde, ist nun die Lösung &lt;321112&gt; bis zum Knoten V 5 und die Lösung &lt;341112&gt; ganz eingefügt worden. D.h. beim Erzeugen einer neuen Lösung für die neue Generation wurden die drei Knoten V 3, V 4 und V 5 des ersten Einfügeversuchs zusätzlich eingefügt. Deshalb kommt es bei der Verwendung der Bounding-Strategie zu einem höheren Speicherver- brauch.</p><p>Um zu belegen, dass das der Grund für den erhöhten Speicherverbrauch ist, wurden weitere Tests durchgeführt. Bei diesen Tests wurden Lösungen, bei denen eine Bound gefunden wurde, die schlechter ist als die beste bisher gefundene Lösung, trotzdem in der neuen Generation akzeptiert. D.h. wenn beim Einfügen einer Lösung eine schlechte Bound gefunden wird, wird der jeweilige Pointer als complete markiert und dann true zurück gegeben. Das hat zur Folge, dass der EA die Lösung als neu akzeptiert.</p><p>Die Ergebnisse dieser Variante werden in <ref type="table" target="#tab_19">Tabelle 9</ref> gezeigt. Hier ist zu sehen, dass für die meisten Instanzen bei dieser Variante weniger Speicher für das Archiv gebraucht wurde.</p><p>Bei der Bounding-Strategie in der Konvertierungs-Methode ist der Grund für den er- höhten Speicherverbrauch ähnlich wie bei der Einfüge-Methode. Wenn bei der Konver- tierungs-Methode in einem zufällig ausgewählten Startknoten der Lösung keine null- Pointer gefunden werden, wird versucht, entlang der Lösung im Trie eine Ebene nach unten zu gehen. Wenn das nicht möglich ist, wird versucht bei einem anderen nicht complete-Pointer eine Ebene nach unten zu gehen. Wenn jetzt aufgrund von Bounds, die schlechter als die beste bisher gefunden Lösung sind, in diesem neuen Knoten alle Pointer complete werden, wird die Konvertierung abgebrochen und an einer anderen Stelle nochmal versucht. Da der Pointer der Lösung in dem Startknoten in diesem Fall auf complete gesetzt wurde, wird beim nächsten Konvertierungsversuch der Startknoten aus den darüber liegenden Ebenen ausgewählt. D.h. bei der Verwendung der Bounding- Strategie ist die Wahrscheinlichkeit höher, dass in den oberen Ebenen die Konvertierung durchgeführt wird. Das führt dazu, dass beim anschließenden Einfügen einer Lösung der neu einzufügende Subtrie größer ist. Deshalb werden mehr Trie-Knoten mit der Bounding-Strategie erzeugt und somit kommt es auch zu einem erhöhten Speicherver- brauch.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">State of the Art</head><p>In <ref type="table" target="#tab_11">Tabelle 10</ref> wurden die Ergebnisse dieser Arbeit mit den Ergebnissen anderer Arbeiten verglichen, um zu sehen, wie der EA Ansatz mit Lösungsarchiv und Bounding-Strategie im Vergleich abschneidet. Die Ergebnisse wurden aus der Arbeit <ref type="bibr" target="#b10">[5]</ref> übernommen. In <ref type="table" target="#tab_11">Tabelle 10</ref> werden vier Verfahren miteinander verglichen: ein Tabu Search Verfahren (TS) von <ref type="bibr" target="#b1">[2]</ref>, ein Variable Neighborhood Search Verfahren (VNS) von <ref type="bibr" target="#b9">[4]</ref>, ein Ver- fahren basierend auf Dynamic Candidates Sets (DCS) von <ref type="bibr" target="#b11">[6]</ref> und einem EA mit einem Archiv in Kombination mit einer Bounding-Strategie. Bei dem Verfahren mit Boundig- Strategie wurden die Ergebnisse genommen, bei denen beide Archive kombiniert wur- den und die Bound nur in der Konvertierungs-Methode verwendet wurde. Hier ist zu sehen, dass das Verfahren mit Bounding-Strategie durchaus mit den anderen Verfahren mithalten kann und in einigen Instanzen auch bessere Ergebnisse liefert. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="44">KAPITEL 4</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Zusammenfassung</head><p>In dieser Arbeit wurde ein Evolutionärer Algorithmus mit zwei verschiedenen Varianten von Lösungsarchiven (Gosh-Archiv und Pop-Archiv) durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Zusätzlich wurde auch ein Nearest Neighbour Ansatz angewendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n nächsten Nachbarcluster bevorzugt werden.</p><p>Bei der Bounding-Strategie werden in den einzelnen Trie-Knoten geeignete Bounds berechnet, die eine Aussage darüber machen können, wie gut die Lösungen im darunter liegenden Subtrie bestenfalls sein können. Mit diesen Bounds können viele Lösungen von vornherein als schlecht markiert werden. Die Boundberechnung erfolgt in 3 ver- schiedenen Varianten: Boundberechnung in der Einfüge-Methode des Archivs, in der Konvertierungs-Methode und in beiden Methoden gleichzeitig.</p><p>Diese Varianten wurden in den beiden Archiven getestet und verglichen. Im Gosh- Archiv haben die Bounding Varianten in allen Instanzen bessere Ergebnisse erzielt, als bei der "normalen" Variante. Die Variante, in der in beiden Methoden die Bounding- Strategie verwendet wird, hat jedoch schlechtere Ergebnisse gebracht als in den anderen beiden Bounding-Varianten. Das ist auf die geringere Anzahl von erzeugten Gener- ationen zurück zu führen. Im Pop-Archiv waren die Ergebnisse der Bounding Vari- anten ebenfalls besser als die der "normalen" Variante. Bei der Variante, in der beide Archive gemeinsam verwendet wurden, haben die Bounding-Varianten ebenfalls eine Verbesserung erzielt. Beim Vergleich zwischen den Archiven kann man sagen, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen bei- den Varianten.</p><p>Die Tests haben ebenfalls ergeben, dass der Speicherverbrauch der Archive durch die Verwendung der Bounds erhöht wird. Das ist darauf zurück zu führen, dass wenn beim Einfügen einer Lösung eine Bound gefunden wird, die schlechter ist als die beste bisher gefundene Lösung, diese Lösung teilweise eingefügt wird und zusätzlich noch eine neue konvertierte Lösung.</p><p>Die Ergebnisse dieser Arbeit wurden auch mit den Ergebnissen anderer Arbeiten ver- glichen, um zu sehen wie das Verfahren im Vergleich zu anderen abschneidet. Dabei hat sich gezeigt dass die Bounding-Strategie mit anderen Verfahren mithalten kann und in einigen Instanzen bessere Ergebnisse liefert.</p><p>Die Ergebnisse dieser Arbeit haben gezeigt, dass die Bounding-Strategie eine Verbesserung gegenüber dem Lösungsarchiv ohne Bounding-Strategie bringt. Ein wichtiger Punkt bei der Bounding-Strategie ist es, eine effiziente Methode für die Boundberechung zu finden, damit die Anzahl der erzeugten Generationen nicht zu stark abnimmt. Für an- dere Problemstellungen könnte dieses Verfahren auch Verbesserungen bringen, wenn eine effiziente Methode zur Boundberechnung gefunden wird.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Abb. 1 :</head><label>1</label><figDesc>Abb. 1: Lösung für ein GMST-Problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Abb. 2 :</head><label>2</label><figDesc>Abb. 2: Pop-Kodierung mit V 1 als Wurzelknoten</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Abb. 3 :</head><label>3</label><figDesc>Abb. 3: Lösung &lt;321112&gt; im Gosh-Lösungsarchiv eingefügt</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Abb. 4 :</head><label>4</label><figDesc>Abb. 4: Lösung &lt;-65611&gt; im Pop-Lösungsarchiv eingefügt, V 1 ist Wurzelcluster</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Abb. 5 :</head><label>5</label><figDesc>Abb. 5: Boundberechnung im Cluster V 3 beim Einfügen der Lösung &lt;321112&gt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Abb. 6 :</head><label>6</label><figDesc>Abb. 6: Boundberechnung im Cluster V 6</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Abb. 7 :</head><label>7</label><figDesc>Abb. 7: Rekombination von zwei Lösungen</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Algorithmus 11 PopTrie convert with Bound Eingabe: solution to convert sol; best solution bestsol</head><label>11</label><figDesc></figDesc><table>Ausgabe: convertion successfull (true/false) 
Variablen: nn[i]... Nearest Neighbours of Cluster i 

1: curr ← random trie-node of the possible startpoints from sol 
2: while curr! = null &amp;&amp; curr! = complete do 

3: 

p null ← random null-pointer from nn[curr], if none exist, random null-pointern 
from all pointer in curr 

4: 

if p null exists then 

5: 

change solution and check if cycle exist 

6: 

invalidate(curr.cluster, sol) 

7: 

if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then 

8: 

curr.next[sol[curr.cluster]] ← complete 

9: 

undo changes of sol 

10: 

else 

11: 

return true 

12: 

end if 

13: 

else 

14: 

if curr.next[sol[curr.cluster]]! = complete] then 

15: 

invalidate(curr.cluster, sol) 

16: 

if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then 

17: 

delete curr.next[sol[curr.cluster]] and set it complete 

18: 

else 

19: 

curr ← curr.next[sol[curr.cluster]] 

20: 

end if 

21: 

else 

22: 

sol[curr.cluster] ← random not-complete-pointer from nn[curr], if none 
exist, random not-complete-pointer from all pointer in curr 

23: 

invalidate(curr.cluster, sol) 

24: 

if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then 

25: 

delete curr.next[sol[curr.cluster]] and set it complete 

26: 

undo changes of sol 

27: 

else 

28: 

curr ← curr.next[sol[cur.cluster]] 

29: 

end if 

30: 

end if 

31: 

end if 
32: end while 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Tabelle 1 : Testinstanzen und die verwendete Laufzeit</head><label>1</label><figDesc></figDesc><table>Instanz Knoten Cluster Laufzeit[s] 
kroa150 
150 
30 
150 
rat195 
195 
39 
150 
d198 
198 
40 
150 
krob200 
200 
40 
150 
ts225 
225 
45 
200 
pr226 
226 
46 
200 
gil262 
262 
53 
300 
pr264 
264 
54 
300 
pr299 
299 
60 
300 
lin318 
318 
64 
400 
rd400 
400 
80 
450 
fl417 
417 
84 
450 
pr439 
439 
88 
600 
pcb442 
442 
89 
600 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head>Tabelle 2 : Anzahl der Cuts in den unterschiedlichen Bereichen des Archivs</head><label>2</label><figDesc></figDesc><table>Gosh-Archiv 
Pop-Archiv 
Instanz 0-25%25-50%50-75%75-100% 0-25%25-50%50-75%75-100% 
kroa150 0 
0 
26 
11.081 
61 
857 10.721 23.394 
rat195 
0 
0 
1 
5.982 
32 
635 3.376 14.438 
d198 
0 
0 
3 
5.103 
410 5.500 11.913 14.468 
krob200 0 
0 
1 
5.376 
19 
243 1.193 7.590 
ts225 
0 
0 
0 
3.362 
0 
1 
99 
5.646 
pr226 
0 
0 
3 
3.301 
721 6.687 12.744 15.731 
gil262 
0 
0 
5 
6.937 
13 
295 3.067 9.529 
pr264 
0 
0 
10 
5.473 
525 5.764 14.587 13.011 
pr299 
0 
0 
1 
3.318 
45 
544 2.541 9.306 
lin318 
0 
0 
6 
5.187 
332 3.119 12.809 16.113 
rd400 
0 
0 
1 
3.475 
55 
637 4.898 9.744 
fl417 
0 
0 
0 
1.835 2.741 14.811 10.400 7.802 
pr439 
0 
0 
1 
3.141 
457 2.238 4.790 7.617 
pcb442 
0 
0 
1 
3.349 
12 
360 2.510 6.367 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>Tabelle 3 : Vergleich der verschiedenen Bounding-Varianten im Gosh-Archiv</head><label>3</label><figDesc></figDesc><table>Trie 
Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound 
Instanz C avg (T ) Gen C avg (T ) Gen C avg (T ) 
Gen 
C avg (T ) 
Gen 
kroa150 9.822,0 60.747 9.822,0 52.511 9.819,9 29.509 9.819,6 
26.609 
(21,4) 
(12,7) 
(17,7) 
(17,8) 
rat195 754,4 33.232 752,7 28.739 752,9 
17.602 
753,9 
14.481 
(4,7) 
(3,1) 
(3,5) 
(4,1) 
d198 7.054,6 29.272 7.051,5 23,219 7.052,4 14.513 7.053,3 
12.707 
(7,6) 
(5,3) 
(4,5) 
(3,5) 
krob200 11.248,831.790 11.246,1 22.863 11.245,3 16.887 11.260,6 14.727 
(8,7) 
(6,3) 
(5,1) 
(11,0) 
ts225 62.306,332.698 62.275,4 26.467 62.286,5 20.472 62.292,1 18.346 
(59,3) 
(17,7) 
(23,9) 
(46,5) 
pr226 55.515,031.541 55.515,0 25.289 55.515,0 12.098 55.515,0 10.576 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
gil262 944,5 37.349 942,7 22.549 944,1 
19.123 
942,8 
15.878 
(3,8) 
(2,2) 
(4,3) 
(2,7) 
pr264 21.895,133.368 21.891,1 21.467 21.890,1 16.071 21.890,6 11.679 
(11,7) 
(6,6) 
(6,0) 
(8,4) 
pr299 20.354,326.404 20.339,7 15.985 20.346,2 13.081 20.341,0 11.389 
(41,0) 
(21,6) 
(30,0) 
(25,4) 
lin318 18.540,527.309 18.535,1 21.289 18.532,4 13.220 18.528,0 10.738 
(25,4) 
(21,2) 
(16,3) 
(15,1) 
rd400 5.950,6 21.185 5.945,4 14.815 5.947,6 9.260 
5.945,6 
8.261 
(13,9) 
(10,8) 
(13,4) 
(11,5) 
fl417 7.982,0 22.146 7.982,0 15.208 7.982,0 6.324 
7.982,0 
5.457 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
pr439 51.873,917.653 51.828,2 7.855 51.827,0 10.339 51.826,3 
8.651 
(54,5) 
(35,5) 
(35,7) 
(26,7) 
pcb442 19.667,218.106 19.657,4 7.576 19.648,9 10.707 19.654,5 
8.707 
(38,0) 
(40,3) 
(27,3) 
(34,3) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>Tabelle 5 : Vergleich der verschiedenen Bounding-Varianten im Pop-Archiv</head><label>5</label><figDesc></figDesc><table>Trie 
Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound 
Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) 
|Gen| 
kroa150 9.815,0 62.747 9.815,0 44.525 9.815,0 32.376 9.815,0 
24.844 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
rat195 752,5 36.732 751,5 25.765 751,9 
22.772 
752,2 
16.854 
(3,0) 
(2,0) 
(2,5) 
(2,7) 
d198 7.046,1 30.787 7.044,0 20.328 7044,0 14.011 7.044,3 
10.249 
(3,9) 
(0,0) 
(0,0) 
(1,6) 
krob200 11.245,3 34.399 11.244,0 24.306 11.244,0 21.614 11.246,0 17.198 
(5,1) 
(0,0) 
(0,0) 
(6,1) 
ts225 62.268,7 38.580 62.268,2 28.141 62.268,5 29.270 62.268,5 22.654 
(0,5) 
(0,4) 
(0,5) 
(0,5) 
pr226 55.515,033.056 55.515,0 19.713 55.515,0 17.736 55.515,0 10.571 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
gil262 942,4 38.873 942,0 25.842 942,3 
24.078 
942,7 
18.201 
(2,0) 
(0,0) 
(2,0) 
(2,7) 
pr264 21.886,0 36.538 21.886,0 23.104 21.886,0 22.734 21.886,0 13.226 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
pr299 20.318,6 28.971 20.316,1 18.548 20.316,0 20.506 20.320,6 13.950 
(14,2) 
(0,5) 
(0,0) 
(17,5) 
lin318 18.525,5 34.659 18.523,9 17.283 18.523,0 22.782 18.522,2 11.108 
(15,0) 
(9,4) 
(14,3) 
(10,5) 
rd400 5.945,2 25.867 5.943,2 14.627 5.942,5 19.263 5.942,7 
10.666 
(16,5) 
(7,9) 
(6,9) 
(7,2) 
fl417 7.982,0 23.200 7.982,0 8.683 7.982,0 13.515 7.982,0 
2.578 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
pr439 51.796,5 24.933 51.794,0 14.215 51.793,5 20.692 51.791,6 
9.734 
(29,7) 
(16,6) 
(10,8) 
(2,7) 
pcb442 19.630,2 26.755 19634,4 15.859 19.627,7 22.892 19.627,4 13.407 
(23,6) 
(20,2) 
(15,7) 
(15,6) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16" validated="false"><head>Tabelle 6 : Vergleich der verschiedenen Bounding-Varianten bei der Kombination von Gosh-und Pop Archiv</head><label>6</label><figDesc></figDesc><table>Trie 
Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound 
Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) 
|Gen| 
kroa150 9.815,0 21.637 9.815,0 14.801 9.815,0 9.853 
9.815,0 
7.638 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
rat195 752,1 18.540 751,3 11.167 752,8 
9.476 
752,6 
5.372 
(2,8) 
(1,4) 
(3,4) 
(3,2) 
d198 7.044,0 11.199 7.044,0 7.149 7.044,0 5.418 
7.044,0 
3.924 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
krob200 11.244,016.633 11.244,0 10.592 11.244,0 10.370 11.244,0 
7.531 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
ts225 62.268,517.676 62.268,3 11.333 62.268,3 13.357 62.268,3 
9.474 
(0,5) 
(0,5) 
(0,5) 
(0,5) 
pr226 55.515,0 1.148 55.515,0 625 55.515,0 
416 
55.515,0 
323 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
gil262 942,0 20.694 942,0 11.228 942,0 
11.494 
942,0 
8.025 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
pr264 21.886,016.198 21.886,0 9.744 21.886,0 9.458 21.886,0 
6.099 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
pr299 20.316,015.475 20.316,0 8.480 20.316,0 9.625 20.316,0 
6.671 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
lin318 18.522,916.954 18.515,9 8.576 18.517,7 8.670 18.519,5 
5.218 
(9,2) 
(12,4) 
(8,7) 
(8,3) 
rd400 5.940,3 14.236 5.937,7 6.692 5.938,9 8.545 
5.939,9 
5.184 
(6,4) 
(5,8) 
(7,6) 
(5,6) 
fl417 7.982,0 1.486 7.982,0 875 
7.982,0 
585 
7.982,0 
418 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
pr439 51.791,012.837 51.792,2 6.101 51.791,0 9.331 51.791,0 
4.716 
(0,0) 
(6,4) 
(0,0) 
(0,0) 
pcb442 19.625,817.457 19.623,6 8.198 19.620,5 10.872 19.622,8 
6.961 
(19,1) 
(17,4) 
(18,7) 
(18,3) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18" validated="false"><head>Tabelle 8 : Vergleich von Pop-Trie mit 10000 Generationen</head><label>8</label><figDesc></figDesc><table>Trie 
Trie+insert-Bound 
Trie+convert-Bound 
Instanz C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B] 
kroa150 9.815,0 24 
28,9 
9.815,0 35 
42,3 
9.815,0 37 
32,8 
(0,0) 
(0,0) 
(0,0) 
rat195 751,6 
41 
55,4 
751,5 
64 
84,1 
752,1 
58 
59,5 
(2,1) 
(2,0) 
(2,8) 
d198 7.046,5 49 
49,0 
7.045,4 90 
95,9 
7.044,6 99 
54,1 
(4,0) 
(3,3) 
(2,3) 
krob200 11.246,1 44 
58,3 
11.246,3 66 
75,7 
11.244,7 55 
61,2 
(6,2) 
(6,4) 
(3,7) 
ts225 62.268,5 53 
84,7 
62.268,5 74 
96,9 
62.268,4 61 
85,3 
(0,5) 
(0,5) 
(0,5) 
pr226 55.515,0 61 
76,1 
55.515,0 140 
171,2 
55.515,0 100 
89,3 
(0,0) 
(0,0) 
(0,0) 
gil262 942,4 
78 
111,4 
942,5 128 
158,3 
942,4 
93 
115,8 
(2,0) 
(2,3) 
(2,0) 
pr264 21.886,0 83 
108,5 
21.886,0 169 
210,9 
21.886,0 106 
115,9 
(0,0) 
(0,0) 
(0,0) 
pr299 20.325,3 105 
133,6 
20.318,6 202 
225,2 
20.317,7 129 
137,4 
(19,5) 
(9,3) 
(7,8) 
lin318 18.521,4 116 
163,5 
18.519,5 298 
384,1 
18.524,2 152 
174,2 
(13,2) 
(14,2) 
(12,8) 
rd400 5.943,0 178 
264,7 
5.942,8 502 
600,1 
5.944,7 212 
276,9 
(9,7) 
(7,1) 
(7,8) 
fl417 7.982,0 196 
265,0 
7.982,0 1.041 
845,7 
7.982,0 326 
302,5 
(0,0) 
(0,0) 
(0,0) 
pr439 51.792,3 248 
309,3 
51.793,0 687 
679,3 
51.791,1 267 
315,3 
(6,7) 
(8,0) 
(0,3) 
pcb442 19.628,9 229 
360,0 
19.628,1 527 
615,6 
19.633,6 244 
367,4 
(20,5) 
(19,1) 
(21,4) 

42 

3.4. State of the Art 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_19" validated="false"><head>Tabelle 9 : Vergleich von Pop-Tries mit 10000 Generationen ohne return</head><label>9</label><figDesc></figDesc><table>Trie 
Trie+insert-Bound 
Instanz 
C avg (T ) Zeit [s] M em [M B] C avg (T ) Zeit [s] M em [M B] 
kroa150 
9.815,0 
24 
28,9 
9.815,0 
36 
29,2 
(0,0) 
(0,0) 
rat195 
751,6 
41 
55,4 
751,5 
61 
54,6 
(2,1) 
(2,0) 
d198 
7.046,5 
49 
49,0 
7.045,6 
89 
44,4 
(4,0) 
(3,4) 
krob200 11.246,1 
44 
58,3 
11.244,7 
62 
58,3 
(6,2) 
(3,7) 
ts225 
62.268,5 
53 
84,7 
62.268,4 
71,9 
82,8 
(0,5) 
(0,5) 
pr226 
55.515,0 
61 
76,1 
55.515,0 
106 
75,8 
(0,0) 
(0,0) 
gil262 
942,4 
78 
111,4 
942,3 
111 
111,9 
(2,0) 
(2,0) 
pr264 
21.886,0 
83 
108,5 
21.886,0 
121 
101,8 
(0,0) 
(0,0) 
pr299 
20.325,3 
105 
133,6 
20.320,3 
158 
130,9 
(19,5) 
(13,0) 
lin318 
18.521,4 
116 
163,5 
18.522,4 
183 
156,8 
(13,2) 
(11,2) 
rd400 
5.943,0 
178 
264,7 
5.944,7 
292 
259,6 
(9,7) 
(7,7) 
fl417 
7.982,0 
196 
265,0 
7.982,0 
384 
239,5 
(0,0) 
(0,0) 
pr439 
51.792,3 
248 
309,3 
51.791,0 377,9 
299,2 
(6,7) 
(0,0) 
pcb442 19.628,9 
229 
360,0 
19.630,5 
354 
355,2 
(20,5) 
(21,8) 

</table></figure>

			<note place="foot" n="1"> http://elib.zib.de/pub/Packages/mp-testdata/tsp/tsplib/tsp/index.html</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Generalized Spanning Trees and Extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feremans</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>Universite Libre de Bruxelles, Diss.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Solving medium to large sized Euclidean generalized minimum spanning tree problems / Indian Institute of Management, Research and Publication Department</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghosh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Computing Generalized Minimum Spanning Trees with Variable Neighborhood Search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">;</forename><surname>Leitner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">;</forename><surname>Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
		<editor>HANSEN, P.</editor>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mladenovi´novi´</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pérez</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A M</forename></persName>
		</author>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">M</forename><surname>Batista</surname></persName>
		</author>
		<imprint>
			<pubPlace>Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Moreno</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Vega</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hrsg</surname></persName>
		</author>
		<title level="m">Proceedings of the 18th Mini Euro Conference on Variable Neighborhood Search. Teneriffa, Spanien</title>
		<meeting>the 18th Mini Euro Conference on Variable Neighborhood Search. Teneriffa, Spanien</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Combining Variable Neighborhood Search with Integer Linear Programming for the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">;</forename><surname>Leitner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">;</forename><surname>Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Heuristics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="473" to="499" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Evolutionary Algorithm with Solution Archive for the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">;</forename><surname>Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EUROCAST 2011-13th International Conference on Computer Aided Systems Theory</title>
		<editor>QUESADA-ARENCIBIA, A.</editor>
		<meeting>EUROCAST 2011-13th International Conference on Computer Aided Systems Theory<address><addrLine>Las Palmas de Gran Canaria, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="256" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An efficient algorithm for generalized minimum spanning tree problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
		<idno>978-1-4503-0072-8</idno>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;10: Proceedings of the 12th annual conference on Genetic and evolutionary computation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Solving Two Generalized Network Design Problems with Exact and Heuristic Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leitner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<editor>G. Raidl and B. Hu</editor>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien, Diplomarbeit</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Myung</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Tcha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="231" to="241" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Einführung in Evolutionäre Algorithmen.: Optimierung nach dem Vorbild der Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nissen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Vieweg</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A hybrid heuristic approach for solving the generalized traveling salesman problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pop</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Iordache</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<imprint>
			<publisher>KRASNOGOR</publisher>
			<pubPlace>Natalio (Hrsg.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pier</forename><forename type="middle">L</forename><surname>Lanzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hrsg</surname></persName>
		</author>
		<title level="m">GECCO, ACM</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="481" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pop</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<pubPlace>Diss</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Twente</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Enhancing Genetic Algorithms by a Trie-Based Complete Solution Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raidl</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolutionary Computation in Combinatorial Optimisation-EvoCOP</title>
		<imprint>
			<biblScope unit="page" from="239" to="251" />
			<date type="published" when="2010" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Ein neues Lösungsarchiv für das Generalized Minimum Spanning Tree-Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sonnleitner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Enhancing a Genetic Algorithm by a Complete Solution Archive Based on a Trie Data Structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Šramko</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Ein Lösungsarchiv-unterstützter evolutionärer Algorithmus für das Generalized Minimum Spanning Tree-Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolf</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">A Complete Archive Genetic Algorithm for the Multidimensional Knapsack Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zaubzer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
