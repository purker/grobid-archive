<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Multilevel Refinement Approach to the Rooted Delay-Constrained Steiner Tree Problem</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-09-25">Wien, 25.09.2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Seidl Matrikelnummer</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universität Wien</orgName>
								<address>
									<addrLine>13 Tel. +43-1-58801-0 www.tuwien</addrLine>
									<postCode>A-1040</postCode>
									<settlement>Wien Karlsplatz</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">Rooted Delay-Constrained Steiner Tree Problem</orgName>
								<orgName type="institution">vii Contents</orgName>
								<address>
									<addrLine>1 Introduction 1 1.1 The</addrLine>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Multilevel Refinement Approach to the Rooted Delay-Constrained Steiner Tree Problem</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-09-25">Wien, 25.09.2011</date>
						</imprint>
					</monogr>
					<note>eingereicht von Betreuung Betreuung: ao. Univ.-Prof. Dipl.-Ing. Dr.techn. Günther Raidl Mitwirkung: Univ.Ass. Dipl.-Ing. Mario Ruthmair (Unterschrift Verfasser) (Unterschrift Betreuung) Erklärung zur Verfassung der Arbeit Thomas Seidl Randhartingergasse 12/26, 1100 Wien Hiermit erkläre ich, dass ich diese Arbeit selbstständig verfasst habe, dass ich die verwen-deten Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen der Arbeit -einschließlich Tabellen, Karten und Abbildungen -, die anderen Werken oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe. i</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract xml:lang="de">
				<p>Acknowledgements I would like to thank my advisor, Prof. Dr. Günther Raidl, for letting me work on this thesis and for his help and suggestions with creating it. I also thank the Vienna University of Technology for the years of education I received there, and for the prolific scientific environment it provided. My special thanks go to my mentor for this thesis, Dipl.-Ing. Mario Ruthmair. Without his countless suggestions, our numerous discussions, his help and his thorough reviews, this thesis would never have been completed. Lastly, I want to sincerely thank my parents, who supported me in every possible way throughout my education and without whom none of this would have been possible. iii Abstract The Rooted Delay-Constrained Steiner Tree Problem (RDCSTP) is a variant of the well-known Steiner Tree Problem on a graph in which the paths to all terminal nodes are restricted by a certain maximum delay. The problem mostly appears in the context of network routing for multicasts, i.e., sending packages from a fixed source to a subset of other participants in the network. Since the RDCSTP belongs to the class of N P-hard problems it is in general not possible to solve large instances exactly in a reasonable amount of time. Therefore, the focus mostly lies on developing good heuristics that can still solve large instances comparatively fast to near optimality. In this thesis a Multilevel Refinement heuristic-which has already been successfully applied to other problems like the Graph Partitioning Problem-is implemented as an improvement heuristic for the RDCSTP. In the general approach of this metaheuristic the problem&apos;s complexity is first iteratively reduced while still maintaining its general characteristics. The problem is thereby simplified and can at the top level finally easily be solved. Then, the solution on this highest level is refined until a solution for the original problem is obtained. The algorithm introduced here implements the Multilevel Refinement approach as an improvement heuristic, iteratively changing an existing solution. However, it is designed in a way that also allows it to be used to construct an initial solution. Another distinctiveness is that, due to the additional delay constraints, supplementary data structures have to be used to avoid creating invalid solutions on higher levels as much as possible. In the refinement phase an additional improvement algorithm, the Key Path Improvement, is executed on each level, drastically increasing result quality. Experimental tests are carried out, evaluating the performance of the algorithm on large instances and comparing it to other algorithms in the literature. The obtained results are promising and indicate that the Multilevel Refinement metaheuristic is indeed a competitive approach for the RDCSTP. v Kurzfassung Das Rooted Delay-Constrained Steiner Tree Problem (RDCSTP) ist eine Variante des bekannten Steinerbaum-Problems auf einem Graphen in welcher die Pfade zu allen Zielknoten durch eine bestimmte maximale Verzögerung beschränkt sind. Das Problem tritt hauptsächlich im Bereich des Netzwerk-Routings beim Multicast auf, das heißt wenn Pakete von einer einzelnen Quelle zu einer bestimmten Untermenge der anderen Netzwerk-Teilnehmer gesendet werden sollen. Da das RDCSTP, wie das ursprüngliche Steiner-Problem, zur Klasse der N P-schwierigen Probleme gehört, ist es allgemein nicht möglich die exakte Lösung einer großen Probleminstanz in vertret-barer Zeit zu finden. Der Fokus der Forschung liegt daher großteils auf der Entwicklung guter Heuristiken, die auch bei großen Probleminstanzen in der Lage sind in vergleichbar kurzer Zeit zu möglichst guten Lösungen zu kommen. In dieser Arbeit wird hierfür die Multilevel-Refinement-Heuristik-die bereits erfolgreich auf etliche andere Probleme, wie das Graph Partitioning Problem, angewandt wurde-als Ver-besserungsheuristik für das RDCSTP entwickelt. Grundsätzlich werden bei dieser Metaheuristik in einem ersten Schritt Knoten sukzessive zusammengefasst um den Graphen auf höheren &quot;Lev-els&quot;, mit weniger Knoten, darzustellen. Das so vereinfachte Problem kann dann auf der höchsten Abstraktionsebene in simpler Weise gelöst werden. Dann wird diese Lösung schrittweise wieder soweit verfeinert, bis eine Lösung für das ursprüngliche Problem erreicht wird. Der hier vorgestellte Algorithmus für das RDCSTP implementiert diesen Multilevel-Ansatz als Verbesserungsheuristik, die eine existierende Lösung iterativ verändert. Er wurde allerdings in einer Weise entworfen, die es ihm ebenso erlaubt eine Anfangslösung selbst zu generieren. Eine weitere Besonderheit ist, dass wegen der zusätzlichen Verzögerungs-Einschränkung wei-tere Datenstrukturen benötigt werden, um auf höheren Levels möglichst gültige Lösungen zu erzeugen. Außerdem wird während der Verfeinerung der Lösung auf jedem Level eine weite-re Verbesserungsheuristik angewandt, das Key Path Improvement, welches die Lösungsqualität drastisch verbessert. Umfangreiche experimentelle Tests wurden durchgeführt um die Leistungsfähigkeit des Al-gorithmus bei großen Instanzen zu messen, und ihn mit anderen Algorithmen aus der Literatur zu vergleichen. Die hierbei erhaltenen Ergebnisse sind durchwegs sehr positiv und weisen somit darauf hin, dass der verfolgte Multilevel-Ansatz tatsächlich eine konkurrenzfähige Heuristik für das RDCSTP darstellt.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The Rooted Delay-Constrained Steiner Tree Problem</head><p>One of the most frequent algorithmic problems encountered in network routing is to connect participants with each other as efficiently as possible (for some definition of "efficient") and a large multitude of literature is available for these problems. However, such simplicistic views often fail to take other concerns into account which might still be of great significance for the practical problem.</p><p>For example, consider the repeated multicast of information from a fixed source to a sub- set of the participants in a network. Fixed connections should be established to faciliate such transmissions, which should of course be done with as little cost as possible.</p><p>To represent this problem in an abstract way, we model the network as a connected graph, with nodes representing all network participants and the edges representing the possible con- nections between these participants. Costs are defined on all edges to provide a measure of how efficiently these connections can be used, or of how desirable it is to use them. The problem then consists of creating a tree of minimum cost in this graph which contains all of the destinations of the multicast, and of course the source.</p><p>This problem is already well-known as the Steiner Tree Problem in literature <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>. There, the nodes that have to be included in the tree are called terminals, while all other nodes are called Steiner nodes. The problem was proven to be N P-hard in <ref type="bibr" target="#b2">[3]</ref>.</p><p>However, as a representation of the original problem this comes short of grasping a vital aspect of some multicasts, namely network delays. Especially when streaming audio or video, maybe even in the context of video conferencing, being able to cheaply enable a connection is often only important as long as the delay between the source and the destinations stays within certain acceptable boundaries. The problem model therefore has to be expanded to takes this additional criterion into account.</p><p>In addition to the previous definitions, we now define network delays for all possible con- nections, i.e., all edges of the graph. Also, a certain threshold is given, a maximum delay bound which no delay between the source node and a terminal may exceed in a valid solution. This variant is known as the Rooted Delay-Constrained Steiner Tree Problem (RDCSTP), or Multi- cast Routing Problem With Delays. It, too, is N P-hard <ref type="bibr" target="#b3">[4]</ref>. <ref type="figure">Figure 1</ref>.1 shows an example for an instance of the RDCSTP. The Steiner node 2 is used to decrease the overall costs of the tree while node 5 is excluded since using it to connect node 4 would be more expensive than the direct edge. Using edge {3, 4} to connect node 4 would decrease the tree cost but violate the delay bound.</p><p>Since in practical usage one might often encounter large instances of the problem which can -due to the N P-hardness of the problem -not be solved exactly in a reasonable amount of time, heuristic algorithms for the RDCSTP have for the most part been the focus of research in this area. While improving existing exact algorithms to increase their range of use is also a worthwhile effort, we still decided to research the suitability of an existing metaheuristic for the RDCSTP in this thesis. Furthermore, a variant of the problem arises in circuit design, where large problem instances might also occur frequently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">The Multilevel Refinement heuristic</head><p>The Multilevel Refinement heuristic is a meta-heuristic that has already been applied successfully to other graph problems, like the graph partitioning problem <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. Its basic idea is to reduce the problem complexity by successively reducing the size of the graph while still maintaining enough information about the original graph for the constructed solution to be useful for the original problem.</p><p>An application of the Multilevel Refinement heuristic on a problem consists of three phases: coarsening, solving the coarsened problem and refinement. In the coarsening phase the problem is successively simplified to create new "levels" of it. This has to be done in a way that ensures the higher levels of the problem still represent the original problem in most characteristics. In the case of Multilevel Refinement on graphs the operation usually chosen here is to merge edges or nodes to form the higher levels, thus still preserving the rough structure of the graph, with node clusters on lower levels being represented by single nodes on higher ones. There are lots of variants here, though, and completely other strategies for coarsening a graph could also be employed.</p><p>The coarsening is executed until a certain abort criterion is met. For instance the condition could be that no more coarsening is possible, or that the problem complexity is below a certain threshold at which it can easily be solved exactly. At this point, the second phase of the algorithm is executed: the problem on the highest level is solved, which should now be easily possible.</p><p>In the concluding third phase, the refinement phase, this solution for the highest level is then iteratively extended to provide solutions for lower levels of the problem. The way this is ac- complished is highly problem-specific, and the suitability of the Multilevel Refinement heuristic for a given problem largely depends on whether this step can be easily executed. Usually the changes between levels of the problem can analogously be applied to the solution, thus yielding solutions for lower levels. In graph problems when merging nodes or edges during coarsening, refinement is usually possible by replacing the merged nodes or edges in the solution by the corresponding nodes and edges from the next-lower level of the graph.</p><p>The refinement is executed until a solution for the original problem is obtained. In addition to the basic refinement, one or more extra improvement heuristics can be applied to the solution as well on each level (or only on certain ones) to further improve the final solution quality. <ref type="figure">Figure 1</ref>.2 illustrates how an application of the Multilevel Refinement metaheuristic on a graph problem might look. In this example the graph is coarsened by merging nodes to form higher levels.</p><p>A good summary of the metaheuristic can be found in <ref type="bibr" target="#b6">[7]</ref>. Section 2 contains examples of previous successful applications of the approach in the literature.</p><p>Since the Multilevel Refinement metaheuristic has already proven successful for several graph problems, but has not yet been applied to the RDCSTP, we were interested in evaluating its appropriateness for this problem, too. One of our specific hopes was that using the Multi- level Refinement approach would bring more impact on the global scale to local improvement heuristics for larger problem instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Structure of the thesis</head><p>The remainder of this thesis is structured as follows: Section 2 contains an overview of exist- ing work in the literature which is relevant to this thesis. Section 3 then explains the general algorithm we designed in this paper and what specific problems had to be solved. This is then elaborated on in Section 4 where we more closely discuss some details of the implementation of our algorithm. In Section 5 we list the results of several benchmarks and comparisons we executed on the final program. We conclude with a short summary of the thesis and an outlook on possible future work in this area in Section 6. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work</head><p>The RDCSTP (mostly under aliases such as Delay-Constrained Multicast Routing) is already well-known and has been the focus of research numerous times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preprocessing</head><p>Preprocessing techniques are an important part of the research for the RDCSTP as they allow to significantly reduce the problem size in a manner that is in no way dependent on the concrete algorithm used to solve the problem. The algorithms mentioned here were therefore also used in the final program evaluated in this thesis.</p><p>In <ref type="bibr" target="#b7">[8]</ref>, some simple cases are described in which edges can safely be removed from the graph. This includes edges that can never be part of a valid solution (due to their delay being too high) or that cannot be part of an optimal solution (e.g., when simple triangle inequalities do not hold on costs and delays for some circle of three edges). Although the paper discusses the Rooted Delay-Constrained Minimum Spanning Tree Problem -a specialized variant of the RDCSTP in which all nodes are terminals -, these techniques can equally be used for the RDCSTP itself.</p><p>Preprocessing techniques that also take the special properties of Steiner nodes into account are described in <ref type="bibr" target="#b8">[9]</ref>, for the original Steiner Tree Problem. This includes simple measures, like removing Steiner nodes that are leaves, but also some more complex checks. For inclusion in our program, these had to be extended to take the edge delays into account.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Heuristic algorithms</head><p>Due to the N P-hardness of the problem, heuristic algorithms have been very popular for the RDCSTP and there are already numerous existing algorithms for it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Construction heuristics</head><p>The first mention of the problem in literature was in <ref type="bibr" target="#b3">[4]</ref>, where an adapted version of the algo- rithm in <ref type="bibr" target="#b9">[10]</ref> for the Steiner tree problem without delays was applied to the problem.</p><p>In <ref type="bibr" target="#b10">[11]</ref>, a minimum-delay tree is constructed as a first step. Then, the delay-bounded tree is iteratively improved to minimize costs. Paper <ref type="bibr" target="#b11">[12]</ref> proposes an adapted version of an algorithm from <ref type="bibr" target="#b12">[13]</ref>, for the unicast routing problem. A solution is constructed by iteratively adding termi- nals to the tree until the whole set of terminals is included. However, this paper also takes into account asymmetric costs and delays, which are not considered here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Improvement and meta-heuristics</head><p>A genetic algorithm is considered in <ref type="bibr" target="#b13">[14]</ref> for a slight variant of the problem, which adds a con- straint on a third edge property, the bandwidth, and allows different delay bounds per terminal.</p><p>More recently, in <ref type="bibr" target="#b14">[15]</ref> a path-relinking approach was applied to the problem. This is a ge- netic algorithm in which new solutions are constructed by conceptually connecting two existing solutions in the solution space and examining all solutions along this path.</p><p>The well-known Greedy Randomized Adaptive Search Procedure (GRASP) heuristic was also employed several times for the RDCSTP <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>, generally leading to promising results. The latter of those uses a Variable Neighborhood Descent (VND) algorithm as the local search heuristic, which was first introduced as a stand-alone heuristic in <ref type="bibr" target="#b17">[18]</ref>.</p><p>One of the most recent works regarding the RDCSTP can be found in <ref type="bibr" target="#b18">[19]</ref>. There, a combi- nation of the path-relinking approach with a scatter search heuristic was developed, also showing very good results. The experimental data from this paper will therefore later be used for com- parison with the algorithm developed here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Exact algorithms</head><p>Even though it is hard to design efficient exact algorithms for the RDCSTP and their use in practice is limited due to the quickly increasing complexity for larger instances there are already several approaches in this category. The first Integer Linear Programming formulation of the problem can be found in <ref type="bibr" target="#b19">[20]</ref>, with the addition of bandwidth to the problem.</p><p>More recently, <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref> investigated some other (also Mixed Integer Programming) formu- lations and additional restrictions. In <ref type="bibr" target="#b22">[23]</ref>, these were then combined with a Branch-and-Cut approach.</p><p>A Mixed Integer Programming formulation using layered graphs is discussed in <ref type="bibr" target="#b23">[24]</ref>. The paper also introduces a technique called "adaptive layers", in which new layers are iteratively added to an initially smaller problem formulation to tighten lower and upper bounds.</p><p>In <ref type="bibr" target="#b24">[25]</ref>, the stabilized column generation algorithm from <ref type="bibr" target="#b25">[26]</ref> is expanded with a branch- and-bound approach and an additional pricing strategy to form a stabilized branch-and-price algorithm.</p><p>Although experimental results for the newer exact algorithms proved very promising, all of these exact approaches quickly reach their limits for complete graphs with more than about 100 nodes. They are therefore no viable option for large problem instances. <ref type="bibr" target="#b5">6</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Multilevel Refinement heuristic</head><p>As already mentioned, the Multilevel Refinement approach has successfully been applied to the Graph Partitioning Problem in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. Earlier applications of the Multilevel approach are discussed in <ref type="bibr" target="#b26">[27]</ref>, mentioning applications like Multilevel Annealing, Multilevel Monte-Carlo, and other heuristics.</p><p>In <ref type="bibr" target="#b27">[28]</ref>, the Multilevel Refinement heuristic is used with great success on the Travelling Salesman Problem, considerably improving the results of the traditional Chained Lin-Kernighan algorithm, which is used as the improvement heuristic on each level. Such an algorithm is also discussed, amongst many others, in <ref type="bibr" target="#b28">[29]</ref>.</p><p>The Graph Coloring Problem has also been tackled with the Multilevel Refinement heuristic <ref type="bibr" target="#b29">[30]</ref>. There, both an iterated greedy algorithm and tabu search are tested as improvement heuris- tics for the refinement, in both cases improving the results obtained by using the algorithms without the Multilevel addition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Other related work</head><p>The Multilevel Refinement heuristic has not yet been applied to the RDCSTP. However, in <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b31">32]</ref> it is applied to the Rooted Delay-Constrained Minimum Spanning Tree Problem (RD- CMSTP).</p><p>In the algorithm presented there, however, nodes are not explicitly merged together. Instead, on each level first a number of so-called "supervertices" are selected according to their "ranking score" (a value computed by the number and cost/delay values of their adjacent edges). Each of the remaining nodes has then to be connected to one of these supervertices by a direct edge. The supervertices and all edges between them then become the problem graph on the next level.</p><p>This process is continued until only the source node remains, which then contains a valid solution for the original problem. The algorithm therefore does not include an explicit refinement phase, thus also precluding the use of an improvement heuristic on each separate level. An improvement heuristic (a VND described in <ref type="bibr" target="#b32">[33]</ref>) is only applied to the final solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CHAPTER 3</head><p>Algorithm As explained in the introduction, the Multilevel Refinement metaheuristic consists of three pri- mary steps: coarsening, solving the coarsest problem and refining. The following chapter de- scribes in detail how each of these phases was implemented for the RDCSTP and what specific problems had to be resolved.</p><p>The algorithm was used as an improvement heuristic, in the form of an Iterated Multilevel Refinement. This means that the three steps were executed repeatedly, with the solution of the previous iteration being used as the starting solution for the next one, until certain criteria (e.g., a time limit or a certain number of iterations without any improvements) were met.</p><p>The iterations in this outer loop were also used to dynamically adapt some parameters of the algorithm, as described later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problem formulation and definitions</head><p>Mathematically, the RDCSTP is defined as follows. Given are a connected graph G = (V, E) consisting of a set V of nodes and a set E of edges; a cost function</p><formula xml:id="formula_0">C : E → R +</formula><p>and a delay function</p><formula xml:id="formula_1">D : E → R +</formula><p>defined for all edges of the graph; a subset S ⊂ V of terminals; a source node s ∈ V ; and a delay bound B ∈ R + <ref type="bibr" target="#b3">[4]</ref>.</p><p>For a tree T = (V T , E T ) (with V T ⊆ V and E T ⊆ E) in G and two nodes u, v ∈ V T , we define P T (u, v) as the path between these nodes in T , i.e., the set of edges e ∈ E T needed to connect them. Likewise, we define P G (u, v) as the path between u and v which has the lowest 9 delay, or an arbitrary one such path if there is more than one. We then define the cost and delay functions on such a path p in the following way:</p><formula xml:id="formula_2">C * (p) = C(e) e∈p D * (p) = D(e) e∈p</formula><p>A valid solution to the RDCSTP is then a tree T = (V T , E T ) for which the following conditions hold:</p><formula xml:id="formula_3">∀v ∈ S : v ∈ V T ∀v ∈ V T : C * (P T (s, v)) ≤ B</formula><p>An optimal solution T * is a valid solution which has a minimal total cost</p><formula xml:id="formula_4">C * (E T ) = C(e) e∈E T</formula><p>among all valid solutions. The existence of more than one optimal solution is of course possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">General approach</head><p>Algorithm 3.1 gives an overview of the general approach of the Multilevel Refinement heuristic that we wanted to apply to the RDCSTP. As explained in Section 1, the algorithm consists of three phases: the problem is first coarsened iteratively to create higher levels of abstraction, in some problem-specific way. Once a certain criterion is met (usually when the current level of the problem can be solved easily enough) this process is stopped and a solution for this highest level problem created. The solution is then successively refined to lower levels in this problem hierarchy, again in a problem-specific way, until we finally obtain a solution for the original problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Coarsening phase</head><p>As explained, the purpose of the coarsening phase is to iteratively reduce the graph until the problem becomes trivial. In principle, this could be done in various ways. The most intuitive approach to this seems, however, to be to merge nodes. As this also leads to a comparatively simple layout of the general algorithm, this variant of coarsening was therefore used here. The schematic approach for this is described in Algorithm 3.2.</p><p>listSortedEdges will retrieve all edges of the graph on the current level. As the nodes that will be merged are determined by the order of the list returned by this function, the sorting Algorithm 3.1: multilevelRefinement() Purpose: Solves a problem heuristically using the Multilevel Refinement algorithm. Input: A (usually combinatorial) problem P . Output: A possible solution to P .</p><p>1 P 0 ← P ; 2 l ← 0; 3 while P l not trivial do // coarsen the problem until it can easily be solved</p><formula xml:id="formula_5">4 l ← l + 1; 5 P l ← simplified form of P l−1 ;</formula><p>6 end while 7 S l ← solution for P l ; // solve the problem on the highest level 8 while l &gt; 0 do // refine the solution again</p><formula xml:id="formula_6">9 l ← l − 1; 10 S l ← solution to P l , based on S l+1 ;</formula><p>11 end while 12 return S 0 ;</p><p>Algorithm 3.2: coarsen() Purpose: Coarsens the graph into a reduced form which can easily be solved, saving the necessary information to later refine it again. there has to be well thought-out. Needed here is a heuristic measure on merging which edges will result in the best final solutions. As edges "contained" in a merged node are conceptually always part of the tree, these would usually be edges which might form a good solution. From this it is clear that the primary indicators of the edge "score", by which edges will be ordered in listSortedEdges should be the edges' costs and delays. As these are have entirely different dimensions, multiplying them is the only reasonable way in which to combine them to form a score. Also, since cost and delay will probably have differently strong influences on the edge quality (in terms of the nodes connected by which edges should be merged), we allow for exponents for both cost and delay to balance their influence on the edge scores accordingly.</p><formula xml:id="formula_7">1 P 0 ← G; 2 level ← 0</formula><p>Another thing that should influence the edge score, since the algorithm should implement an Iterated Multilevel Refinement approach, is the previous solution. Nodes connected by edges that already were part of the previous solution should be more likely to be merged again. There- fore, the score of edges contained in the previous solution tree should be decreased (indicating a better score, in our case).</p><p>We also took into account the possibility that the types of nodes merged could influence the final solution quality. For instance, always preferring to merge terminals with other terminals instead of Steiner nodes, or Steiner nodes with other Steiner nodes, could conceivably improve or worsen the algorithm's results. A factor to represent this possible effect was hence also included in the formula.</p><p>Finally, we also added a random factor to the formula to faciliate larger variety in searching the solution space, and to avoid getting stuck in local optima too easily. We thus arrived at the following formula for the edge score:</p><formula xml:id="formula_8">score(e) = C α (e) · D β (e) · treeBoost(e) · edgeTypeBoost(e) · rand () 1 treeBoost(e) = treeBoost if e in previous solution 1 otherwise rand () = 1 if randBoost = 0 2 GetRandom(randBoost) otherwise</formula><p>Here, randBoost and treeBoost are parameters of the algorithm whose effects on the solu- tion quality will be studied in Section 5. GetRandom(σ) is a function which returns a random number, following a normal distribution with mean 0 and variance σ 2 . In the formula it is used as an exponent with basis 2, so the probability of multiplying and of dividing the score by a certain value would be equal (and would decrease for increasing values).</p><p>edgeTypeBoost(e) is a function which can return an additional boosting factor according to the type of nodes edge e connects. It is explained in Algorithm 3.3. As can be seen, its concrete effect is dependent on two additional parameters, twoTermBoost and mixedEdgeBoost. These parameters, too, will be evaluated in Section 5.</p><p>First, it is counted how many of the two end nodes of the edge are terminals. Then, this will result in a boost or penalty to the edge score. A positive value of the twoTermBoost parameter means that edges connecting two terminals should have better scores. (Note that we did not use non-zero values with an absolute value less than 1 for these two parameters. For such values, Algorithm 3.3: edgeTypeBoost() Purpose: Determines a boost or penalty for an edge, depending on the types of nodes it connects. Input: An edge between two nodes u and v. Output: The value by which the edge score should be multiplied. the effects would of course be reversed.) Therefore, if the parameter has a positive value and the number of terminals is not 2, the score is multiplied by the parameter and thus worsened. A negative value of the twoTermBoost parameter conversely means that edges connecting two Steiner nodes should have better scores. Therefore, in this case the scores of edges where the number of terminals is not 0 are multiplied by the absolute value of the parameter. Likewise, the mixedEdgeBoost parameter is treated, where positive values mean better scores for edges connecting a terminal and a Steiner node, and negative values result again in a score boost for edges connecting two Steiner nodes.</p><p>On the whole, this sorting results in edges which have lower costs or delays, or which were already part of the previous solution, being inspected sooner (not accounting for the random factor) and therefore being more likely to be merged.</p><p>The algorithm for merging two nodes, referred to as mergeEdge here, is detailed in Algo- rithm 3.4. The function isFeasible checks whether the given edge can, in theory, be part of a feasible solution on the current level. In principle, this is the case if the minimum delay from the source to at least one of the connected nodes is less than or equal to the delay bound minus the edge's delay. The computation is significantly more complicated for higher levels, however. A detailed description of the function implementation will be given in Algorithm 4.1.</p><p>In mergeEdge it is first checked whether the edge between the two nodes that should be merged can still be part of a valid solution in the current graph. If this is not the case, the edge is simply removed from the graph and the function returns. Otherwise, the edge is removed and a new node n inserted into the graph. The new node is exactly then a terminal if at least one of the two merged nodes is a terminal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3.4: mergeEdge()</head><p>Purpose: Merges the two nodes connected by e into a single one which inherits all edges to other nodes. Remembers all modifications so that they can be undone later during refinement. Input: An edge e, connecting the nodes u and v. Then all nodes are inspected which are neighbors of either one or both of the nodes to be merged. For each node among these neighbors, the edge or edges connecting it to the merged nodes will be checked for whether they could still be part of a valid solution once the nodes are merged. If this is not the case, the concerned edge is just removed. Otherwise, cost and delay of the edge are remembered before it is removed. If a node is connected to both of the nodes that will be merged, only the cost and delay of the edge with the lower delay will be remembered. Now, after the edge or edges to a neighbor are removed, an edge with the remembered cost and delay between this node and the newly inserted node n will be created, unless no values were remembered for that node. This is done for all neighbors of the two nodes. Afterwards, they, too, are removed from the graph.</p><formula xml:id="formula_9">1 if not isFeasible(e) then 2 E ← E \ {e}; 3 return; 4 end if 5 E ← E \ {e}; 6 V ← V ∪ {n}; 7 if u ∈ S or v ∈ S then 8 S ← S ∪ {n}</formula><p>The choice of "keeping" the edges with lower delays, regardless of their costs, was found sensible here as this ensures a wider range of possibilities on higher levels, not restricting the solution space too much. Other decision criteria, like one based again on the score formula, could be used here, too. Not explicitly discarding one edge but keeping information about both was also considered but eventually judged as not being practical, as this would result in large amounts of additional data on higher levels which would ultimately defeat the purpose of the Multilevel Refinement approach. <ref type="figure">Figure 3</ref>.1 shows an example of two nodes, u and v, being merged. All edges connected to the two merged nodes are inspected. In the example we assume that the minimum delay from the source to node 1 plus the delay of the path to v exceeds the delay bound, causing the edge {1, u} to be removed from the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An example</head><p>The edges {2, u} and {4, v} pose no problems. They are inherited identically by the new node n. In case a node is connected to both merged nodes, like 3 is in the example, the edge with the lower delay is kept, as explained. A detailed example of what additional information was stored by our implementation of the algorithm will be given in Section 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Solving the highest level</head><p>The coarsening phase ends when no more nodes can possibly be merged. This means that no edges between non-source nodes are present in the graph anymore, leading to a graph like the one in <ref type="figure">Figure 3</ref>.2. It is now of course rather trivial to construct a valid solution on this highest level, which is therefore done via Algorithm 3.5.</p><p>The only problem here is that, due to the limiting effect of the coarsening to the solution space, it is possible that some terminals are not connected to the rest of the graph at all anymore. For those, a special solution has to be found. We decided to add a so-called "virtual edge" to the graph, which does not really exist in the original graph, but represents the cost and delay of the shortest delay path from the node to the source in the original graph. As the node itself most likely does not exist in the original graph, a random one of its sub-nodes is selected and its shortest delay path used.   </p><formula xml:id="formula_10">1 V T = S ∪ {s}; 2 E T = ∅; 3 for i ∈ S do 4 if {s,i} ∈ E then 5 E T ← E T ∪ {s,i}; 6 else 7 p ← P P 0 (s, i);</formula><p>// shortest delay path from the original problem</p><formula xml:id="formula_11">8 E T ← E T ∪ {s,i}; 9 C({s,i}) ← C * (p); 10 D({s,i}) ← D * (p); 11 end if 12 end for 13 T ← (V T , E T );</formula><p>These virtual edges are saved in a special way and later removed at the end of refining (right before the last improvement phase), if they are still present in the graph, and replaced by the path they represent. In doing so, we of course also take care not to create a cycle in the solution tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Refinement phase</head><p>The refinement phase is the final phase of an iteration of the algorithm. All changes made during coarsening are undone, to finally arrive back at the original graph on level 0. The basic algorithm for this phase is described in Algorithm 3.6.</p><p>When undoing changes in the graph, it is important to also make the necessary adjustments to the solution to reflect those changes. For example, when a merged node is split into its two sub-nodes again, and the node is present in the tree, we also have to replace the node in the tree with the sub-nodes. Additionally we have to add the edge connecting the two nodes, as well as re-connect all adjacent edges of the merged node to its two sub-nodes (depending on the sub-node to which the respective edge was originally connected). This is demonstrated with an example in <ref type="figure">Figure 3</ref>.3.</p><p>Looking at the algorithm you will notice that after undoing the changes of each level a repair algorithm is executed. This was necessary as, even with several measures in place to keep higher level representations as accurate was possible, we could not completely avoid the possibility of creating invalid solutions on higher levels without too large performance drawback. In this step during refinement we would therefore check all terminals for their delay to the source, repairing parts of the tree where necessary.</p><p>As the final part of the refinement of each level, there is also an improvement phase with a Algorithm 3.6: refine() Purpose: Refines the coarsened graph back to its original form, also transforming and improving the solution tree while doing so. Input: The current level l of the graph. b) The tree after the merge operation is undone. The gray edge is only part of the graph, not of the tree. Since it has got a different cost and/or delay than the edge on the higher level it is clear that the edge to the other node has to be the one represented by the higher-level edge. Since 4 is not connected to the merged node on the other level, edges to it are ignored when undoing the merge operation on the tree. local search heuristic trying to enhance the solution on the current level. Next to the coarsening, this is the most crucial part of the algorithm, as simple refinement of the coarse solution would only rarely lead to a good overall solution directly. Therefore we implement a variant of the Key Path Improvement heuristic, as explained in <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b34">35]</ref>, to be executed after each refinement iteration.</p><formula xml:id="formula_12">1 while l &gt; 0 do 2 l ← l − 1; 3 changes ← changes between G l and G l+1 ;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Key Path Improvement heuristic</head><p>The Key Path Improvement heuristic (KPI) originates from the fact that any solution of the Steiner Problem (and, therefore, also the RDCSTP) can be viewed in terms of its key nodes. A key node in this context is a node which is either a terminal (or the source), or a Steiner node with a degree of at least 3. Key paths are then all paths connecting two key nodes, without including a third one. They therefore consist of two key nodes at the end points, and an arbitrary number (possibly 0) of Steiner nodes of degree 2 in between. <ref type="figure">Figure 3</ref>.4 contains an example.</p><p>With these basic definitions in mind, the KPI now consists of first finding all key paths contained in a tree, and then for each of them removing it from the tree and reconnecting the two resulting components with each other as cheaply as possible. The delay constraint of course has to be minded here, too. Algorithm 3.7 gives an overview of the approach. Note that it is possible that no valid connection can be found after a key path has been removed on higher levels -most notably, when a virtual edge is removed. In these cases, we just revert to the previous state.</p><p>Also note that the improvement function is called only once per level. In a typical local search heuristic the improvement would be executed iteratively until a local optimum is reached. However, experimental results showed that this would lead to worse results than obtained by the variant used here. Apparently, the performance loss due to the additional time spent in improvement outweighs the possibly better solution quality in the short term. It could also be the case that such heavily optimized solutions in general present worse starting points for subsequent iterations of the Multilevel Refinement heuristic.</p><p>The method by which cycles are detected and removed when adding the new path is outlined in <ref type="figure">Figure 3</ref>.5. Before the path is added, the nodes of the two components are marked. Then, all visited nodes in the path are marked. Once a new edge is added to the tree the algorithm u ← the endpoint of path which is farther from s;</p><formula xml:id="formula_13">6 maxCost ← C * (path); 7 E T ← E T \ path; 8</formula><p>comp2 ← all nodes that can be reached from u in T ; When such a cycle is detected, the algorithm then backtracks from the newly reached node along the edges it was previously connected to, adding up the delays. Once the new path to the node would increase the delay from the source to the node, or once a node already marked as visited in the path is reached, the last edge that was looked at is removed and the cycle thereby resolved.</p><p>In <ref type="figure">Figure 3</ref>.5, a) shows the initial situation, the dashed path should be added to the tree to re-connect the source to the separate component at the top. In b), when the first edge {s, 3} is added, the algorithm detects that 3 was already part of the source component and that a cycle has therefore been created. In c), it backtracks along the edge {3, 2} which previously connected 3. It determines that the new delay for 2 would be lower than the previous delay (6 &lt; 7). Edge {3, 2} is therefore kept in the tree and the algorithm backtracks further. Inspecting edge {2, 1}, it detects that the new route via 3 and 2 would increase the delay to node 1. Therefore, edge {2, 1} is removed, resolving the cycle. If a cycle is created in the other component the process is analogous.</p><p>The getComponentSCP function used in the above explanation of the Key Path Improve-ment algorithm denotes a function which computes the shortest path between two components while minding the delay bound. This is a slightly modified version of the so-called Shortest Constrained Path problem, which is known to be N P-hard. Luckily, <ref type="bibr" target="#b35">[36]</ref> describes a pseudo- polynomial algorithm for it which could be adapted to our purposes here. The detailed imple- mentation will be explained in Section 4.4. Note that we pass the removed path's cost to the function. This is done to optimize the algorithm's performance by only considering the paths that would improve the solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Asymptotic runtime</head><p>Before executing practical tests for obtaining empirical performance data, we are also interested in the theoretical asymptotic runtime of a single iteration of the algorithm. We call the number of nodes N = |V | and the number of edges M = |E|. For (nearly) complete graphs, M = O N 2 will hold, which is the assumption we make in the following analysis. However, in many practical problem instances, the number of edges per node can be more seen as constant, M = O (N ), or increasing logarithmically.</p><p>The overall runtime of one iteration is of course the sum of the time needed for coarsening, solving the problem on the highest level, and refining. We label these times as</p><formula xml:id="formula_14">T O = T C + T S + T R .</formula><p>For coarsening (cf. Algorithm 3.2), the number of nodes will approximately be halfed on every level. Therefore, the maximum level L = O (log N ). In each level, we first retrieve all edges in a sorted list, which has runtime O (M i log M i ) (for sorting), where M i is the number of edges on level i.</p><p>Then we go through the list, merging O (N i ) times, where each of these merges takes (for a complete graph) O (N i ), with N i ≈ N 2 −i being the number of nodes on level i.</p><formula xml:id="formula_15">Since M i = O N 2 i</formula><p>, the whole runtime of each level of the coarsening phase will be O</p><formula xml:id="formula_16">N 2 i log N i + N 2 i = O N 2 i log N i .</formula><p>The level i goes from 0 to L = O (log N ), resulting in the following term for the overall runtime of the coarsening phase T C :</p><formula xml:id="formula_17">log N N 2 2 −2i log N 2 2 −2i = i=0 log N N 2 i (2 log N − 2i log 2) = i=0 1 4 2N 2 log N 1 + 1 4 + 1 16 + · · · − 2N 2 log 2 1 4 + 1 8 + · · · = 2N 2 log N 2 O (1) = O N 2 log N T C = O N 2 log N</formula><p>For the runtime of solving the problem on the highest level (cf. Algorithm 3.5), the worst case upper bound would be when nearly all nodes are still present on the highest level, and nearly all terminals need to be connected to the source via long virtual edges. The runtime would then be T S = O N 2 . As even this crude approximation is below the runtime of the coarsening phase, we do not need to search for a better upper bound.</p><p>More interesting here is the refinement phase (cf. Algorithm 3.6). There are of course the same number of levels as in the coarsening phase, i.e., O (log N ). As we also know from the coarsening phase, the simple refinement (without improvement) takes O N 2 overall (since there is no sorting involved). Calculating the runtime of the improvement phase (cf. Algo- rithm 3.7) is more complicated. Obtaining all key paths takes O (N i ), as there are O (N i ) key paths in the tree. The most expensive operation in the improvement heuristic is finding the short- est constrained path (SCP) between two nodes, the exact variant of which takes O (BM i ), where B is the delay bound. As this is done for each of the O (N i ) key paths, we get:</p><formula xml:id="formula_18">N i ≈ N 2 −i , M i ≈ N 2 i log N BN 3 2 −3i = i=0 log N BN 3 i = i=0 1 8 1 log N +1 BN 3 1 − 8 1 − 1 8 = BN 3 8 7 − 8 7 · 8 log N +1 = O BN 3 T R = O BN 3</formula><p>Therefore, under the premises stated at the start of the section, we see that most of the runtime in the asymptotic case will be spent in the refinement phase, resulting in an overall runtime of</p><formula xml:id="formula_19">T O = O N 2 log N + N 2 + BN 3 = O BN 3 .</formula><p>This runtime is at least a vast improvement compared to exact algorithms for an N P-hard problem, as it is only polynomial, not exponential, in the number of nodes. However, the fact that the runtime will depend on the delay bound B is worrying, as simple scaling of all delays by some factor should normally not influence the algorithm. This is a problem of the exact method for finding an SCP between two components, which loops over all possible delays and finds the shortest path for each of them.</p><p>To mitigate these problems a different, heuristic algorithm was implemented for finding SCPs. This was a simple implementation of Dijkstra's algorithm <ref type="bibr" target="#b36">[37]</ref>, adapted to include de- lay bounds and to be suitable for computing the SCP between whole components. It will be described in detail in Section 4.4. The runtime for this algorithm is the same as for Dijkstra's al- gorithm itself (implemented with d-ary heaps), namely O (M log N ) <ref type="bibr" target="#b37">[38]</ref>. Using this algorithm instead of the exact variant therefore leads to an overall runtime of</p><formula xml:id="formula_20">T O = O N 2 log N + N 2 + M log N = O N 2 log N .</formula><p>Here, the runtime of the refinement phase no longer dominates the overall runtime, which is now also determined by the coarsening phase's runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>24</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CHAPTER 4</head><p>Implementation This chapter discusses some of the details of our implementation, too specific to be mentioned in the discussion of the general algorithm. Especially, particular data structures that were intro- duced, detailed implementations of some algorithms and parameters introduced to the algorithm are explained.</p><p>The algorithm was implemented in a program using an existing C++ framework for the RDCSTP, provided by <ref type="bibr" target="#b38">[39]</ref>. This framework already included the preprocessing described in <ref type="bibr" target="#b7">[8]</ref> for the Rooted Delay-Constrained Minimum Spanning Tree Problem. Also included were some of the preprocessing techniques described in <ref type="bibr" target="#b8">[9]</ref>. An existing construction heuristic was then used to create the initial solution for improve- ments. Although it would have easily been possible to use the Multilevel algorithm both for constructing and subsequent improvement, having an existing solution to compare against was considered favorable.</p><p>The construction heuristic used had a simple approach, iteratively adding shortest con- strained paths to all terminals, as first introduced by <ref type="bibr" target="#b3">[4]</ref>. Despite of the simple approach, this still turned out to find an optimal result in several cases for small instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Additional data structures</head><p>In the form described in Section 3, the algorithm would store too little information during coars- ening to be able to reliably find valid solutions on higher levels. Especially, copying unmodified edges to higher levels while removing those between merged nodes from the tree would result in much too low delays for paths on higher levels, letting too many solutions seem valid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The dmax property</head><p>There are actually two different problems with this naive approach. The first problem is that reaching a node on a higher level within the delay bound is not enough. It only means that you reach the nearest of the contained nodes within the delay bound, not all of them. We therefore needed a measure of the extra delay within a node we had to consider when connecting it to the solution tree.</p><p>To solve this problem, we introduced a dmax property for all nodes in the graph. This property is only used for nodes on higher levels, which already contain several other nodes due to merging, and defaults to 0 otherwise. It stores the maximum delay on the path between any two terminals contained in the node. Since Steiner nodes do not have to be connected to in the tree if they would be leaves, they are not taken into account here.</p><p>However, on the whole these were just approximations of the real inner structure of the node. In general, a single value cannot represent all possible configurations in which a node can be added to a tree and much more complex data structures would have been needed. We therefore opted for keeping this as a heuristic measure and accepting that solutions for higher levels could in reality sometimes slightly violate the delay bound. Along with other performance-related changes, discussed in Section 4.4, this resulted in the necessity of executing a repair algorithm during refinement.</p><p>A value for this property is computed whenever a new merged node is created, based on the dmax values of the merged nodes. A practical example will be given later in this chapter.</p><p>This property is then always used when determining whether a connection from the source to a node forms a valid part of a solution. In practice, this means that the delay bound for an individual node is permanently decreased by the value of its dmax property.</p><p>The additionalDelays data structure</p><p>The second problem with the naive approach is that the delays of edges contained in merged nodes would be ignored when computing the delay of a path leading across such merged nodes. For illustration consider the exemplary merge operation in <ref type="figure">Figure 4</ref>.1. Once the nodes u and v are replaced by n and all edges reconnected, the question remains what delays to set for the new edges to n. If we just use the same delays as before, the delay of {u, v} is completely disre- garded, leading to wrong results when, e.g., connecting 1 and 3 via n. This would make it very likely that invalid solutions are created on higher levels, as the delays of paths are considerably underestimated.</p><p>On the other hand, if we add the delay (or half the delay) of {u, v} to all surrounding edges, the delay to n itself will be wrong. Also, when connecting 1 to 2 via n, ignoring the delay of Algorithm 4.1: isFeasible() Purpose: Determines whether the given edge could be part of a valid solution on the current level. Input: An edge e, connecting the nodes u and v. Output: true, if the edge can be part of a valid solution; false otherwise.</p><formula xml:id="formula_21">1 pathU ← P G (u, s); 2 predU ← node next to u in pathU; 3 pathV ← P G (v, s); 4 predV ← node next to v in pathV; 5 delayU ← D * (pathV) + additionalDelays[v][predV][u] + u.dmax; 6 delayV ← D * (pathU) + additionalDelays[u][predU][v] + v.dmax; 7 return (min(delayU, delayV) + D(e)) ≤ B;</formula><p>{u, v} is really the right thing to do.</p><p>It is therefore obvious that the correct delays for the new edges would differ depending on the context in which we retrieve them. Since this cannot be done by simply setting some edge delay, we introduced the additionalDelays global data structure. This is a three-dimensional array which stores for each node and each pair of its neighbors the additional delay that will have to be added to the edge delays when connecting the pair of neighbors via the node. In our example, we would have three new entries:</p><formula xml:id="formula_22">additionalDelays[n][1][2] = 0; additionalDelays[n][1][3] = 3; additionalDelays[n][2][3] = 3;</formula><p>This assumes that we are on level 1 -otherwise we would have to take into account existing entries for u and v, as will be illustrated later in this chapter. Note also that additionalDelays is of course symmetric in the second and third indices, so we would really have to add six entries. However, for the sake of simplicity we assume here, and in the rest of the paper, that setting</p><formula xml:id="formula_23">additionalDelays[i][j][k] will automatically also set additionalDelays[i][k][j] to the same value.</formula><p>This information in additionalDelays is subsequently used in all places in the algorithm where the delay of a path is computed. As an example, Algorithm 4.1 contains the detailed implementation of the isFeasible function introduced in Section 3.3.</p><p>As explained there, the function analyzes whether the delay from s to either of the end nodes via the checked edge lies below the delay bound. However, as can be seen this necessitates additional checking of the additionalDelays data structure and the nodes' dmax values. For example, the delay from s to node u, delayU, is the sum of the delay from s to v; plus the additional delay within v, when connecting the previous node in the lowest-delay path to s with u; plus the dmax value of u, as the delay bound would have to be reduced by that value. The computation for delayV is analogous, the function min simply returns the minimal value of all its arguments. If this minimum is lower than or equal to the delay bound, the edge could still be part of a valid solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Memory size problems</head><p>As one can easily see, the memory size of the additionalDelays data structure necessarily is in the dimension of O N 3 . In practice, this becomes even worse as the additional nodes added during coarsening result in an overall factor of (2N ) 3 = 8N 3 . A naive implementation of the data structure therefore was not practical for larger instances, quickly running out of memory for instances of about 1000 nodes.</p><p>A first step to mitigate this problem was to "re-use" nodes when merging -instead of re- moving both merged nodes and adding a new one, we just "promoted" one of the merged nodes to the next level, adapting all its related information accordingly. When merging a terminal and a Steiner node, we thereby always kept the terminal, so this information would automati- cally always be correct. This re-using of nodes had no influence on the general algorithm, but made the implementation of several parts significantly easier. (For example, we also could now easily come up with a "contained" node for Algorithm 3.5 when solving the highest level.) It also helped to conserve a lot of memory for the additionalDelays data structure. However, on the other hand it necessitated "versioning" of its data, as entries could now vary according to the current level. Simply copying and storing the data structure for each level would of course almost eliminate the little decrease in memory size this approach afforded us.</p><p>In the end, we therefore resolved this problem by not using a complete three-dimensional array for all nodes, but an array containing two-dimensional arrays containing only entries for the neighbors of all nodes. Since, after preprocessing, even in complete graphs nodes were not connected to most other nodes (especially for larger instances), this resulted in a huge decrease in memory size. The versioning problem for different levels was further mitigated by using lists for each entry in the three-dimensional array, versioning each entry on its own and thereby only creating additional entries where really necessary. On the whole, this resulted in a large improvement of memory size that even allowed us to solve instances as large as 5000 nodes.</p><p>Of course, the new layout of the additionalDelays data structure required additional mea- sures when accessing the data structure. Algorithm 4.2 shows the function used for accessing the data structure. It uses a new data structure, additionalDelaysLookup, to find the real indices used for accessing the additionalDelays data structure. Also, to exploit the symmetry of the data structure, we only store entries for half of the table and therefore need to swap the indices if sup- plied in the "wrong" order. Only then the list of entries for these three nodes can be obtained. This list is then searched for the relevant entry for the current level. (New entries for higher levels are always prepended to the list.)</p><p>The function front here returns the first element of the list, where each element has the two properties level and delay. The function pop removes the list's first element. If the list does not contain a relevant entry, 0 is returned. Otherwise the entry's delay value is returned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4.2: getAdditionalDelay()</head><p>Purpose: Finds the additional delay to be taken into account when connecting two nodes via a third node. Input: Three nodes v, i and j. Output: The additional delay in v when connecting i and j via v.</p><formula xml:id="formula_24">1 i ← additionalDelaysLookup[u][i]; 2 j ← additionalDelaysLookup[u][</formula><note type="other">j]; 3 if i &lt; j then 4 swap i and j; 5 end if 6 list ← additionalDelays[v][i][j]; 7 while list not empty and front(list).level &gt; l do 8 pop(list); 9 end while 10 if list is empty then 11 return 0; 12 end if 13 return front(list).delay;</note><p>The changelog data structure Also not mentioned in the algorithm is the changelog data structure which was used to capture the changes that were made during coarsening. While, in principle, storing each level during coarsening and then dynamically computing the differences between them during refinement would be possible, logging just all operations and then undoing them in the reverse order saves both time and memory size in practice, while also keeping that part of the algorithm considerably simpler.</p><p>As not removing nodes from the graph (as long as you make sure to not treat them as termi- nals anymore) during coarsening makes little difference, we only added or deleted the relevant edges. Therefore, the changelog data structure just consisted of an array containing a list of changes for each level, where each change would simply store a flag for the type of operation, adding or deleting, and the data of the edge in question.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A detailed merge example</head><p>With these new insights into the inner workings of our implementation, we can now also revisit the merge example from Section 3.3 and discuss the additional information we would need to save there. Most basically, we would of course store each adding or removal of an edge in changelog. But apart from that, we would also need to update the additionalDelays data structure and the merged node's dmax value accordingly.</p><p>Consider the example in the following code would be used to update all the necessary data in additionalDelays as well as u.dmax. (Note that the dmax values of all nodes are automatically stored at the beginning of each level, so we do not need to take care of that here.)</p><formula xml:id="formula_25">if (isTerminal(u) &amp;&amp; isTerminal(v)) { u.dmax = max(u.dmax, v.dmax, D + min(u.dmax, v.dmax)); } i2 = additionalDelaysLookup[u][2]; i3 = additionalDelaysLookup[u][3]; i4 = additionalDelaysLookup[u][4]; additionalDelays[u][i2][i3] = D + getAdditionalDelay(u, 2, v) + getAdditionalDelay(v, u, 3); additionalDelays[u][i2][i4] = D + getAdditionalDelay(u, 2, v) + getAdditionalDelay(v, u, 4); additionalDelays[u][i3][i4] = getAdditionalDelay(v, 3, 4);</formula><p>The new dmax value of the merged node is computed in a way that ensures creating mostly valid solutions, while avoiding to limit the solution space too much. Note that the formula to use here for reliably preventing the property value from being too small in certain instances would be D + u.dmax + v.dmax. However, as using this formula would lead to coarsening stopping much earlier, due to the high resulting dmax values, this compromise between correctness and flexibility was adopted.</p><p>For computing the new additionalDelays entries from the existing ones, there are simply two cases. Either the two neighboring nodes are connected to the new node with edges that belonged to the same previous node (u or v) -in which case we just copy the corresponding entry for the previous node, as it is done for the delay from 3 to 4 in the example. (If both nodes would have been connected to u, we would not have had to do anything.) Or the edges belonged to different nodes (as they did in the two other cases in the example), so we have to add both the delay of the merged edge and the two entries for the respective additional delays in u and v to obtain the correct new additionalDelays entry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Parameters</head><p>The algorithm was originally built with a number of parameters, to be able to flexibly adapt some of its aspects and see what settings work best. The following parameters were introduced: randBoost As already mentioned in Section 3.3, this parameter controls the influence of a random factor when choosing the edges to merge during coarsening. When set to 0, the complete algorithm is deterministic, with the random factor removed. Values greater than 0 are used as the random factor's variance, leading to more randomized edge selection with increasing randBoost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>treeBoost</head><p>This parameter, too, was already mentioned while discussing edge selection during coars- ening. It controls the influence of the previous solution on edge selection, as the scores of all edges that are present in the current tree are divided by this parameter. Therefore, the previous solution will have no influence when this is set to 1, values greater than 1 will make the selection of edges from the previous solution more likely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>twoTermBoost</head><p>This parameter is one of the two parameters that are used to boost edges based on the types of nodes they connect in edgeTypeBoost(e). When positive, the scores of all edges that do not connect two terminals are multiplied by this value, resulting in edges between two terminals being merged earlier (unless the parameter would be lower than or equal to 1). When negative, on the other hand, edges not connecting two Steiner nodes are multiplied by the absolute value of the parameter. When set to 0, this parameter is not used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>mixedEdgeBoost</head><p>Similar to twoTermBoost, a positive value for this parameter means that all edges con- necting either two terminals or two Steiner nodes are multiplied by the value. This means that edges connecting a terminal and a Steiner node would be merged sooner. The effect of negative values is exactly the same as for twoTermBoost, and the parameter is also not used if set to 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>scpMode</head><p>As described in Section 3.6, we implemented two different algorithms for solving the SCP problem occuring in the KPI heuristic, one exact and one heuristic algorithm. The two variants are discussed in detail in Section 4.4. This parameter controls which of these two functions is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>minKPCost</head><p>This parameter stands for the "minimum key path cost" and can be used to restrict the amount of key paths being looked at in the KPI runs. Concretely, all key paths with a cost lower than this treshold are just carried over and never replaced. The parameter is specified in relation to the highest cost among all key paths. Therefore, a value of 0 means that all key paths will be looked at, while with a setting of 1, only the most expensive key path might be replaced. Values greater than 1 would effectively disable the improvement phase of the algorithm.</p><p>In Section 5.1 these parameters were then evaluated to see which settings would provide the best results, and what dynamics could be observed when varying instance size, delay bounds or other problem characteristics. Note that an examination of the exponents in the score formula from Section 3.3 was dropped due to time constraints. They were in our tests therefore always set to a value of 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Shortest Constrained Path algorithms</head><p>We now discuss the implementation details for the two mentioned algorithms for the Shortest Constrained Path problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Exact algorithm</head><p>As mentioned in Section 3.5, the pseudo-polynomial exact algorithm for solving the SCP prob- lem for two components employs a dynamic programming approach described by Gouveia et al. in <ref type="bibr" target="#b35">[36]</ref>, for finding the shortest constrained path between two nodes. Its adapted version is shown in detail in Algorithm 4.3. Here, the modified cost function</p><formula xml:id="formula_26">C (e) = 0 if e ∈ T C(e) otherwise</formula><p>is used, which ignores the cost of all edges that are already contained in the tree. The function getNeighbors returns all nodes that are connected to the given node in the tree.</p><p>The basic idea is to use Dijkstra's algorithm <ref type="bibr" target="#b36">[37]</ref> for finding the shortest path between two nodes, but restricting the paths to those up to a certain delay. Starting with this delay bound at 0 and gradually increasing it to the delay bound given by the problem we automatically get for each node the cheapest way of reaching it for each delay bound. Therefore, we additionally only have to remember the cheapest way we reached any node in the other component (starting from the source node and disregarding the cost of all edges contained in the tree) and eventually backtrack the path to the source from there.</p><p>Note that the check for a valid connection on line 23 of the algorithm only checks for the height in the component, not taking the possible additional delay in the reached node into ac- count. This was done to avoid the much more expensive complete check, which would need to completely traverse the whole component each time, but naturally leads to invalid solutions </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Heuristic algorithm</head><p>The heuristic variant of the algorithm, shown in Algorithm 4.4, takes a simpler approach which is just a slight adaption of Dijkstra's algorithm for finding the shortest path between two nodes <ref type="bibr" target="#b36">[37]</ref>. As can be seen it first marks all nodes as reachable with cost ∞ and only the source node s to be reachable with cost 0. Like in the exact algorithm, the modified edge cost function is used to ignore the costs of edges that are already part of the solution tree.</p><p>Then, similar to the normal variant of Dijkstra's algorithm, the costs of all neighbors of the source node are updated according to the cost of the edges that connect them, which is done iteratively for all reachable nodes, by ascending costs. The only difference to Dijkstra's original algorithm is that we make sure that a node can be reached within the delay bound before updating its cost. Also, we have again the same success criterion as in the exact algorithm, of reaching the other component of the tree while fulfilling the relaxed condition on the path delay plus the delay height from the reached node. In this case, however, we can now instantly return from the function as it is guaranteed that we will not be able to find a cheaper path to the component with this algorithm. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmarks and comparison</head><p>To evaluate the finished program, numerous tests were carried out, varying the given instance sizes and other characteristics. For each test, a single core of a Xeon E5540 processor with 2.53 GHz was used, where each core had up to 3 GB RAM at its disposal. The test instances were randomly created complete graphs with 100, 500, 1000 and 5000 nodes. There were 30 instances for each of these sizes. The costs and delays both varied between 1 and 99, inclusive, and were independently obtained from a uniform distribution. Some of the instances can be found at <ref type="bibr" target="#b39">[40]</ref>. For determining the set of terminals, a variable R was introduced, specifying the fraction of nodes that are terminals. For an instance with N nodes, the first N · R nodes in the graph were then marked as terminals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Evaluating parameters</head><p>In the first test runs carried out, we evaluated the parameters described in Section 4.3 to find the best settings for subsequent tests. The result values "imp.", "σ" and "n" are the (arithmetic) means over all 30 test instances for the specified test group.    In the tests for each parameter all other parameters were set to default values (influenced by preliminary test runs). These were:</p><formula xml:id="formula_27">N = 500 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_28">N = 1000 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_29">randBoost 0.2 treeBoost ∞ twoTermBoost 0 mixedEdgeBoost 0 scpMode 0 minKPCost 0</formula><p>The time limits used were 180 seconds for 500 node instances and 720 seconds for 1000 node instances. We executed ten test runs for each instance and each tested setting.     <ref type="table" target="#tab_3">Table 5.1 and Table 5</ref>.2 contain the results obtained for various values of the randBoost parame- ter. As can be seen, a small random factor generally improves the algorithm's results, the benefit of exploring more possible solutions seems to easily outweigh the benefit of reliably finding a local optimum (in which a deterministic algorithm will then of course be stuck).</p><formula xml:id="formula_30">N = 500 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_31">N = 1000 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><p>The table shows also that the best results are obtained by higher random factors for smaller instances than for larger ones. This, however, can be explained with the much larger number of iterations that could be executed on these instances, which would naturally favor higher random- ness. A general principle for more randomness in smaller instances does not seem to hold when examining the differences between different terminal node ratios at the same instance size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>treeBoost</head><p>In <ref type="table" target="#tab_3">Table 5.3 and Table 5</ref>.4, the results for different values of the treeBoost parameter are listed. Contrary to our expectations, the highest value for the parameter (equivalent to the edges of the N = 500   previous solution being always merged first) leads to the best results in almost all cases. For this parameter, the additional diversity introduced by lower parameter values does not seem to outweigh the benefits of exploring solutions "near" the current one.</p><formula xml:id="formula_32">R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_33">N = 1000 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>twoTermBoost</head><p>The results for the twoTermBoost parameter can be seen in <ref type="table" target="#tab_3">Table 5</ref>.5. While it shows a signif- icant influence of the parameter on the solution quality, the concrete influence does not seem to follow any kind of pattern, with negative values, positive values and 0 resulting in the best results for several test groups each.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>mixedEdgeBoost</head><p>Listed in <ref type="table" target="#tab_3">Table 5</ref>.6 are the results for different values of the mixedEdgeBoost parameter. The outcome was similar to that for twoTermBoost -while the setting clearly had some level of impact on solution quality, the concrete influence was as unpredictable as before, making opti- mization rather difficult.    <ref type="table" target="#tab_3">Table 5</ref>.7 shows a comparison of the results for the two possible settings of the scpMode param- eter -exact or heuristic. While we expected the runtime cost for the exact solution to explode for larger instances, leading to the heuristic variant delivering better results for those, this could not even be observed for 1000 node instances. While these large instances showed an increase in the number of iterations of up to 40% for the heuristic variant, this was clearly predominated by the better results obtained with the exact algorithm. Overall, there were no instances where the heuristic variant led to even slightly better results than the exact one.</p><formula xml:id="formula_34">N = 500 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_35">N = 1000 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><p>Of course, as discussed in Section 3.6, this result is also dependent on the delays being relatively small integers. By distributing the delays over a much larger range, or by allowing real values for delays, the relative performance of both settings could probably be changed. However, for real-world applications it is rarely the case that delays have to be allowed to be so fine-grained as to make such a wide range of possible delay values necessary.       minKPCost Statistics for the last tested parameter, minKPCost, are listed in <ref type="table" target="#tab_3">Table 5</ref>.8. Similar to the results for the scpMode parameter, the conceived performance improvements for higher values (i.e., inspecting less key paths) in no case outweighed the smaller improvements in solution quality. Moreover, the difference was even more pronounced for this parameter, with higher settings being faster by more than 1000% in some instances, but making the algorithm almost useless in improving the initial solution. This also illustrates the importance of the improvement heuristic for the overall solution quality. Due to the impressive performance of the KPI heuristic, it was also tested how it would perform alone, without the Multilevel framework, as a simple local search heuristic. The results are listed in <ref type="table" target="#tab_3">Table 5</ref>.9 (for 500 node instances). As can be seen, while the complete Multilevel algorithm is obviously superior, the KPI heuristic itself already leads to significant improvements to the originally created solution, and in much shorter time. It might therefore be a good option when a solution has to be found too quickly to use the whole Multilevel algorithm. As the KPI heuristic is deterministic, a longer runtime will not improve the solution quality, though.</p><formula xml:id="formula_36">N = 500 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_37">N = 1000 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_38">N = 500 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula><formula xml:id="formula_39">N = 1000 R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. σ n imp. σ n imp. σ n imp. σ n imp. σ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Automatic parameters</head><p>Based on the tests in Section 5.1, the parameters for final benchmarks and comparisons were determined. Due to the unequivocal results, scpMode was fixed to "exact", and minKPCost to 0.</p><p>For twoTermBoost and mixedEdgeBoost, the results were not meaningful enough to de- termine their best settings. Furthermore, it could be assumed that these two parameters would be especially closely coupled with each other. Therefore, additional benchmarks were executed for the 500 and 1000 node instances, varying both parameters at the same time. The results are illustrated in <ref type="table" target="#tab_3">Table 5</ref>.10. As can be seen, the results were not as random as previously suspected. An area of better results is clearly visible, with a difference of almost half a percentage point in the relative improvement to the initially constructed solution. It can also be seen that the "off" setting 0 for both parameters results in rather good solutions, but not the best. The parameters were therefore fixed to twoTermBoost = 3 and mixedEdgeBoost = −2 for all further tests.    For the last two parameters, a different solution was sought, which would both ensure that local optima were reliably found and that the algorithm would still explore other areas of the solution space afterwards. Therefore, varying parameters, which would automatically adapt to the current situation, were implemented. This approach was partly influenced by the work in <ref type="bibr" target="#b40">[41]</ref>, which describes a way to use such dynamic variations in algorithmic parameters to support both diversification and intensification when searching for solutions.</p><p>Algorithm 5.1 gives an overview of how this approach was implemented. After a certain number of consecutive iterations in which no new best solution was found, a variation of the parameters is started. When a new best solution is then reached, the parameters are again reset to their initial values and the limit for unsuccessful iterations is increased by 1 (to automatically adapt to larger time limits).</p><p>The exact way in which parameters are varied is illustrated in <ref type="figure">Figure 5</ref>.1. Three automatic modes were designed for the randBoost parameter and four for the treeBoost parameter, each of them testing a different balance between intensification and diversification. Keep in mind, though, that these automatic parameters are only used as long as several consecutive iterations do not find a new best solution.</p><p>In the auto 1 mode for the randBoost parameter, the parameter is first uniformly raised to 0.5 over the course of the first ten iterations. It is then further raised at twice the slope to 1.5 over the next ten iterations. In the following 20 iterations, this is mirrored to again reach a setting of 0 and start the cycle over from the beginning.</p><p>The auto 3 setting does the same in principle, but uses maxNoGain steps (instead of ten) for each phase. This results in faster variation at the beginning of the program runtime, and slower variation later on, helping to adapt to longer runtimes. Shown in the figure is the variation function when maxNoGain would have a value of 5 (i.e., the fifth time parameter variation is Here, GetRandom(σ) is the same function as in Section 3.3 -i.e., it returns a random num- ber, following a normal distribution with mean 0 and variance σ 2 . The result is a randBoost parameter roughly following the distribution shown in <ref type="figure">Figure 5</ref>.2, with values of about 0.5 being most common.</p><p>The auto 1 setting for the treeBoost parameter starts off at 5 in the first iteration with varied parameters (coming from ∞ before). It then steadily drops by 0.2 for each further iteration, therefore reaching 0 (or, rather, a minimal value slightly above 0) in the 26 th iteration and then remaining at that level, completely banning edges contained in the previous solution from coars- ening. The probability density function of the auto 2 randBoost parameter.</p><p>The auto 2 setting, on the other hand, varies the parameter continously between 0 and 3, by alternately dropping to 0 and then rising to 3, always at a rate of 0.2 per iteration. It starts off at a value of 2.8.</p><p>With the auto 3 setting for the treeBoost parameter, it is not varied in linear, but exponential segments. Starting at a value of 4, the parameter is first halved at each iteration until it reaches the value 0.03125 <ref type="formula">(   1   32</ref> ), and then doubled again at each iteration until it reaches 8. This is repeated periodically.</p><p>Finally, there was also a probabilistic setting for the treeBoost parameter, namely auto 4 (not shown in the <ref type="figure">figure)</ref>. This setting sets the parameter to ∞ with a probability of 50%, or to 1 or 0 with a probability of 25% each.</p><p>Results with automatic parameters <ref type="table" target="#tab_3">Table 5</ref>.11 and 5.12 show an overview of the results obtained with the automatic parameters for 500 and 1000 node instances. In these tests, both variables were varied at the same time to find possible correlations between their best settings. The values shown are the aggregations for one specific value of one parameter over all values of the other one -as no particular correlation could be found, a more detailed listing was not considered useful. All other parameters were set to the fixed values mentioned above.</p><p>As another note on the results, you will see that no standard deviations are listed for the re- sults. The reason for this is that, due to time and resource constraints, we were not able to execute the test runs more than once for each instance, thus providing not enough data to meaningfully specify standard deviations. Therefore, the results also cannot be considered statistically sound enough to make any definite statements. However, as they were on the whole very consistent, it can be gathered that our conclusions from them will at least be plausible.</p><p>Contrary to our hopes, it was not really possible to improve much on the previously best results. In the case of the treeBoost parameter, the results were considerably worse almost throughout with the automatic parameters, compared to the treeBoost = ∞ setting. Therefore, the automatic settings were dropped again for this parameter, and it was fixed to ∞ for all further tests.</p><p>The results were a bit better for the randBoost parameter. Even though the randBoost = 0.2 still showed about as good results as the automatic settings, at least two of the three automatic settings showed continously good results. Since fixed parameters are more sensitive to variations in instance size and runtime, the auto 1 setting was eventually chosen for all further tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">100 node instances</head><p>Even though instances with only 100 nodes can usually too easily be solved exactly to be a useful benchmark for heuristic algorithms, we were still curious how the algorithm would perform for such small instances. Especially, we here had the unique chance to also compare our algorithm to the exact solutions and thus see how much worse our solutions were, on average.</p><p>In the tests we used 30 different instances of the size. The delay bound and ratio of terminals were again varied, and 30 test runs executed for each instance and each delay bound and terminal N = 500     <ref type="table" target="#tab_3">Table 5</ref>.13: Results of the test runs with 100 node instances. "Construction" marks the results for the initial construction heuristic. "Mean" and "Best" represent the mean and best values obtained with the complete algorithm for each problem instance. For these three data sets, "opt." lists the number of instances in which the respective result was that of the optimum solution, and "avg." lists the average relative deficit compared to the optimal solutions. "σ" for the "Mean" results shows the average standard deviations across the 30 instances. ratio setting. The time limit for each run was set to 8 seconds, which sufficed for several hundred iterations. A summary of the results is shown in <ref type="table" target="#tab_3">Table 5</ref>.13. As can be seen, even the greedy initial construction heuristic accomplished to find the opti- mal solution for a number of problem instances, especially for low delay bounds and low number of terminals. (Remember that, since the construction heuristic is deterministic, it always yielded the same result for a given problem instance, so listing mean and best result separately would not be meaningful here.)</p><formula xml:id="formula_40">R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. n</formula><formula xml:id="formula_41">R = 0.1 R = 0.3 R = 0.5 R = 0.7 R = 0.9 B * imp. n</formula><p>For the most interesting results, the mean values of the Multilevel Refinement heuristic, the results are also rather promising. On average, the solutions obtained tend to be worse than the optimal solutions by about two to seven percent. A clear trend is that the solutions tend to get relatively worse for higher delay bounds and higher number of terminals.</p><p>The last columns, listing the comparison of the best results obtained for each instance, are also interesting. It shows that for about half of the instances in which a solution was reached, the solution was not reached reliably. It can therefore be concluded that executing the algorithm on a problem multiple times has generally a good chance of finding better values than just running the algorithm once, but with a higher time limit. This means that, e.g., wrapping the algorithm in a GRASP heuristic might be a promising area of further research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">5000 node instances</head><p>To test how well the algorithm can deal with very large instances, it was also used (with the aforementioned parameter settings) on 30 instances with 5000 nodes. In these tests it really showed that the program reached its limits, needing several hours to more than a day for the desired 100 iterations per test run and also almost completely using up the available RAM.</p><p>Due to these long runtimes and our limited resources we were not able to run tests in the re- quired quantity to arrive at statistically sound results. A detailed listing of the results is therefore omitted here. They were however also very promising for these large instances, with the algo- rithm still achieving average improvements of ten to 15 percent compared to the construction heuristic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Comparison to other heuristics</head><p>After optimizing the parameters, the algorithm was compared to competing algorithms for this problem. The choice for the competitor fell on the Scatter Search and Path Relinking algorithm with Variable Neighborhood Descent improvement (SSPR-VND), discussed in <ref type="bibr" target="#b18">[19]</ref>. This algo- rithm was selected since it is not only one of the most recent and most successful algorithms for the RDCSTP, but has also benchmark data with well-documented instances publicly available.</p><p>As in the original paper, the time limit was set to 60 seconds CPU time for all test runs (although this was far more than needed for these small instances). To obtain meaningful results, 30 test runs were executed for each instance and delay bound. As solving the Steiner Problem without delays is a different problem, with its own well-suited algorithms, the tests for the delay bound ∞ were dropped and therefore only those for ∆ 1 = 1.1 × Delay(T OPT ) and ∆ 2 = 0.9 × Delay(T OPT ) executed. As used in the source, Delay(T OPT ) here stands for the maximum delay of a path to the source in the solution to the problem without delay bound. <ref type="table" target="#tab_3">Table 5</ref>.14 shows the results of this comparison. "Mean" is the arithmetic mean of the solution tree costs of all 30 runs for the given test instance and delay bound, "Best" is the best result obtained for it. σ denotes the standard deviation of the solution tree cost. "Nr." marks the instances, as used in the referenced paper. "Opt." lists the costs of the optimal solutions for each problem instance. The best mean costs for each instance are marked in bold, results marked with an asterisk signify the optimal solution for an instance.</p><p>Before reviewing the results it should be noted that the appropriateness of these test instances as benchmarks for RDCSTP heuristics can be disputed. As the instances are all very small - varying between 50 and 100 nodes -, all these problem instances could as well be solved with exact algorithms, especially in the 60 seconds used for testing. Benchmarks with much larger instances would be considerably better suited for comparing these heuristics, but no existing benchmark data for such instances could be found. Choosing a delay bound that is large enough to not constrain the optimal solution at all (like done with the ∆ 1 delay bounds) could also be considered a distortion of the core problem.</p><p>It has also to be noted that several of the retrieved test instances seemed faulty, or maybe the listed delay bound wrong. Instance B02 seemed completely defective, while the optimal results for the ∆ 2 instances were in several cases worse than the ones obtained by the SSPR-VND algorithm according to the paper. These tests were therefore excluded from the comparison and the SSPR-VND column marked with dashes. The unavailable result for instance B14 with the ∆ 2 delay bound, however, is due to the SSPR-VND algorithm not finding any valid solution.</p><p>The optimal solutions for the ∆ 1 delay bounds were taken from the reference paper, while the optima for the ∆ 2 delay bounds were computed with the Layered Graph algorithm in <ref type="bibr" target="#b23">[24]</ref>. A further demonstration of the inappropriateness of these benchmark instances was that this computation was possible in a few seconds in nearly all cases, with only one instance taking more than the one minute allowed for the tested heuristics.</p><p>The results themselves look very promising for the Multilevel Refinement heuristic. While the easiness of the problems lead to results being tied (with both algorithms reliably finding the global optimum) in the majority of cases, the algorithm described in this paper showed slightly better results on the whole, even though both algorithms "won" in several instances. A short summary of the results is given in <ref type="table" target="#tab_3">Table 5</ref>.15.</p><p>Concretely, when summing up the relative advantage or disadvantage of the Multilevel Re- finement heuristic in each test instance, the summed advantage is 2.62% across all instances (2.22% in the ∆ 1 instances and an almost-tie in the others). Additionally, the Multilevel Refine- ment heuristic reliably finds a solution if one exists (even when disregarding the initial solution), while the SSPR-VND heuristic failed to do so in one tested problem instance.</p><p>On the whole, these test results indicate that the Multilevel Refinement approach followed in this paper is not only a competitive, but even slightly superior alternative to existing techniques for the RDCSTP. However, as indicated above, further tests have to assess the relative advantage of either algorithm in larger test instances, as these are the main targets of heuristic algorithms.   <ref type="table" target="#tab_3">Table 5</ref>.15: Summary of the comparison in <ref type="table" target="#tab_3">Table 5</ref>.14. "solv." lists the number of instances that could be solved in each category by each algorithm. The values in "opt." show for how many instances the algorithms always found the optimal solution, with the value in parantheses being the number of instances where they found it at least once. The "sum" column lists the summed relative advantage of the Multilevel Refinement algorithm, with negative values signifying an advantage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>54</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CHAPTER 6</head><p>Conclusions and Future Work</p><p>In this thesis we implemented an algorithm based on the Multilevel Refinement meta-heuristic for the Rooted Delay-Constrained Steiner Tree Problem. This problem, which is also known as the Multicast Routing Problem With Delays, has been proven to be N P-hard. Our algorithm was developed in the form of an Iterated Multilevel Refinement heuristic to be used as an im- provement heuristic for an existing solution. Since the previous solution was only used in a single spot in each iteration without checking its validity, the algorithm could also be used as the initial construction heuristic, with additional improvement afterwards.</p><p>In the algorithm, we first merged nodes based on the cost and delay of their connecting edges, preferring ones with lower cost and delay. Thus, we iteratively created smaller graphs representing higher levels of abstraction of the original problem. In doing so we also saved the additional delays hidden in these merged nodes when connecting other nodes to them. This was done to make the creation of mostly valid solutions on higher levels possible without restricting the solution space too much. A solution tree was then created for the trivial problem on the highest level. Finally, the combined nodes were separated again in reverse order, stepping down again in the multilevel hierarchy. On each level we also executed an improvement heuristic on the solution in this phase. The Key Path Improvement heuristic was chosen for this, leading to considerably improved results. For the N P-hard problem of finding the shortest constrained path between two tree components, which is encountered in that improvement heuristic, we employed a well-known exact pseudo-polynomial dynamic programming approach.</p><p>Since initial test results were promising, we introduced additional parameters for the algo- rithm to further improve its performance. These showed to have a significant impact on the constructed solutions, and meaningful settings resulted in a further increase of solution quality, as benchmarks demonstrated. We also showed that the algorithm has an asymptotic runtime of T = O BN 3 , which roughly corresponded to the benchmark results. Finally, we demonstrated in a test against another algorithm, which used a Scatter Search and Path Relinking approach, that our algorithm can compete well with comparable algorithms, showing on the whole slightly better results for the tested instances. In contrast to the other 55 algorithm used in the comparison the Multilevel algorithm also reliably found a solution to all tested problems.</p><p>For lack of benchmarks for larger instances, however, this comparison was not as meaningful as would be desired. Still, we also demonstrated, without comparison to another algorithm, that our algorithm is capable of successfully handling even large instances of 5000 nodes with moderate resources, considerably improving the initially constructed solutions.</p><p>In future work, some of the underlying design decisions might be questioned and put to the test. For instance, we currently only merge each node once at each level, and never merge the source node. These restrictions were incorporated to simplify the algorithm, but better results might be possible when working around these limitations. Also, the explicit and implicit pa- rameters might be inspected more closely. For instance, a parameter restricting the number of merges on each level could be introduced and used to further improve solution quality. Also, an attempt could be made to examine the correlation between problem characteristics (instance size, delay bound, number of terminals) and the best algorithm parameters to produce more intelligent automatic parameters. Finally, improvement heuristics other than the Key Path Im- provement heuristic currently used could be tested in the refinement phase. The use of the Key Path Improvement heuristic in other meta-heuristics could also yield good results.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 . 1 :</head><label>11</label><figDesc>Figure 1.1: An example for an instance of the RDCSTP. a) The given graph with edge costs and delays. The nodes with thick borders are the terminals, s denotes the source node. b) The optimal solution tree for the delay bound B = 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 . 2 :</head><label>12</label><figDesc>Figure 1.2: An example of an application of the Multilevel Refinement heuristic on a graph problem. a) The original problem on level 0. Nodes which will be merged for the next level are encircled. b) The corresponding problem on level 1, after the shown merging operations were executed. c) The graph on level 2. We consider the graph in this form already a valid solution tree itself and therefore stop coarsening. d) The solution tree refined to level 1. Edges that were newly added to the tree are drawn heavier. These are the edges which previously connected the afterwards merged nodes on level 1 of the graph. e) After refining again to level 0, a solution for the original problem is obtained.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1</head><label></label><figDesc>penalty ← 1; // 1 does nothing, higher values are penalties. 2 numTerminals ← |S ∩ {u, v}|; // number of the edge's end nodes which are terminals 3 if twoTermBoost &gt; 0 and numTerminals &lt; 2 then 4 penalty ← penalty · twoTermBoost; 5 else if twoTermBoost &lt; 0 and numTerminals &gt; 0 then 6 penalty ← penalty · (−twoTermBoost); 7 end if 8 if mixedEdgeBoost &gt; 0 and numTerminals = 1 then 9 penalty ← penalty · mixedEdgeBoost; 10 else if mixedEdgeBoost &lt; 0 and numTerminals &gt; 0 then 11 penalty ← penalty · (−mixedEdgeBoost); 12 end if 13 return penalty;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 . 1 :</head><label>31</label><figDesc>Figure 3.1: An example for merging two nodes. a) A subsection of a problem graph, with the nodes u and v being merged. b) The selected edges to neighboring nodes which will be inherited by the new merged node. c) The resulting merged node n and its edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 . 2 :</head><label>32</label><figDesc>Figure 3.2: An example of what the graph might look like after the coarsening phase. a) The complete graph after coarsening. b) If a terminal is not connected to the source anymore, a virtual edge is inserted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Purpose: Creates a new solution T for the graph G on the current level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>4 forFigure 3 . 3 :</head><label>433</label><figDesc>Figure 3.3: An example of a merge operation in the graph being undone for the tree. a) The initial situation on the higher level. b) The tree after the merge operation is undone. The gray edge is only part of the graph, not of the tree. Since it has got a different cost and/or delay than the edge on the higher level it is clear that the edge to the other node has to be the one represented by the higher-level edge. Since 4 is not connected to the merged node on the other level, edges to it are ignored when undoing the merge operation on the tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 . 4 :</head><label>34</label><figDesc>Figure 3.4: An example of key paths in a tree. All nodes other than 4 and 5 are key nodes. The key paths are the edges {s, 1}, {1, 2} and {1, 3}, as well as the path from s to 6, including 4 and 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3 . 5 :</head><label>35</label><figDesc>Figure 3.5: An example of detecting and removing cycles. The dashed path should be added to the tree. Visited nodes in the path are marked by a thicker circle (there is no distinction made here between terminals and Steiner nodes). Likewise, edges that were added or accepted by the algorithm are drawn heavier. The numbers next to edges are their delays, edge costs are omitted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>9 p2</head><label>9</label><figDesc>← getComponentSCP(comp2, maxCost); 10 // On levels above 0, there might not be a valid connection. 11 if p2 exists then 12 E T ← E T ∪ p2; 13 detect and remove created cycles; 14 else 15 E T ← E T ∪ path; 16 end if 17 end if 18 end for checks whether the edge's end node (the one farther from the source) already was in the tree. If he already was in the same component as the source, a cycle has been created. The same applies when a node from the other component is reached, if it is not the first one. (This might be the case when the first node from the other component that was reached had too high delays to other nodes in the component.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 4 . 1 :</head><label>41</label><figDesc>Figure 4.1: An example illustrating the additionalDelays data structure. If the edge {u, v} in a) is merged-what should the delays look like in the resulting coarsened graph in b)? (The edges are only labelled with their delays in this example, as the edge costs are irrelevant here.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 4 . 2 .Figure 4 . 2 :</head><label>4242</label><figDesc>Figure 4.2: An example for merging two nodes. a) A subsection of a problem graph, with the nodes u and v being merged and infeasible or duplicated edges already removed. b) The resulting merged node (which is the old node u with altered data) and its edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Purpose: Finds the delay-constrained shortest path between two separate components of T in G. Input: comp2, the component that does not contain s; and maxCost, lower than which the connection's cost should be. Output: The cheapest valid path connecting the two components, if one exists. 1 // cost, pre and preDelay are 2-dimensional tables containing ∞ for all entries 2 // minC is a one-dimensional table containing maxCost for all entries 3 // reachable is an array of (empty) node sets 4 for i ∈ comp2 do 5 height[i] ← maximum delay to any other node in comp2; 6 end for 7 bound ← B − min i (height[i]); 8 vc ← maxCost; 9 insert s into reachable[0]; 10 minC[s] ← 0; 11 for b ∈ {0, 1, . . . , bound − 1} do 12 for i ∈ reachable[b] do 13 if cost[i][b] &lt; vc then 14 minC[i] ← min(minC[i], cost[i][b]); 15 for j ∈ getNeighbors(i) do 16 b 2 ← b+D({i,j})+getAdditionalDelay(i, pre[i][b], j); 17 if b 2 ≤ bound then 18 c 2 ← cost[i][b] + C ({i,j}); 19 if c 2 &lt; min(minC[j], cost[j][b 2 ]) and c 2 &lt; vc then 20 insert j into reachable[b 2 ]; 21 cost[j][b 2 ] ← c 2 ; 22 pre[j][b 2 ] ← i; preDelay[j][b 2 ] ← b; 23 if j ∈ comp2 and b 2 ≤ (B − height[j]) then 24 v ← j; vc ← c 2 ; 25 end if 26 end if 27 end if 28 end for 29 end if 30 end for 31 end for 32 if vc &lt; maxCost then 33 return path from s to v (determined by pre and preDelay); 34 end if being sometimes created on levels above 0. Therefore, this was another reason for including a repair mechanism in the refinement phase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Purpose: Finds a short delay-constrained path between two separate components of T in G. Input: comp2, the component that does not contain s; and maxCost, lower than which the connection's cost should be. Output: A cheap valid path connecting the two components, if one exists. 1 for i ∈ V do 2 cost[i] ← maxCost; 3 delay[i] ← ∞; 4 pre[i] ← i; 5 if i ∈ comp2 then 6 height[i] ← maximum delay to any other node in comp2; 7 end if 8 end for 9 cost[s] ← 0; 10 delay[s] ← 0; 11 bound ← B − min i (height[i]); 12 queue ← {s}; 13 while queue = ∅ do 14 i ← node with lowest cost entry from queue; 15 if i ∈ comp2 and delay[i] ≤ (B − height[i]) then 16 return path from s to i (determined by pre); 17 end if 18 remove i from queue; 19 for j ∈ getNeighbors(i) do 20 d ← delay[i] + D({i,j}) + getAdditionalDelay(i, pre[i], j); 21 if d ≤ bound and cost[i] + C ({i,j}) &lt; cost[j] then 22 cost[j] ← cost[i] + C ({i,j}); 23 delay[j] ← d; 24 pre[j] ← i; 25 if j / ∈ queue then 26 insert j into queue; 27 end if 28 end if 29 end for 30 end while</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>The following symbols are used in the tables representing results in this chapter: R Fraction of nodes which are terminals N Number of nodes (specifying a certain set of instances) B Delay bound used * Marks the column for the tested parameter imp. Relative improvement compared to the solution generated by the construction heuristic (in percent) σ Mean standard deviation of the imp. values n Number of iterations of the algorithm which could be executed</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>-</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>5 . 10 :</head><label>510</label><figDesc>Summarized results of the tests to determine the best settings for the twoTermBoost and mixedEdgeBoost parameters. Different columns represent different values for twoTermBoost, the rows differentiate between the mixedEdgeBoost settings. The values are the arithmetic means of the relative improvement over all test instances. Tested were all 500 node instances with delay bounds of 6, 16, 32 and 50, and all 1000 node instances with delay bounds of 6, 16 and 32. The ratio of terminals took the values 0.1, 0.3, 0.5, 0.7 and 0.9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>Purpose: Runs the Multilevel algorithm on G, adapting the parameters randBoost and treeBoost between iterations. 1 randBoost ← 0; 2 treeBoost ← ∞; 3 noGain ← 0; 4 maxNoGain ← 1; 5 while time limit not exceeded do 6 coarsen(); 7 solveCurrentLevel(); 8 refine(); 9 if new best solution found then 10 if noGain &gt; maxNoGain then 11 increment maxNoGain; 12 end if 13 noGain ← 0; 14 randBoost ← 0; 15 treeBoost ← ∞; 16 else 17 increment noGain; 18 if noGain &gt; maxNoGain then 19 vary parameters; 20 end if 21 end if 22 end while started during the program run). The auto 2 setting for the randBoost parameter (not shown in the figure) randomly varies the parameter according to the following formula: randBoost = 2 GetRandom(0.5)−1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 5 . 1 :Figure 5 . 2 :</head><label>5152</label><figDesc>Figure 5.1: The functions according to which the randBoost and treeBoost parameters are varied when using the various (deterministic) automatic settings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 5 .</head><label>5</label><figDesc>1: Results for different values of the randBoost parameter and 500 node instances.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 5 .2: Results for different values of the randBoost parameter and 1000 node instances.</head><label>5</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 5 .</head><label>5</label><figDesc>3: Results for different values of the treeBoost parameter and 500 node instances.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 5 .4: Results for different values of the treeBoost parameter and 1000 node instances. randBoost</head><label>5</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head>Table 5 .5: Results for different values of the twoTermBoost parameter.</head><label>5</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>Table 5 .6: Results for different values of the mixedEdgeBoost parameter. scpMode</head><label>5</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18" validated="false"><head>Table 5 .</head><label>5</label><figDesc>7: Results for different values of the scpMode parameter.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_21" validated="false"><head>Table 5 .</head><label>5</label><figDesc></figDesc><table>8: Results for different values of the minKPCost parameter. 

42 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_22" validated="false"><head>Table 5 .</head><label>5</label><figDesc></figDesc><table>9: Comparison between the Key Path Improvement heuristic (KPI) and the complete 
Multilevel Refinement heuristic (MLR) presented in this thesis. Shown in each case are the 
average relative improvements compared to the initially constructed solution. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_24" validated="false"><head>Table</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_26" validated="false"><head>Table 5 .</head><label>5</label><figDesc></figDesc><table>11: Test results for automatic and normal settings for the randBoost parameter. 

48 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_28" validated="false"><head>Table 5 .12: Test results for automatic and normal settings for the treeBoost parameter.</head><label>5</label><figDesc></figDesc><table>N = 100 

Construction 
Mean 
Best 

B 
R opt. 
avg. 
opt. 
avg. 
σ 
opt. 
avg. 

16 0.1 
5 
11.1% 
12 1.89% 
1.54 
23 1.59% 
0.3 
0 20.11% 
3 4.37% 
4.83 
8 3.28% 
0.5 
0 21.82% 
0 5.94% 
7.29 
1 4.53% 
0.7 
0 22.16% 
0 5.04% 
8.89 
0 3.82% 
0.9 
0 23.47% 
0 5.14% 
9.15 
0 4.04% 
1 
0 24.31% 
0 5.56% 10.66 
0 4.38% 
30 0.1 
2 
19.3% 
15 
3.1% 
2.83 
23 
1.1% 
0.3 
0 26.57% 
3 4.37% 
3.76 
8 3.18% 
0.5 
0 26.95% 
2 4.07% 
3.91 
8 2.99% 
0.7 
0 27.55% 
0 5.12% 
3.81 
1 4.09% 
0.9 
0 29.08% 
0 4.98% 
5.92 
0 3.74% 
1 
0 28.97% 
0 
5.1% 
5.66 
0 3.94% 
50 0.1 
2 14.68% 
11 2.27% 
1.45 
21 0.78% 
0.3 
0 23.55% 
3 3.43% 
1.4 
7 2.64% 
0.5 
0 28.95% 
0 4.54% 
2.41 
3 3.54% 
0.7 
0 30.31% 
0 4.22% 
2.97 
1 3.04% 
0.9 
0 30.83% 
0 5.06% 
4.21 
0 3.53% 
1 
0 31.28% 
0 6.08% 
2.85 
0 4.95% 
100 0.1 
2 18.36% 
13 2.53% 
0.92 
24 
0.8% 
0.3 
0 27.11% 
1 3.17% 
1.57 
11 
1.6% 
0.5 
0 29.59% 
0 4.32% 
1.04 
1 3.29% 
0.7 
0 31.04% 
0 5.62% 
1.47 
0 4.32% 
0.9 
0 
31% 
0 6.46% 
1.61 
1 5.25% 
1 
0 31.75% 
0 6.81% 
1.11 
0 5.93% 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_30" validated="false"><head>Table 5 .</head><label>5</label><figDesc></figDesc><table>14: Results from the test instances used in [19], compared to the results obtained there. 
∆ 1 specifies a delay bound of 1.1 times the maximum delay in the optimal solution to the 
problem without delays; ∆ 2 marks delay bounds of 0.9 times that value. 

53 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Steiner minimal trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilbert</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pollak</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">O</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="1968" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Steiner&apos;s problem in graphs and its implications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hakimi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="113" to="133" />
			<date type="published" when="1971" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reducibility among combinatorial problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karp</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Complexity of Computer Computations</title>
		<editor>R. Miller and J. Thatcher</editor>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1972" />
			<biblScope unit="page" from="85" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Multicasting for multimedia applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kompella</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">P</forename><surname>Pasquale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Polyzos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM &apos;92. Eleventh Annual Joint Conference of the IEEE Computer and Communications Societies</title>
		<imprint>
			<date type="published" when="1992-05" />
			<biblScope unit="page" from="2078" to="2085" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A fast and high quality multilevel scheme for partitioning irregular graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karypis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kumar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Sci. Comput</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="359" to="392" />
			<date type="published" when="1998-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A multi-level algorithm for partitioning graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hendrickson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leland</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC Conference 0</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page">28</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Coarsening, sampling, and smoothing: Elements of the multilevel method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Teng</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms for Parallel Processing</title>
		<imprint>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="247" to="276" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Variable Neighborhood Search and Ant Colony Optimization for the Rooted Delay-Constrained Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruthmair</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Parallel Problem Solving from Nature: Part II</title>
		<editor>R. Schaefer et al.</editor>
		<meeting>the 11th International Conference on Parallel Problem Solving from Nature: Part II</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="volume">6239</biblScope>
			<biblScope unit="page" from="391" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Solving Steiner tree problems in graphs to optimality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koch</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="207" to="232" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A fast algorithm for Steiner trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Markowsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Berman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="141" to="145" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A source-based algorithm for delay-constrained minimum-cost multicasting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parsa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM&apos;95. Fourteenth Annual Joint Conference of the IEEE Computer and Communications Societies</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="377" to="385" />
		</imprint>
	</monogr>
	<note>Bringing Information to People</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A delay-constrained least-cost multicast routing heuristic for dynamic multicast groups</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhengying</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bingxin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ling</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Commerce Research</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="323" to="335" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Dclc routing algorithm based on selective function. Mini-Micro Computer Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhengying</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bingxin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1267" to="1269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Bandwidth-delay-constrained least-cost multicast routing based on heuristic genetic algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhengying</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bingxin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erdun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer communications</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="685" to="692" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A path relinking approach for delay-constrained least-cost multicast routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghaboosi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haghigha</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools with Artificial Intelligence, 2007. ICTAI 2007. 19th IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="383" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A grasp heuristic for the delay-constrained multicast routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Skorin-Kapov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Telecommunication Systems</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="69" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A GRASP approach for the Delay-constrained Multicast routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Multidisplinary International Scheduling Conference (MISTA4)</title>
		<meeting>the 4th Multidisplinary International Scheduling Conference (MISTA4)<address><addrLine>Dublin, Ireland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="93" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Variable Neighborhood Descent Search Algorithm for Delay-Constrained Least-Cost Multicast Routing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kendall</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Learning and Intelligent OptimizatioN</title>
		<meeting>Learning and Intelligent OptimizatioN</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="15" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A hybrid scatter search meta-heuristic for delay-constrained multicast routing problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Intelligence</title>
		<imprint>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Optimum routing of multicast streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Noronha Jr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tobagi</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM&apos;94. Networking for Global Communications., 13th Proceedings IEEE</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="865" to="873" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Multicast problems in telecommunication networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leggieri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<pubPlace>Lecce, Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Università del Salento</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The steiner tree problem with delays: a tight compact formulation and reduction procedures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leggieri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Haouari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Triki</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<pubPlace>Lecce, Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Universita del Salento</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An Exact Algorithm for the Steiner Tree Problem with Delays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leggieri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Haouari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Triki</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Notes in Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="223" to="230" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A Layered Graph Model and an Adaptive Layers Framework to Solve Delay-Constrained Minimum Tree Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruthmair</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Conference on Integer Programming and Combinatorial Optimization (IPCO XV</title>
		<editor>O. Günlük and G. Woeginger</editor>
		<meeting>the 15th Conference on Integer Programming and Combinatorial Optimization (IPCO XV</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">6655</biblScope>
			<biblScope unit="page" from="376" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Stabilized Branch-and-Price for the Rooted Delay-Constrained Steiner Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leitner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ruthmair</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network Optimization: 5th International Conference, INOC 2011</title>
		<editor>J. Pahl, T. Reiners, and S. Voß</editor>
		<meeting><address><addrLine>Hamburg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011-06" />
			<biblScope unit="volume">6701</biblScope>
			<biblScope unit="page" from="124" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Stabilized Column Generation for the Rooted Delay-Constrained Steiner Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leitner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ruthmair</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VII ALIO/EURO-Workshop on Applied Combinatorial Optimization</title>
		<meeting>the VII ALIO/EURO-Workshop on Applied Combinatorial Optimization<address><addrLine>Porto, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-05" />
			<biblScope unit="page" from="250" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">In Multigrid methods: theory, applications, and supercomputing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brandt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Copper Mountain Conference on Multigrid Methods, held at Copper Mountain</title>
		<imprint>
			<publisher>Dekker</publisher>
			<date type="published" when="1987" />
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="page">35</biblScope>
		</imprint>
	</monogr>
	<note>Multilevel computations: Review and recent developments</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A multilevel approach to the travelling salesman problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walshaw</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="page" from="862" to="877" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Experimental analysis of heuristics for the stsp. The Traveling Salesman Problem and its Variations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johnson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mcgeoch</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="369" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A multilevel approach to the graph colouring problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walshaw</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SE10 9LS</title>
		<imprint>
			<publisher>Citeseer</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Multilevel Heuristiken für das Rooted Delay-Constrained Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berlakovich</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">; M</forename><surname>Ruthmair</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010-07" />
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Vienna University of Technology, Institute of Computer Graphics and Algorithms</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A Multilevel Heuristic for the Rooted Delay-Constrained Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berlakovich</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ruthmair</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Extended Abstracts of the 13th International Conference on Computer Aided Systems Theory</title>
		<editor>A. Quesada-Arencibia et al.</editor>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="247" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A Kruskal-Based Heuristic for the Rooted Delay-Constrained Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruthmair</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Computer Aided Systems Theory</title>
		<editor>R. Moreno-Díaz, F. Pichler, and A. Quesada-Arencibia</editor>
		<meeting>the 12th International Conference on Computer Aided Systems Theory</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">5717</biblScope>
			<biblScope unit="page" from="713" to="720" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Steiner&apos;s problem in graphs: heuristic methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Voss</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="45" to="72" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Solving Two Network Design Problems by Mixed Integer Programming and Hybrid Optimization Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leitner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Vienna University of Technology, Institute of Computer Graphics and Algorithms</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Modeling and Solving the Rooted Distance-Constrained Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gouveia</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Paias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharma</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="600" to="613" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A note on two problems in connexion with graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dijkstra</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische mathematik</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="269" to="271" />
			<date type="published" when="1959" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Network flows: theory, algorithms, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahuja</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Magnanti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Orlin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Prentice Hall</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">C++-Framework for Solving Delay-Constrained Tree Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruthmair</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Test instances for the RDCMSTP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruthmair</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="https://www.ads.tuwien.ac.at/~marior/instances/random/" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A hybrid GRASP with perturbations for the Steiner problem in graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ribeiro</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Uchoa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werneck</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INFORMS Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="228" to="246" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
