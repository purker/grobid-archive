<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Raab</surname></persName>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Unanticipated Context Awareness for Software Configuration Access using the getenv API</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Configuration files, command-line arguments and environment variables are the dominant tools for local configuration management today. When accessing such program execution environments, however, most applications do not take context , e.g. the system they run on, into account. The aim of this paper is to integrate unmodified applications into a coherent and context-aware system by instrumenting the getenv API. We propose a global database stored in configuration files that includes specifications for contextual interpretations and a novel matching algorithm. In a case study we analyze a complete Debian operating system where every getenv API call is intercepted. We evaluate usage patterns of 16 real-world applications and systems and report on limitations of unforeseen context changes. The results show that getenv is used extensively for variability. The tool has acceptable overhead and improves context-awareness of many applications.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The goal of context-oriented programming (COP) is to avoid the tedious, time- consuming and error-prone task of implementing context awareness manually, and instead adapt the application's behavior using the concept of layers <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">12]</ref>. Each layer represents one dimension of the context relevant to the application. Contextual values <ref type="bibr" target="#b26">[27]</ref> act as variables whose values depend on layers. A program execution en- vironment consists of the environment variables and key/value pairs retrieved from configuration files. A program execution environment can be tightly integrated with contextual values <ref type="bibr" target="#b20">[21]</ref>. Context awareness <ref type="bibr" target="#b4">[5]</ref> is a property of software and refers to its ability to correctly adapt to the current context. Our aim is to make applications context-aware that previously were not.</p><p>For example, an important context for a browser is the network it uses. In a different network, different proxy settings are required to successfully retrieve a web page. We want the browser to automatically adapt itself to the network actually present, i.e., make it context-aware in respect to the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Markus Raab</head><p>Institute of Computer Languages, Vienna University of Technology e-mail: markus.raab@complang.tuwien.ac.at</p><p>Although COP eases the writing of new software, there remains a huge corpus of legacy software that cannot profit from context awareness. Our paper aims at intercepting the standard API getenv in a way that COP-techniques are applied to unmodified applications. We focus on getenv because we found that it is used extensively. Our interception technique, however, does not make any assumption on the API. We recommend to specify the values and the context of the program execution environments separately. This configuration specification contains place- holders, each representing a dimension of the context:</p><p>[/phone/call/vibration] type=boolean context=/phone/call/%inpocket%/vibration</p><p>In this example, vibration is a contextual value of type boolean and %inpocket% a placeholder to be substituted in contextual interpretations. Thus, the value of vibration changes whenever inpocket changes. E.g., when a context sensor mea- sures body temperature only on one side of the gadget, it will change the value of %inpocket%. Thus, when the mobile phone is in the pocket, it will turn on vibration.</p><p>When the mobile phone is lying on a table, it will turn off vibration to prevent falling down when someone calls. If needed, users can even specify further context. For ex- ample, some users dislike the context-dependent feature as described. Our approach inherently allows users to reconfigure every parameter in every context. To turn on vibration if the phone is not in the pocket, we configure our device differently: In this paper we analyze the popular getenv() API. The function getenv() is standardized by SVr4, POSIX.1-2001, 4.3BSD, C89, and C99. Because of this standardization and ease of use it is adopted virtually everywhere, even in core li- braries such as libc. It allows developers to query the environment. Using standard getenv implementations developers have to act carefully: settings valid in the cur- rent context can differ from those received through getenv. To reduce the danger of assuming wrong context information we propose to use a context-aware implemen- tation. We implement it in the whole system by intercepting every getenv API call. Our contributions are:</p><p>• We allow unmodified applications to use contextual values. In these standard applications the developers did not initially think of context awareness.</p><p>• We conduct an extensive case study and analyze 16 applications and systems. These contributions are of practical relevance. While other approaches require code rewriting <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, our approach is suitable for legacy applications, flexible and open for extensions. We tackle the research question: "How can we integrate unmodified applications into a coherent, context-aware system?"</p><p>The paper is structured as follows: In Section 2 we elaborate on the background. In Section 3 we explain our approach and in Section 4 we evaluate it. The validity of the evaluation is discussed in Section 5. After considering related work in Section 6 we conclude the paper in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>Context-oriented programming (COP) enables us to naturally separate multi-dimen- sional concerns <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26]</ref>. In some sense it extends object-oriented programming. Activation and deactivation of layers belong to its main concepts. Every layer rep- resents a dimension of context that cuts across the system. All active layers together form the context the program currently is in.</p><p>The (de)activation of layers occur at any time during program execution. A cur- rently active stack of layers determines the context the program or thread is in. COP allows us to specify programs with adaptable, dynamic behavior. Later ap- proaches <ref type="bibr" target="#b13">[14]</ref> go beyond object-oriented programming: they support program con- struction with layers only. Furthermore, later work considers software engineering perspectives <ref type="bibr" target="#b23">[24]</ref> and modularity visions <ref type="bibr" target="#b12">[13]</ref>.</p><p>Tanter suggested a lightweight subset of COP: Contextual values. They are eas- ier to understand because they "boil down to a trivial generalization of the idea of thread-local values" <ref type="bibr" target="#b26">[27]</ref>. They are variables whose values depend on the current context. Contextual values originate from COP and naturally work along with the concepts of dynamic scoping and layers.</p><p>For newly written context-aware software, COP is a viable choice. For legacy software, however, rewriting seems unrealistic. So in this paper we introduce a new approach that does not require modifications of the application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EnvElektra</head><p>In our approach, we want to intercept every call to the getenv API. Whenever an ap- plication calls the API, we want to invoke a context-aware implementation instead. EnvElektra, which is our research tool, contains such a getenv() implementation. The implementation contains a novel matching algorithm for context awareness. When EnvElektra is installed and activated on a system, the matching algorithm will be used for every call of getenv() done by any application.</p><p>The basic idea of EnvElektra's getenv() implementation is as follows: First, it ensures that the data structure is up-to-date. Second, the matching algorithm cal- culates a new key for the parameter of getenv() using the context specification. Third, this key is searched in the data structure. With the found key, we recursively descend until every relevant context is considered.</p><p>The library LibElektra <ref type="bibr" target="#b20">[21]</ref> (shown in <ref type="figure">Fig. 1</ref>) maps the program execution envi- ronments (e.g., command-line arguments and configuration files) to the in-memory key/value pairs. LibElektra includes start-up code that initializes all key/value pairs from a key database. The key database is modular via plugins <ref type="bibr" target="#b17">[18]</ref>. The plugins allow us to use different syntax for configuration files. <ref type="figure">Fig. 1</ref> also depicts the EnvElektra architecture. The system with EnvElektra has to provide three artifacts (bold, blue boxes): (1) unmodified applications that be- come context-aware, (2) context specifications, and (3) context sensors for out-of- <ref type="figure">Fig. 1</ref> Architecture of EnvElektra. The common data structure is a set of key/value pairs (middle). Bold, blue boxes need to be provided by users of EnvElektra. is part of process layer (de)activation. In the remainder of this chapter we will explain the user-provided artifacts and the matching algorithm. Finally, we will give a full ex- ample demonstrating how the system works interconnected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Context Sensors</head><p>An essential issue to enjoy global, context-aware configuration access without mod- ifying the application is an out-of-process layer (de)activation. We will show why such context sensors require us to use a database.</p><p>The original function getenv() retrieves values from the environment. Inter- nally, it uses the data structure char ** environ. By design, environ is copied into every process and will not receive any external changes afterwards. Thus, environ cannot consider out-of-process changes and cannot be used in EnvElektra.</p><p>We prefer to use configuration files that are read by the application itself. Then security is correctly handled by the operating system. In EnvElektra the adminis- trator decides which configuration files are used, possibly with different syntax for each file <ref type="bibr" target="#b19">[20]</ref>. EnvElektra makes sure that all applications have the same global view of the system's configuration files leading to a consistently configured system. This way values returned by getenv() will not be different from values retrieved from configuration files. The configuration files are viewed as a key/value database suitable for getenv lookups.</p><p>Context sensors observe the system and change the database when they detect context changes. They are responsible to modify the layers accordingly. Context sensors write their layer information into /env/layer. The key /env/layer is part of the database and resides within one of the configuration files. The use of files en- ables out-of-process communication between context sensor and applications. Thus, context changes can have an immediate effect on applications. We identified two different kinds of context sensors to be used with our approach:</p><p>Information within the Database: Quite often, the necessary value is already present in the database. For example, in Linux many syscalls and the /sys-file sys- tem already provide much information. Using plugins, these sources are easily em- bedded within the database. Then we only need a symbolic link from /env/layer to the correct key. For example, if /env/layer/nodename points to /syscall/uname/ nodename, then %nodename% will resolve to the nodename as returned by the uname system call. In EnvElektra we mount plugins into any part of the hierarchy <ref type="bibr" target="#b17">[18]</ref>.</p><p>Context Sensor Daemons: In other cases, we implement a daemon, i.e. an ac- tive process, that updates /env/layer. Doing so, we can implement hysteresis, value transformations, and even complex feedback control systems. For exam- ple, to update %inpocket% a daemon measures the temperatures and modifies /env/layer/inpocket whenever we cross a threshold value. Changes in the data- base influence all processes across the whole system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Context Specification</head><p>Up to now, we have established a database that contains key/value pairs to be used in a getenv() implementation. We have to make the database context-aware with the layer-information present in /env/layer, e.g.:</p><formula xml:id="formula_0">/env/layer/inpocket = notinpocket</formula><p>Furthermore, we specify which key is used in which contextual interpretation:</p><formula xml:id="formula_1">[/phone/call/vibration] type=boolean context=/phone/call/%inpocket%/vibration</formula><p>Now, when an API accesses /phone/call/vibration, the lookup layer will search for /phone/call/%inpocket%/vibration. Layer interpretations are stored in the database below the key /env/layer. In this case the correct contextual in- terpretation of %inpocket% is notinpocket. Using more than one placeholder cre- ates several dimensions of variability. Late-binding is necessary so that unmodified software benefit from contextual features. EnvElektra needs to resolve its context awareness as late as possible, i.e., on getenv() calls.</p><p>For example, if a phone-call application executes getenv("vibration") it will look up /phone/call/vibration. Because of the context specification, we know we want the key /phone/call/%inpocket%/vibration instead. For the correct interpretation of %inpocket% we will lookup /env/layer/inpocket first. We get the value notinpocket for the layer %inpocket%. Thus, getenv("vibration") will return the value of /phone/call/notinpocket/vibration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Matching algorithm</head><p>The core of our approach is the contextual lookup within our alternative imple- mentation of the getenv API. In EnvElektra getenv() provides the context-aware variability. The essence of EnvElektra's getenv() implementation is:</p><formula xml:id="formula_2">char * getenv(char * key) { if(needsReload(conf)) { reloadConfiguration(conf); reloadLayers(conf); } return contextLookup(conf, key); }</formula><p>Context is not static but dynamically changes over time. Our approach sup- ports dynamic changes of context using reloadLayers() even though the original getenv implementation did not. The interception approach limits us to context- changes within getenv(): We cannot (de)activate layers at other places. Instead, we make sure that for every contextLookup() the correct context is used. The matching algorithm contextLookup() is recursively defined: The idea of the algorithm is: First, we look whether a context is specified for the key. If it is, contextLookup descends recursively after replacing all placeholders in the key. If it is not, a ordinary lookup will be used. The full implementation features namespaces, symbolic links and defaults <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Example</head><p>We present a full example that demonstrates recursion with several layers. Suppose a mobile phone is lying on the table in a building during a meeting. To simplify the example, we assign constant values to the layers:</p><formula xml:id="formula_3">/env/layer/inpocket = notinpocket /env/layer/inbuilding = inbuilding /env/layer/inmeeting = inmeeting</formula><p>In a real system, a sensor will continuously update the values. So far, we already discussed the layer inpocket. The layer inbuilding represents a value from a location context. Layers such as inmeeting are called virtual sensors <ref type="bibr" target="#b0">[1]</ref>. In this case the value of the layer is calculated by a sensor querying the person's schedule. The application running on the phone uses the following non-context-aware code:</p><p>char * use_vibration = getenv("vibration"); if (!strcmp(use_vibration, "on")) {/ * activate vibration * /} We add context awareness with the following specification:</p><formula xml:id="formula_4">[/phone/call/vibration] type=boolean context=/phone/call/%inbuilding%/vibration [/phone/call/inbuilding/vibration] type=boolean context=/phone/call/%inpocket%/%inmeeting%/vibration [/phone/call/notinbuilding/vibration] type=boolean context=/phone/call/%handsfree%/vibration</formula><p>Due to lack of space, we here specify only two of the six possible configurations:</p><formula xml:id="formula_5">/phone/call/inpocket/inmeeting/vibration = on /phone/call/notinpocket/inmeeting/vibration = off</formula><p>Suppose the mobile phone gets a call. By above getenv we request to lookup /phone/call/vibration to know whether vibration is turned on. In the first step, it will find the context and resolve inbuilding. In the next step, it will recursively search in the specification again, and find another context with /phone/call/ %inpocket%/%inmeeting%/vibration. Then the placeholders are again replaced with the respective values. Resolving this key, the algorithm will not find an- other matching specification. Thus, it returns the configuration value of not in pocket and in meeting, i.e., /phone/call/notinpocket/inmeeting/vibration. Because this configuration value is off, the phone will not vibrate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>Our methodological foundation is built on "theory of cases" <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>. Other research should supplement our work with further case and user studies.</p><p>We chose 16 popular systems for evaluation (as discussed in threats to validity in Section 5). We will solely focus on existing applications and their integration into a coherent system. The evaluation was conducted on different machines using Debian GNU/Linux Jessie 8.1 amd64. For the evaluation we globally intercept getenv() using /etc/ld .so.preload. By listing EnvElektra in /etc/ld.so.preload it will be loaded be- fore any other library. Thus its symbols will be preferred. Because of this preference EnvElektra will be used for every getenv()-call.</p><p>In each of the following subsections, we will answer one of the questions: RQ1: What are the usage patterns of getenv() in popular applications? RQ2: For which applications can we actually exploit getenv() to be used for unanticipated context awareness? What are the fundamental limitations? RQ3: What is the overhead that occurs in a system using EnvElektra?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">RQ1: Usage Patterns</head><p>Only APIs that are actually called during runtime can be exploited for context awareness. To learn more about usage patterns, we count how often getenv(key) is executed. getenv all: Count all calls to getenv while using the application. getenv init: Count all calls to getenv while starting the application. all unique: From all getenv calls, how many different keys were used? later unique: From getenv calls after initialization, how many different keys were used? For wget and curl the first download counts as initialization. same: From the getenv calls during startup (during runtime an arbitrary high num- ber could be acquired), what is the maximum number of queries with the same value for the parameter key?</p><p>To interpret the numbers correctly we have to know that the usage patterns vary widely even for the same application. For example, firefox started within GNOME requests 11 GNOME specific and 8 GTK specific environment variables (like G_DEBUG). If executed on a system with OpenGL enabled, 43 additional en- vironment variables (like __GL_EVENT_LOGLEVEL) are used to determine OpenGL configurations. Additionally, the tested system requested three vendor (NV) specific variables. For KDE, KDE_FULL_SESSION was used as detection. Then 8 more KDE- specific and 15 more QT-specific environment variables were requested if started within KDE. Thus, the numbers depend on the desktop environment and hardware.</p><p>For better reproducibility, we freshly installed Debian Jessie KDE and GNO- ME variants, respectively. The only modification was the installation of EnvElektra. For example, on a daily used KDE with many installed applications, we measured 210.276 getenv() during startup, which is 21 more than with a freshly installed KDE. We see that the numbers also depend on the installed software.</p><p>The above 13 applications request an average of 2969 environment values (2790 median). Akonadi, configured to use IMAP, had the highest number of calls to getenv. The reason seems to be a potential misuse of a libc function which re- quested LANGUAGE 5126 times. During the KDE startup 27% of all getenv calls were LANGUAGE. We conclude that excessive use can be unintentional.</p><p>From the numbers in the table we conclude that getenv() is used extensively in all examined applications. Applications often reread environment parameters during user interactions. This statement is true for both large applications and small helper tools. As expected, large feature-rich applications request much more environment variables. The ratios of requested and unique environment variables varies greatly: it is 14% median, and in akonadi it is ∼ 1%. We see that applications tend to request the same variables often.</p><p>Our findings regarding RQ1 are:</p><p>(1) We quantitatively show that getenv() is pervasive. We think that the usage patterns stem from a rather random use of getenv(): variability seems to be added ad-hoc whenever single developers needed it. Because getenv() has no noticeable performance implication and typically is not unit-tested, it is likely that quality assurance will not find unnecessary occurrences.</p><p>(2) Based on our observation, getenv() is used frequently after startup. Implications: Developers seem to not optimize calls to getenv(). The re- sulting high number of getenv()-calls open up possibilities to influence the behavior of applications on context changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ2: Unanticipated Context Awareness</head><p>We already showed that the use of getenv() is pervasive, even after startup. Now, we want to find out whether changes in the context -and thus in the variables returned by getenv() -actually have an influence on the behavior.</p><p>We found that in help-, save-and open-dialogs different values returned by getenv() often influence the behavior of the application in a way easily visible to the user. These environment variables often have immediate and visible im- pact when changed dynamically. For example, gimp uses for every open dialog G_FILENAME_ENCODING and for every help dialog GIMP2_HELP_URI. On context changes, e.g. when we enter another network or mount a new file system, the soft- ware can automatically be adapted with EnvElektra. Now, we investigate context awareness of proxy settings. A user changing the network with a different proxy should be able to continue browsing. lynx requests and correctly uses http_proxy for every single page. curl has the same behavior and reloads 7 additional environment variables every time. wget gives less control per download but still requests http_proxy for every page in recursive download- ing mode. Firefox uses the proxy for most pages but pages in cache are displayed even when the proxy is unreachable. Chromium is the only browser not rereading http_proxy. Instead, it requests many internals such as GOOGLE_API_KEY during run-time. EnvElektra supports http_proxy well.</p><p>Our approach is very successful whenever an application executes other pro- grams because during the startup of the programs the whole environment is always requested and used. Many programs use a pager or editor as external program. For example, man executes a pager for every displayed manpage.</p><p>For some applications it is possible to specify a configuration file using an envi- ronment variable. In EnvElektra configuration files can be mounted. Then they are a part of the database, which permits full configurability. For example, less executed within man uses the environment variable LESSKEY. In such cases our approach pro- vides seamless context-aware configuration.</p><p>Some getenv() calls, however, do not have any user-visible impact. Instead, they seem to be left-overs. In LibreOffice, WorkDirMustContainRemovableMedia is obviously a workaround for a very specific problem. It is not documented and searching the web for it only reveals the use in the source code. Instead, OOO_ENABLE_LOCALE_DATA_CHECKS is an announced workaround. In GTK GTK_ TEST_TOUCHSCREEN is requested extensively. According to the commit log it was explicitly introduced as a test feature.</p><p>Sometimes recurring getenv cannot be exploited to improve context awareness. For example, LANGUAGE is requested very often but does not influence the user- interface after startup. Here changes at runtime seem to have no impact. Such envi- ronment variables will only be context-aware during the start of an application.</p><p>A limitation of our approach is the impossibility to detect unwanted changes of environment variables. For example, the environment variable CC can change during compilation. Obviously, this easily leads to inconsistent compilation and linking.</p><p>In EnvElektra the runtime-context-change feature can easily be (de)activated for process hierarchies, though.</p><p>Not a single crash occurred in our experiments regardless of which values we modified. This behavior is not entirely surprising: First, software should validate values returned from getenv(). Thus, wrong values from getenv() are rejected. Second, we did no systematic stress testing but only searched for useful changes.</p><p>Our findings regarding RQ2 are:</p><p>(1) We show that many practical use cases exist where context changes are applied successfully at runtime.</p><p>(2) Limitations include that some getenv() calls do not have visible impact and that context switches in rare cases lead to incorrect behavior.</p><p>Implications: EnvElektra increases the context awareness for the evaluated applications. Specific functionality is even flawlessly context-aware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ3: Overhead</head><p>Finally, we want to evaluate whether the overhead of EnvElektra is acceptable. The benchmarks were conducted on a hp The glibc getenv() implementation linearly searches through the whole envi- ronment. On the one hand, our implementation does not have this constraint. Its complexity is O(log(n)) compared to O(n) for environ iteration. We do not use unordered hash maps because we need lexically ordered iteration, e.g. to iterate over all layers and during reloadConfiguration(). On the other hand, the con- textual lookup involves recursion. Depending on the specification EnvElektra needs additional nested lookups.</p><p>In a benchmark we compared 1,000,000 getenv() calls with the same number of EnvElektra's lookups. We did 11 measurements and report the median value. For a small number (30) of environment variables, standard getenv() implementations (0.03 sec) clearly outperform EnvElektra's lookup (0.06 sec). For 100 environment variables (which is a typical value) they perform equally well: 0.076 sec for standard getenv() and 0.073 sec for EnvElektra's lookup. For more than 100 environment variables, EnvElektra's lookup outperforms getenv().</p><p>Regarding the overall overhead, we first report about the diversity of the applica- tions. For the startup of gimp the overhead of 2.6% is negligible. For the startup of firefox, however, the overhead is 6.5%. The reason is that Firefox performs exec() 5 times during startup. Then EnvElektra needs to be initialized and needs to parse its configuration files again. For very small applications, e.g. curl and wget, the pars- ing strongly affects the runtime overhead. If they download empty files, the overhead even dominates. The overhead between different applications varies greatly.</p><p>Next, we were interested in the impact on a system which executes many pro- cesses each with trivial tasks. An extreme example happens to be the compilation of C software projects with gcc. Because gcc spawns 5 subprocesses for the compila- tion of every .c file, the overhead seems to get immense. Actually, the overhead of a trivial program's compilation, only containing int main(){}, is 90%. The parsing of configuration files gets dominant. It is astonishing that the overhead of a compila- tion for a full project is only 14%. For this benchmark we compiled EnvElektra from scratch. The absolute times are 2:23 min total when compiling with EnvElektra and 2:05 min total without EnvElektra as measured with the time utility. The compila- tion executed 6847 processes, did 30862 getenv calls, 6199 of which contained CC. Even though trivial process executions have large overhead, the overall performance only suffers little, even in extreme cases.</p><p>We further were very interested in any other occurrence with a similar number of many process executions. The booting of Debian executes 732 processes. The most often requested environment variable was SANE_DEBUG_SANEI_SCSI with 286 oc- currences. In the script startkde, 227 binaries are executed. The executed number of processes in the case of compilation actually seems to represent an exception. We conclude that occurrences where processes are spawned excessively are rare.</p><p>Finally, we want to discuss the overhead of the reload feature. We chose the following setup: We installed the webserver lighttpd locally. EnvElektra was ac- tive throughout the whole experiment. To download 10 files with 1MB to 10MB size each we executed curl -o "#1 http://localhost/test/ <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref>". With- out reloading this execution resulted in 83,786,947 instructions. With reloading Env- Elektra every millisecond, valgrind counted 91,569,790 instructions. The reloading caused the configuration to be fetched 91 times instead of 4 times. Because of an optimization within EnvElektra only stat is used on the configuration files without parsing them again. Thus, the overhead is only 9.3%.</p><p>Different to the benchmark setup above we will now change the database once during program execution. Then EnvElektra will reread the respective configuration file. We have to take care that the changed value does not influence the control flow. For example, if we add the no_proxy variable, proxy setup is skipped and the performance even increases. Thus, we changed COLUMNS, which is requested for every download but does not influence the overhead more than unrelated parameters. When changing it during one of the ten requests the execution needed 95,248,722 instructions. We see that actual context changes have acceptable overhead of ∼ 4%.</p><p>Our findings regarding RQ3 are:</p><p>(1) In applications that terminate very soon, e.g. only showing help text, the run-time overhead dominates. In practical use, however, EnvElektra only adds run-overhead from 2.6% to 14% (in extreme but realistic cases).</p><p>(2) Dynamic reload has about 10% overhead. On context changes the over- head increases again by about 4% in a realistic http-proxy-transition.</p><p>Implications: EnvElektra's run-time overhead typically is low and thus ac- ceptable. For frequent context changes, optimizations would be preferable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Threats to Validity</head><p>As in all quantitative studies our concern is if the evaluated software is represen- tative. In RQ1 we address it by using a significant number of diverse open-source software in terms of functionality, development teams and programming languages. We did not consider context awareness already present in applications. Although interception also works for closed-source software, we did not study it because of the impossibility to cross-check with source code. Anyhow some of the software, including libreoffice, chromium and eclipse, has at least origins in closed-source de- velopment. Thus, the results can be valid for closed-source software, too. While we think that the software we inspected represents some characteristics of variability APIs, more general conclusions need further work.</p><p>In the methodology of RQ2, we need to interpret whether contextual aware- ness can be exploited. We avoid subjective judgements about context awareness during program start. One could also modify the environment with a wrapper script to achieve similar results. We prefer to examine dynamic context changes which are impossible with former approaches. To improve reproducibility and objectivity we only consider visible changes in the user interface.</p><p>We exclusively measure calls of getenv but do not consider the use of the environ pointer, the third parameter of main, and /proc. We cannot guarantee full coverage. Therefore our evaluation actually underestimates the full potential.</p><p>We added optional logging to count the number of getenv. Logging, however, influences a system deeply. On one system two start-processes failed when logging was activated. We did not find other occurrences that caused differences in behavior. Thus, we always rerun our tests without logging.</p><p>The benchmarks are conducted comparatively and consider only a single imple- mentation of getenv. Therefore run-time measurements may not apply for other versions or OSs. Additionally, the benchmarks yield very different results depend- ing on the size of the used configuration files and the respective parser. To level out this problem, we took care that our setup is realistic. We used 8 different configu- ration files and especially chose parsers which are known to be slow. We think that it is straight-forward to reproduce our benchmarks in a way that they perform even better than the numbers we reported.</p><p>Overall, while we cannot draw general conclusions for context-aware configu- ration access in the getenv API, we think that our study unveils some important insights, particularly for open source software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Riva et al. <ref type="bibr" target="#b22">[23]</ref> acquired software-engineering-related knowledge from studying context-aware software. Different from our approach, they reverse-architected ex- isting context-aware support systems. We preferred to study the behaviour of well- known software when introducing context awareness.</p><p>Context-aware middleware <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> is a well-established research direction. Env- Elektra could be seen as local context-aware middleware for configuration. Env- Elektra scores in situations where legacy software needs to be deployed.</p><p>Using the correct context is a subtopic of avoiding configuration errors. Yin et al. <ref type="bibr" target="#b27">[28]</ref> researched different types of configuration-parameter-related mistakes. They investigated value-environment mistakes which can be caused by wrong contextual interpretation. Which errors actually are induced by incorrect contextual interpreta- tion, however, is still an open question.</p><p>A lot of work exists about how to extract program configuration constraints from source code <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b21">22]</ref>. The authors argue that even though many constraints are ex- tracted, sometimes additional external knowledge is needed. We think that context awareness is such a constraint.</p><p>Context-oriented programming (COP) already has an important role within software-engineering <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b23">24]</ref>. COP mainly aims at more comprehensible pro- grams expressing more context awareness. Our approach tackles the problem in a different direction: We add context awareness without changing the program.</p><p>Previous work <ref type="bibr" target="#b18">[19]</ref> describes context-awareness by using explicit layer activa- tions. Other than our approach, these methods cannot be used for already existing applications.</p><p>Niu et al. <ref type="bibr" target="#b16">[17]</ref> report on a web-based framework which uses indoor location, which is an important context sensor. Software product line engineering <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b24">25]</ref> deals with the question how to construct products by combining features. Configu- ration specification languages <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> rarely have support for context. An exception is the context oriented component model PCOM <ref type="bibr" target="#b14">[15]</ref>. Unlike our approach, these approaches cannot be used for already existing applications.</p><p>Yuan et al. <ref type="bibr" target="#b28">[29]</ref> provided a quantitative characteristic study for software logging. Similar to our study they revealed that their object of study is used in four large open-source applications pervasively. Different to our approach, they researched how logging statements were introduced and changed, while we show how APIs for variability are intercepted for more context awareness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper, we described a context-aware database using configuration files. A getenv implementation uses it for context-aware configuration access. Applications facilitating this API profit from context awareness. Our approach is unique because it allows applications to be context-aware without any modifications.</p><p>We saw that getenv() in most software provides excessive variability which is currently underutilized. This variability benefits from context awareness. The paper gives ideas for programmers how getenv() can be used with more efficacy. Some- times software is even capable to dynamically adapt to context changes even though the authors did not anticipate this use. In a benchmark we found out that while in small synthetic benchmarks the overhead might be devastating, in practice it stays well with reasonable bounds.</p><p>Our results are:</p><p>• Presentation of an approach in which applications are more aware of their context • A novel context-aware getenv() implementation downloadable from http://www.libelektra.org. • Providing experimental validation by a case study of significant complexity.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>/</head><label></label><figDesc>phone/call/inpocket/vibration = off /phone/call/notinpocket/vibration = on</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>char</head><label></label><figDesc>* contextLookup (KeySet * cfg, char * key) { m = lookupBySpecification (cfg, key, "context"); if (m) return contextLookup (cfg, fix(m)); else return lookup (cfg, key); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>R</head><label></label><figDesc>EliteBook 8570w using the central processor unit Intel R Core TM i7-3740QM @ 2.70GHz. Overhead is measured with valgrind by running the executable without and with EnvElektra.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A survey on context-aware systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Baldauf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dustdar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Rosenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Ad Hoc and Ubiquitous Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="263" to="277" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">What is a feature?: a qualitative study of features in industrial software product lines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lettner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Grünbacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chechik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Software Product Line</title>
		<meeting>the 19th International Conference on Software Product Line</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="16" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient control flow quantification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bockisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kanthak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Haupt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="125" to="138" />
			<date type="published" when="2006" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient layer activation for switching contextdependent behavior</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Costanza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hirschfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>De Meuter</surname></persName>
		</author>
		<idno type="doi">10.1007/11860990_7</idno>
		<ptr target="http://dx.doi.org/10.1007/11860990_7" />
	</analytic>
	<monogr>
		<title level="m">Modular Programming Languages</title>
		<editor>D. Lightfoot, C. Szyperski</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">4228</biblScope>
			<biblScope unit="page" from="84" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The what, who, where, when, why and how of context-awareness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">K</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Abowd</surname></persName>
		</author>
		<ptr target="ftp://ftp.cc.gatech.edu/pub/gvu/tr/1999/99-22.pdf" />
	</analytic>
	<monogr>
		<title level="m">CHI &apos;00 Extended Abstracts on Human Factors in Computing Systems, CHI EA &apos;00</title>
		<meeting><address><addrLine>NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Selecting empirical methods for software engineering research</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Easterbrook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Singer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Storey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Damian</surname></persName>
		</author>
		<idno type="doi">10.1007/978-1-84800-044-5_11</idno>
		<ptr target="http://dx.doi.org/10.1007/978-1-84800-044-5_11" />
	</analytic>
	<monogr>
		<title level="m">Guide to Advanced Empirical Software Engineering</title>
		<editor>F. Shull, J. Singer, D. Sjøberg</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="285" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Theory building from cases: opportunities and challenges</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Eisenhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Graebner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Academy of management journal</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="32" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A comprehensive solution for application-level adaptation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Geihs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Eliassen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Floch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fricke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gjorven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hallsteinsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">U</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mamelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">A</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Paspallis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Reichle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Stav</surname></persName>
		</author>
		<idno type="doi">10.1002/spe.900</idno>
		<ptr target="http://dx.doi.org/10.1002/spe.900" />
	</analytic>
	<monogr>
		<title level="j">Software: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="385" to="422" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A middleware for building context-aware mobile services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">K</forename><surname>Pung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Q</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Vehicular Technology Conference</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004" />
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="2656" to="2660" />
		</imprint>
	</monogr>
	<note>VTC 2004-Spring</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Software variability: the design space of configuration languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cleenewerck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Jonckers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Workshop on Variability Modeling of SoftwareIntensive Systems</title>
		<meeting>the 6th Workshop on Variability Modeling of SoftwareIntensive Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="157" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">A declarative approach to automated configuration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Hewson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="51" to="66" />
		</imprint>
		<respStmt>
			<orgName>LISA</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Context-aware systems: A literature review and classification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jong-Yi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eui-Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sung-Jin</surname></persName>
		</author>
		<idno type="doi">10.1016/j.eswa.2008.10.071</idno>
		<ptr target="http://dx.doi.org/10.1016/j.eswa.2008.10.071" />
	</analytic>
	<monogr>
		<title level="j">Expert Systems with Applications</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="8509" to="8522" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Context-oriented software engineering: A modularity vision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Aotani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Masuhara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tamai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Modularity</title>
		<meeting>the 13th International Conference on Modularity<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="85" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Context-oriented programming: Beyond layers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Von Löwis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
		<idno type="doi">10.1145/1352678.1352688</idno>
		<ptr target="http://dx.doi.org/10.1145/1352678.1352688" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 International Conference on Dynamic Languages, ICDL &apos;07</title>
		<meeting>the 2007 International Conference on Dynamic Languages, ICDL &apos;07<address><addrLine>NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="143" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Primitive component architecture description language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Magableh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Barrett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 7th International Conference on</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
	<note>Informatics and Systems (INFOS)</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Mining configuration constraints: Static analyses and empirical results</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kästner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<idno type="doi">10.1145/2568225.2568283</idno>
		<idno>DOI 10.1145/ 2568225.2568283</idno>
		<ptr target="http://dx.doi.org/10.1145/2568225.2568283" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Software Engineering</title>
		<meeting>the 36th International Conference on Software Engineering<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="140" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Wif4inl: Web-based integration framework for indoor location</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Niu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Saiki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Matsumoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nakamura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Pervasive Computing and Communications</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A modular approach to configuration storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raab</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
		<respStmt>
			<orgName>Vienna University of Technology</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Global and thread-local activation of contextual program execution environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raab</surname></persName>
		</author>
		<idno type="doi">DOI10.1109/ISORCW.2015.52</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE 18th International Symposium on Real-Time Distributed Computing Workshops (ISORCW/SEUS)</title>
		<meeting>the IEEE 18th International Symposium on Real-Time Distributed Computing Workshops (ISORCW/SEUS)</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="34" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Sharing software configuration via specified links and transformation rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raab</surname></persName>
		</author>
		<idno>from KPS 2015</idno>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">18</biblScope>
		</imprint>
		<respStmt>
			<orgName>Vienna University of Technology, Complang Group</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Program execution environments as contextual values</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raab</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Puntigam</surname></persName>
		</author>
		<idno type="doi">10.1145/2637066.2637074</idno>
		<ptr target="http://dx.doi.org/10.1145/2637066.2637074" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 6th International Workshop on Context-Oriented Programming</title>
		<meeting>6th International Workshop on Context-Oriented Programming<address><addrLine>NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Static extraction of program configuration options</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rabkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering (ICSE), 2011 33rd International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="131" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Unearthing design patterns to support context-awareness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Riva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Di Flora</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Raatikainen</surname></persName>
		</author>
		<idno type="doi">10.1109/PERCOMW.2006.138</idno>
		<ptr target="http://dx.doi.org/10.1109/PERCOMW.2006.138" />
	</analytic>
	<monogr>
		<title level="m">Pervasive Computing and Communications Workshops, 2006. PerCom Workshops</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="5" to="387" />
		</imprint>
	</monogr>
	<note>Fourth Annual IEEE International Conference on</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Context-oriented programming: A software engineering perspective</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Salvaneschi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ghezzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pradella</surname></persName>
		</author>
		<idno type="doi">10.1016/j.jss.2012.03.024</idno>
		<ptr target="http://dx.doi.org/10.1016/j.jss.2012.03.024" />
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1801" to="1817" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Formal methods in software product line engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hähnle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="82" to="85" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A graph-based operational semantics for contextoriented programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Schippers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Molderez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Janssens</surname></persName>
		</author>
		<idno type="doi">DOI10.1145/1930021.1930027</idno>
		<ptr target="http://dx.doi.org/10.1145/1930021.1930027" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2Nd International Workshop on ContextOriented Programming, COP &apos;10</title>
		<meeting>the 2Nd International Workshop on ContextOriented Programming, COP &apos;10<address><addrLine>NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Contextual values</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tanter</surname></persName>
		</author>
		<idno type="doi">DOI10.1145/1408681.1408684</idno>
		<ptr target="http://dx.doi.org/10.1145/1408681.1408684" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 Symposium on Dynamic Languages, DLS &apos;08</title>
		<meeting>the 2008 Symposium on Dynamic Languages, DLS &apos;08<address><addrLine>NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An empirical study on configuration errors in commercial and open source systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename><surname>Bairavasundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
		<idno type="doi">DOI10.1145/2043556.2043572</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Third ACM Symposium on Operating Systems Principles, SOSP &apos;11</title>
		<meeting>the Twenty-Third ACM Symposium on Operating Systems Principles, SOSP &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="159" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Characterizing logging practices in open-source software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2337223.2337236" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering, ICSE &apos;12</title>
		<meeting>the 34th International Conference on Software Engineering, ICSE &apos;12<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="102" to="112" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
