<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="de">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ein Lösungsarchiv mit Branch-and-Bound-Erweiterung für das Generalized Minimum Spanning Tree Problem DIPLOMARBEIT zur Erlangung des akademischen Grades Computational Intelligence eingereicht von</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Diplom-Ingenieur</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">im Rahmen des Studiums</orgName>
								<orgName type="department" key="dep2">Fakultät für Informatik</orgName>
								<orgName type="institution" key="instit1">Technischen Universität Wien</orgName>
								<orgName type="institution" key="instit2">Technische Universität Wien</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Gruber</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">im Rahmen des Studiums</orgName>
								<orgName type="department" key="dep2">Fakultät für Informatik</orgName>
								<orgName type="institution" key="instit1">Technischen Universität Wien</orgName>
								<orgName type="institution" key="instit2">Technische Universität Wien</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Ein Lösungsarchiv mit Branch-and-Bound-Erweiterung für das Generalized Minimum Spanning Tree Problem DIPLOMARBEIT zur Erlangung des akademischen Grades Computational Intelligence eingereicht von</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Betreuung Betreuer: Univ.-Prof Dr.Günther Raidl Mitwirkung: Univ.-Ass. Dr. Bin Hu Wien, September 5, 2011 (Unterschrift Verfasser) (Unterschrift Betreuer)</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>A-1040 Wien Karlsplatz 13 Tel. +43-1-58801-0 www.tuwien.ac.at Erklärung Christian Gruber Wachbergsraße 29 3382 Schollach Hiermit erkläre ich, dass ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen der Arbeit-einschließlich Tabellen, Karten und Abbildungen-, die an-deren Werken oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe. ii Kurzfassung In dieser Arbeit wird ein Algorithmus für das Generalized Minimum Spanning Tree-Problem (GMST) entwickelt. Beim GMST-Problem ist ein vollständiger Graph gegeben, bei dem die Knoten in Cluster partitioniert sind. Als Lösung wird ein Spannbaum gesucht, der von jedem Cluster genau einen Knoten beinhaltet und dessen Kosten minimal sind. Dieses Problem ist NP-schwierig. In dieser Arbeit wird eine Heuristik für dieses Problem entwickelt. Bei diesem Verfahren wird ein Evolutionärer Algorithmus (EA) mit zwei ver-schiedenen Lösungsarchiven verwendet. Die Lösungsarchive werden dazu benutzt Lösungen zu speichern, um Duplikate zu erkennen und diese in neue Lösungen umzuwandeln. Das eine Lösungsarchiv beruht auf einer Kodierung, bei der die ausgewählten Knoten der Cluster einer Lösung gespeichert werden, während das andere Archiv auf einer Kodierung beruht, bei der gespeichert wird, welche Cluster in der Lösung verbunden sind. Diese Archive werden in dieser Arbeit durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Dabei wird versucht im Archiv an günstigen Positionen geeignete Bounds zu berechnen, die Auskunft darüber geben, wie gut die Lösungen in diesem Bereich des Archivs höchstens sein können. Wird eine Bound gefunden, die schlechter als die beste gefunden Lösung ist, sind diese Lösungen im weiteren Verlauf des Algorithmus uninteressant und werden nicht mehr berücksichtigt. Das führt dazu, dass mehrere Lösungen von vornherein als schlecht erkannt werden können und somit nur Lösungen verfolgt werden, die auch Verbesserungen bringen können. Zusätzlich zu der Bounding-Strategie wird auch noch ein Nearest Neighbour Ansatz verwendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n näch-sten Nachbarcluster bevorzugt werden. Am Ende der Arbeit wurden Tests durchgeführt, bei denen die Bounding Strate-gie in den unterschiedlichen Archiven verwendet wurde. Diese Tests führten zu dem Ergebnis, dass die Bounding Strategie zu einer Verbesserung gegenüber den Archiven ohne Bounding Strategie führt. Der Vergleich zwischen den Archiven hat ergeben, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen beiden Varianten. iii Abstract In this work, an algorithm for the generalized minimum spanning tree problem (GMST) is developed. Given is a complete graph where the nodes are partitioned into clusters. A solution is a spanning tree which contains exactly one node of each cluster and its costs are minimal. This problem is NP-hard. In this work, a heuristic is developed for this problem. In this method, an evolutionary algorithm (EA) is used with two different solution archives. Using a solution archive, it is possible to store solutions generated by the EA in order to detect duplicates and converts duplicate solutions into new solutions. One solution archive based on an encoding in which the spanned nodes of each cluster in the solution are stored. The other archive is based on an encoding which characterizes the connections between the clusters. These archives are extended by a bounding strategy based on the branch-and-bound technique. They try to calculate appropriate bounds at a convenient positions which give information about how good the solutions in the respective area of the archive can be in the best case. If a bound was found which is worse than the best known solution, the solutions are unattractive in the course of the algorithm and will not be considered. Therefore inferior solutions can be detected at an early stage and only promising solutions that can bring improvements will be pursued. In addition to the bounding strategy a nearest neighbor approach is implemented in which a cluster attached to the spanning tree is preferred among the the n nearest neighboring clusters. Tests were carried out in which the bounding strategy was used in the different variants. These tests led to the conclusion that the bounding strategy leads to an improvement in comparison to the &quot;normal&quot; archives. The comparison between the archives shows that the pop version lead to better results than the gosh version. When both archives are used simultaneously, the results are better than the results of the other two variants.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="de">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kurzfassung</head><p>In dieser Arbeit wird ein Algorithmus für das Generalized Minimum Span- ning Tree-Problem (GMST) entwickelt. Beim GMST-Problem ist ein vollständiger Graph gegeben, bei dem die Knoten in Cluster partitioniert sind. Als Lösung wird ein Spannbaum gesucht, der von jedem Cluster genau einen Knoten beinhaltet und dessen Kosten minimal sind. Dieses Problem ist NP-schwierig. In dieser Arbeit wird eine Heuristik für dieses Problem entwickelt.</p><p>Bei diesem Verfahren wird ein Evolutionärer Algorithmus (EA) mit zwei ver- schiedenen Lösungsarchiven verwendet. Die Lösungsarchive werden dazu benutzt Lösungen zu speichern, um Duplikate zu erkennen und diese in neue Lösungen umzuwandeln. Das eine Lösungsarchiv beruht auf einer Kodierung, bei der die ausgewählten Knoten der Cluster einer Lösung gespeichert werden, während das andere Archiv auf einer Kodierung beruht, bei der gespeichert wird, welche Clus- ter in der Lösung verbunden sind.</p><p>Diese Archive werden in dieser Arbeit durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Dabei wird versucht im Archiv an günstigen Positionen geeignete Bounds zu berechnen, die Auskunft darüber geben, wie gut die Lösungen in diesem Bereich des Archivs höchstens sein können. Wird eine Bound gefunden, die schlechter als die beste gefunden Lösung ist, sind diese Lösungen im weiteren Verlauf des Algorithmus uninteressant und werden nicht mehr berücksichtigt. Das führt dazu, dass mehrere Lösungen von vornherein als schlecht erkannt werden können und somit nur Lösungen verfolgt werden, die auch Verbesserungen bringen können.</p><p>Zusätzlich zu der Bounding-Strategie wird auch noch ein Nearest Neighbour Ansatz verwendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n näch- sten Nachbarcluster bevorzugt werden.</p><p>Am Ende der Arbeit wurden Tests durchgeführt, bei denen die Bounding Strate- gie in den unterschiedlichen Archiven verwendet wurde. Diese Tests führten zu dem Ergebnis, dass die Bounding Strategie zu einer Verbesserung gegenüber den Archiven ohne Bounding Strategie führt. Der Vergleich zwischen den Archiven hat ergeben, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen beiden <ref type="bibr">Varianten.</ref> iii Abstract In this work, an algorithm for the generalized minimum spanning tree problem (GMST) is developed. Given is a complete graph where the nodes are partitioned into clusters. A solution is a spanning tree which contains exactly one node of each cluster and its costs are minimal. This problem is NP-hard. In this work, a heuristic is developed for this problem.</p><p>In this method, an evolutionary algorithm (EA) is used with two different solu- tion archives. Using a solution archive, it is possible to store solutions generated by the EA in order to detect duplicates and converts duplicate solutions into new solutions. One solution archive based on an encoding in which the spanned nodes of each cluster in the solution are stored. The other archive is based on an encoding which characterizes the connections between the clusters. These archives are extended by a bounding strategy based on the branch-and-bound technique. They try to calculate appropriate bounds at a convenient positions which give information about how good the solutions in the respective area of the archive can be in the best case. If a bound was found which is worse than the best known solution, the solutions are unattractive in the course of the algorithm and will not be considered. Therefore inferior solutions can be detected at an early stage and only promising solutions that can bring improvements will be pursued.</p><p>In addition to the bounding strategy a nearest neighbor approach is implemented in which a cluster attached to the spanning tree is preferred among the the n nearest neighboring clusters.</p><p>Tests were carried out in which the bounding strategy was used in the different variants. These tests led to the conclusion that the bounding strategy leads to an improvement in comparison to the "normal" archives. The comparison between the archives shows that the pop version lead to better results than the gosh version. When both archives are used simultaneously, the results are better than the results of the other two variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>iv</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inhaltsverzeichnis</head><p>Erklärung Gegeben ist ein vollständiger gewichteter Graph G = (V, E, c), wobei V die Knoten- menge, E die Kantenmenge und c : E → R + die Kostenfunktion ist. Die Knotenmenge V ist partitioniert in m paarweise disjunkte Cluster</p><formula xml:id="formula_0">V 1 , V 2 , . . . , V m , wobei i=1,...,m V i = V , V i ∩ V j = ∅ ∀i, j = 1, . . . , m, i = j. d i ist die Anzahl der Knoten in Cluster V i , i = 1, . . . , m. Eine Lösung für das GMST-Problem ist ein Graph S = (P, T ), wobei P = {p 1 , p 2 , . . . , p m } ⊆ V enthält genau einen Knoten von jedem Cluster (p i ∈ V i f or all i = 1, . . . , m). T ⊆ E ist ein Spannbaum auf die Knoten in P . Die Kosten von T ergeben sich aus den Kantenkosten, C(T ) = (u,v)∈T c(u, v)</formula><p>. Die optimale Lösung ist dann ein Graph S = (P, T ) dessen Kosten C(T ) minimal sind. Ein Beispiel für eine solche Lösung ist in Abb. 1 zu finden. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Evolutionäre Algorithmen</head><p>Ein Evolutionärer Algorithmus (EA) <ref type="bibr" target="#b8">[9]</ref> ist eine Metaheuristik, mit deren Hilfe Opti- mierungsprobleme gelöst werden können. Der EA macht sich die Eigenschaften der natürlichen Evolution zunutze, um ausgehend von einer Anfangspopulation im Laufe der Zeit immer bessere Lösungen zu finden. Dazu werden drei Operationen angewen- det: Selektion, Mutation und Rekombination.</p><p>Der EA arbeitet mit einer Population von Lösungen, wobei die einzelnen Lösungen in kodierter Form gespeichert werden. Diese kodierten Lösungen werden Genotyp genannt. Sie bestehen oft aus einem Bitstring. In dieser Arbeit werden die Lösungen aber als Integer-Vektor gespeichert. Auf die Kodierungsarten wird in Kapitel 1.4 noch genauer eingegangen. Um die Lösungen auswerten zu können ist es notwendig, die Lösungen auch wieder zu dekodieren. Die dekodierten Lösungen werden Phänotypen genannt.</p><p>Der Ablauf des EA ist wie folgt: Zunächst wird für jede Lösung der Population aus den dazugehörigen Phänotypen ein Fitnesswert berechnet. Dieser Fitnesswert ist ein Maß dafür wie gut die Lösung ist. Danach werden durch eine Selektionsfunktion mit Hilfe der Fitnesswerte, zwei Elternlösungen ausgewählt. Aus diesen beiden Elternlö- sungen wird dann durch eine Rekombination eine neue Lösung generiert. Die Idee dabei ist, dass die guten Teile der ausgewählten Lösungen zusammengesetzt werden und dadurch eine neue bessere Lösung entsteht. Danach wird eine Mutation angewen- det, in der die Lösung zufällig an einer bestimmten Stelle verändert wird, um nicht so schnell in einem lokalen Optimum festzustecken. Die Mutation wird aber nur mit einer bestimmten Wahrscheinlichkeit ausgeführt, da sonst der Zufall einen zu großen Einfluss auf die Lösungsfindung hat.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Lösungsarchive</head><p>Wie bei den meisten Metaheuristiken, ist die Definition der einzelnen Methoden all- gemein gehalten. Um den EA auf ein spezifisches Problem anzuwenden, müssen diese Methoden angepasst werden. Es gibt zwei unterschiedliche Arten von EAs:</p><p>• Steady-State-EA: Dabei wird in jedem Generationsschritt nur eine Lösung aus der Population ersetzt. Die restlichen Lösungen bleiben erhalten.</p><p>• generationalen-EA: Hier wird in jedem Generationsschritt die gesamte Population ersetzt.</p><p>In dieser Arbeit, genauso wie in den Arbeiten von Sonnleitner <ref type="bibr" target="#b12">[13]</ref> und Wolf <ref type="bibr" target="#b14">[15]</ref>, auf denen diese Arbeit aufbaut, wurde ein Steady-State-EA verwendet. replace one solution in pop with sol new 14: end while</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Lösungsarchive</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Lösungsrepräsentationen</head><p>In dieser Arbeit wurden zwei verschiedene Lösungsrepräsentationen verwendet: Die Kodierung von Gosh <ref type="bibr" target="#b1">[2]</ref> und die von Pop <ref type="bibr" target="#b10">[11]</ref>. Beide Lösungsrepräsentationen wur- den auch in den Arbeiten von Wolf <ref type="bibr" target="#b14">[15]</ref> und Sonnleitner <ref type="bibr" target="#b12">[13]</ref>, auf denen diese Arbeit aufbaut, verwendet. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.1">Gosh-Kodierung</head><p>Bei der Gosh-Kodierung wird für jeden Cluster angegeben, welcher Knoten in diesem Cluster ausgewählt wurde. Die kodierte Lösung besteht somit aus einem Vektor P = {p 1 , p 2 , . . . , p m } wobei p i ∈ V für alle i = 1 . . . m. Um aus der kodierten Lösung den Phänotypen und den dazugehörigen Lösungswert zu bekommen, kann dazu ein MST- Algorithmus angewendet werden (z.B. Kruskal).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.2">Pop-Kodierung</head><p>Bei der Pop-Kodierung wird gespeichert, welche Cluster miteinander verbunden sind. Dazu wird ein globaler Graph definiert <ref type="bibr" target="#b6">[7]</ref>:</p><formula xml:id="formula_1">G G = (V G , E G ), wobei V G den Clustern des ursprünglichen Graphen G entsprechen und E G den Kanten zwischen den Clustern, d.h. E G = V G ×V G . Auf diesen Graphen G G kann nun ein Spannbaum S G = (V G , T G ) gebildet werden, wobei T G ⊆ E G .</formula><p>Die Pop-Kodierung wird nun mithilfe der Predecessor-Darstellung gemacht. Dazu wird ein Cluster als Wurzelcluster ausgewählt. In dem Spannbaum S G gibt es nun für jeden Cluster einen eindeutigen Pfad zum Wurzelcluster und somit auch einen eindeutigen Vorgänger. Für die Lösungsrepräsentation wird in einem Vektor oder Array für jeden Cluster (außer dem Wurzelcluster) der Vorgänger gespeichert. In Abb. 2 ist ein Beispiel dazu angegeben.</p><p>Ein Problem dieser Kodierung ist, dass nicht jede Kodierung eine gültige GMST-Lösung darstellt. Dieser Faktor muss bei den EA-Operationen berücksichtigt werden, damit dadurch keine ungültigen Lösungen erstellt werden. Sonnleitner <ref type="bibr" target="#b12">[13]</ref> hat dazu in seiner</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5.">Branch and Bound</head><p>Arbeit einen Repair-Mechanismus entwickelt, mit dem ungültige Lösungen in gültige umgewandelt werden können. Mittels dynamischer Programmierung kann dann aus der kodierten Lösung die optimale Auswahl der Knoten innerhalb der Cluster erfolgen und somit der Phänotyp und den dazugehörigen Lösungswert ermittelt werden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Branch and Bound</head><p>Branch and Bound ist ein Verfahren, mit deren Hilfe man beweisbar optimale Lösungen für kombinatorische Optimierungsprobleme finden kann. Das Verfahren beruht auf der Idee der beschränkten Enumeration und basiert auf dem Divide &amp; Conquer Prinzip. Branch and Bound-Algorithmen bestehen prinzipiell aus zwei Bereichen: Abgrenzung (Bound) und Verzweigung (Branch).</p><p>• Verzweigung (Branch): Durch die Verzweigungsschritte wird das Problem in mehrere Teilprobleme zerlegt, die dann leichter zu lösen sind. Durch wieder- holte Anwendung des Verzweigungsschritts auf die Teilprobleme entsteht ein so- genannter Entscheidungsbaum, der den Lösungsraum widerspiegelt.</p><p>• • null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde.</p><p>• complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde oder alle Lösungen in den darunter liegenden Subtrie bereits complete sind.</p><p>• • null: Dieser Pointerwert gibt an, dass hier noch keine Lösung eingefügt wurde.</p><p>• complete (c): Dieser Wert tritt auf, wenn das Ende einer Lösung erreicht wurde oder alle Lösungen in dem darunter liegenden Subtrie bereits complete sind.</p><p>• forbidden (f): Dieser Wert gibt an, dass diese Kodierung zu einer ungültigen Lö- sung führt, d.h. zu keinem Baum.</p><p>• </p><formula xml:id="formula_2">Graph G = (V , E ) definiert, wobei V = V 1 ∪ V 0 .</formula><p>Die Menge E setzt sich aus 3 verschiedenen Arten von Kanten zusammen:</p><formula xml:id="formula_3">• E 11 = V 1 × V 1 sind die</formula><p>Kanten zwischen allen Paaren von Clustern, für die bereits eine Auswahl getroffen wurde. Die Kantenkosten ergeben sich aus der Distanz zwischen den ausgewählten Knoten der Cluster.</p><p>• E 10 = V 1 × V 0 sind die Kanten zwischen allen Paaren von Clustern, bei de- nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht wurde. Die Kantenkosten zwischen den Clustern</p><formula xml:id="formula_4">V i ∈ V 1 und V j ∈ V 0 lauten c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist.</formula><p>• E 00 = V 0 × V 0 sind die Kanten zwischen allen Paaren von Clustern, für die noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern</p><formula xml:id="formula_5">V i ∈ V 0 und V j ∈ V 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.</formula><p>Die Definition der Kantenmenge lautet also E = E 11 ∪ E 10 ∪ E 00 . Die Berechnung der Kantenkosten wird in einem Preprocessing-Schritt durchgeführt, d.h. sie erfolgt einmal zu Beginn des Algorithmus und ist somit für die Laufzeit des Algorithmus nicht mehr relevant. Um die Bound zu berechnen, wird für den Graphen G ein mi- </p><formula xml:id="formula_6">nimaler Spannbaum S = (V , T ) ermittelt, wobei T ⊆ E . Die Bound entspricht dabei den Kosten des Spannbaums T , C(T ) = (u,v)∈T c(u, v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Konvertierungs-Methode</head><p>Die zweite Möglichkeit, wann Boundberechnungen durchgeführt werden können, ist bei der Konvertierungs-Operation des Lösungsarchivs. Bei der Konvertierungs-Operation wird aus einer im Archiv enthaltenen Lösung eine neue Lösung gemacht, die der alten möglichst ähnlich ist. Die Boundberechnung erfolgt nach jeder Änderung, die in der alten Lösung gemacht wird. Ist diese Bound besser als die beste bisher gefundene Lö- sung, wird diese neue Lösung akzeptiert. Ist die Bound aber schlechter, so werden die Änderungen wieder rückgängig gemacht, die Lösung im Archiv als complete markiert und danach weiter nach einer anderen neuen Lösung gesucht.</p><p>In Algorithmus 3 ist dargestellt wie die Konvertierung mit Berücksichtigung der Bounds funktioniert. Zuerst wird ein zufälliger Trie-Knoten der Lösung sol ausgewählt. In Zeile 5 wird dann geprüft, ob es einen null-Pointer in dem ausgewählten Trie-Knoten gibt. Wenn es einen gibt, wird die Lösung geändert und überprüft ob die Bound der neuen Lösung an dieser Position schlechter ist als die beste bisher gefunden Lösung. Wenn sie besser ist, wird sie akzeptiert und es kann abgebrochen werden. Ist sie schlechter, wird die Änderung wieder rückgängig gemacht und der Pointer als complete markiert. Die Suche wird danach fortgesetzt. In den Zeilen 14-21 wird versucht, entlang der Lösung im Archiv eine Ebene nach unten zu gehen. Dieser Schritt erfolgt nur, wenn der Pointer nicht complete ist und die Bound besser ist als die beste Lösung. Wenn entlang von sol nicht nach unten gegangen werden kann, wird in den Zeilen 22-31 versucht einen anderen Pointer, der nicht complete ist, zu finden und an diesen eine Ebene nach unten zu gehen. Hier erfolgt wieder eine Überprüfung der Bound. Der ausgewählte Pointer wird nur weiter verfolgt, wenn die Bound besser ist als die beste Lösung.</p><p>Es kann vorkommen, dass in einem Trie-Knoten kein Pointer vorhanden ist, der zu einer guten Bound führt. Das hat zur Folge, dass alle Pointer als complete markiert werden und somit nicht mehr weiter nach unten gegangen werden kann. Deshalb muss bei jedem Schleifendurchlauf überprüft werden, ob es noch einen Pointer gibt, der nicht complete ist. Wenn nicht, wird dieser Trie-Knoten gelöscht und der zugehörige Pointer im Eltern-Knoten als complete markiert. Danach kann Abgebrochen werden und f alse zurück gegeben werden. Die Konvertierungs-Methode wird danach nochmal aufgerufen. Das kann zu einem Problem führen. Wenn die Ausgangslösung relativ schlecht ist, kann die Suche nach einer neuen Lösung recht lange dauern. Tests haben gezeigt, dass dieser Fall nicht sehr oft auftritt und in den meisten Fällen schon nach wenigen Versuchen eine neue Lösung gefunden werden kann. In wenigen Fällen wurde aber lange nach einer Lösung gesucht. Um dieses Problem zu umgehen, wurde ein Parameter num_conv eingeführt, mit dem die Anzahl der Konvertierungsversuche begrenzt werden kann.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 3 GoshTrie convert with Bound</head><note type="other">Eingabe: sol -solution to convert, best solution bestsol Ausgabe: convertion successfull (true/false) 1: curr ← random Trie-node along sol 2: add all clusters from root to curr to V 1 and the other clusters to V 0 3: while curr! = null &amp;&amp; curr! = complete do 4:</note><p>check if all pointers in curr are complete, so we can cancel <ref type="bibr">5:</ref> if curr has a null-pointer then  Danach wird mit der Methode calculateBound mit einem angepassten Kruskal Algo- rithmus ein minimum Spanning-Tree ermittelt. Ähnlich wie bei der Boundberechnung im Gosh-Archiv, werden im Pop-Archiv auch drei Arten von Kanten zur Berechnung verwendet:</p><note type="other">immer für einen bestimmten Pointer in einem Trie-Knoten. Bei der Pop-Kodierung wird, wie in Kapi- tel 1.4.2 erläutert, für jeden Cluster der Vorgänger des minimalen Spannbaums, der aus den globalen Graphen G G erzeugt wird, gespeichert. Wenn in einem bestimmten Trie- Knoten die Bound berechnet werden soll, bedeutet das, dass für alle Cluster vom ak- tuellen Trie-Knoten bis hin zur Wurzel der Vorgänger bereits ausgewählt wurde. Diese Menge wird als V 1 bezeichnet. Für alle Cluster in den darunterliegenden Trie-Ebenen wurde noch keine Auswahl getroffen. Sie sind noch mit keinem Cluster verbunden. Diese Menge wird als V 0 bezeichnet. Dadurch ergibt sich ein Wald G . In</note><formula xml:id="formula_7">• E 11 = V 1 × V 1 ist die</formula><note type="other">Menge aller Kanten von G . Die Kantenkosten ergeben sich aus dem Abstand zwischen den ausgewählten Knoten der Cluster.</note><p>• E 10 = V 1 × V 0 sind die Kanten zwischen allen Paaren von Clustern, bei de- nen schon eine Auswahl getroffen wurde und denen für die noch keine gemacht wurde. Die Kantenkosten zwischen den Clustern</p><formula xml:id="formula_8">V i ∈ V 1 und V j ∈ V 0 lauten c(p i , V j ) = min{c(p i , p j )|p j ∈ V j }, wobei p i ∈ V i ist.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>20</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Boundberechnung im Pop-Archiv</head><p>• E 00 = V 0 × V 0 sind die Kanten zwischen allen Paaren von Clustern, für die noch keine Auswahl getroffen wurde. Die Kantenkosten zwischen den Clustern</p><formula xml:id="formula_9">V i ∈ V 0 und V j ∈ V 0 lauten c(V i , V j ) = min{c(p i , p j )|p i ∈ V i , p j ∈ V j }.</formula><p>Im Kruskal-Algorithmus werden jetzt zunächst alle Kanten von E 11 eingefügt. Danach werden die restlichen Kanten E 10 ∪ E 00 , wie bei einem normalen Kruskal-Algorithmus, in der Reifenfolge ihrer Kantenkosten hinzugefügt, sodass kein Zyklus entsteht.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 5 calcClusters</head><p>Eingabe: root-node cN r; solution sol; data; current level of the trie aktP os Wie vorhin bereits erwähnt, wird mit den Methoden calcClusters und generateList die bestmögliche Auswahl von Knoten innerhalb der Cluster getroffen. Zunächst wird mit calcClusters (Algorithmus 5) für jeden Knoten der zu untersuchen- den Cluster die Kosten berechnet, die entstehen wenn dieser Knoten ausgewählt wird. Dazu wird calcClusters rekursiv aufgerufen, um, angefangen bei den Clustern in der untersten Ebene, die Kosten für die Knoten zu berechnen.</p><p>Die Kosten werden in der Methode calcClusterweights (Algorithmus 6) berechnet. Dazu wird für jeden Knoten p i ∈ C cur des jeweiligen Clusters C cur ∈ V 1 die mini- malen Kosten berechnet, die entstehen würden, wenn dieser ausgewählt werden würde. Das geschieht, indem für alle Nachfolgecluster C suc ∈ V 1 ein Knoten p j ∈ C suc ausgewählt wird. Der Knoten p j wird dabei so gewählt, dass die Summe der Kosten von p j und die Distanz von p i zu p j minimal ist. Die Kosten des Knoten sind also C(p i ) = p j ∈Psuc (C(p j ) + dist(p i , p j )), wobei P suc die Menge der minimalen Knoten der Nachfolgecluster von C cur ist. In der Datenstruktur nodes werden für alle Knoten deren Kosten C(p i ) gespeichert und berechnet und auch alle Knoten der Menge P suc gespeichert. Diese Datenstruktur wird für die spätere Auswahl der Knoten in den Clus- tern benötigt.</p><p>Mit der Methode generateList (Algorithmus 7) werden nun die ausgewählten Knoten innerhalb der Cluster ermittelt. Dazu wird beginnend beim Wurzelcluster der Knoten mit den geringsten Kosten in data gespeichert. Dazu wird die Datenstruktur nodes ver- wendet, in der für jeden Knoten die günstigsten Nachfolgeknoten gespeichert sind.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 6 calcClusterweights</head><p>Eingabe: current cluster cN r; solution sol; data Variablen: minW eight=current minimal weight of the cluster 1: childCl ← all cluster which predecessor is cN r in sol 2: for all nodes parentN ode in cluster cN r do <ref type="bibr">3:</ref> for all child in childCl do <ref type="bibr">4:</ref> for all nodes childN ode in cluster child do </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rekombination</head><p>Bei der Rekombinations-Methode wurde die in <ref type="bibr" target="#b12">[13]</ref> verwendete Methode als Grundlage genommen und durch den Nearest Neighbour Ansatz ergänzt. Die Rekombination wird dabei wie folgt durchgeführt: Für jedes Cluster C i wird über- prüft, ob es in den beiden Lösungen den gleichen Vorgänger hat. Wenn das der Fall ist, wird dieser Vorgänger in die neue Lösung übernommen. Hat der Cluster C i in den beiden Lösungen unterschiedliche Vorgänger, gibt es drei Möglichkeiten:</p><p>• Ein Vorgänger C j ist in der Menge der Nearest Neighbours von C i und der andere C k nicht: In diesem Fall wird C j in der neuen Lösung aufgenommen.</p><p>• </p><formula xml:id="formula_10">(T ) = 1/n n i=1 C(T i ) und die Standard- abweichung S = 1/(n − 1) n i=1 (C(T i ) − C avg ) 2 genommen.</formula><p>Die Tests wurden auf dem Cluster des Institut für Computergraphik und Algorithmen der TU-Wien durchge- führt, welcher aus 14 Maschinen mit jeweils zwei QuadCore-CPUs und 24 GB Ar- beitsspeicher besteht.</p><p>Grundsätzlich wurden zwei Arten von Tests durchgeführt. Zum einen sind Testläufe gemacht worden, bei denen der EA nach einer fixen Laufzeit terminiert und zum an- deren Testläufe bei denen nach einer bestimmten Anzahl von Generationen der EA ter- miniert. Letztere wurden unter anderem dazu verwendet, um den Speicherverbrauch des Archivs genauer zu untersuchen.</p><p>Die folgenden Tests wurden mit einer fixen Laufzeit durchgeführt. Die Daten der ver- wendeten Testinstanzen und die Laufzeit werden in Tabelle 1 dargestellt. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Analyse der Cuts</head><p>Zum Beginn der Tests sollte die Frage geklärt werden, ob und wie viele Teilbereiche des Archivs abgeschnitten (als complete markiert) werden können. Außerdem sollte geklärt werden, in welchen Bereichen des Archivs Teilbereiche abgeschnitten werden, also Cuts gemacht werden. Cuts in den oberen Ebenen sind besser, da dadurch mehr Lösungen im vorhinein ausgeschlossen werden können als bei Cuts in den unteren Ebenen. Dieser Test wurde für beide Archive (Pop-und Gosh-Archiv) und für alle 14 Test-Instanzen durchgeführt. Dabei wurde der EA nach einer konstanten Zeit terminiert.</p><p>In Tabelle 2 werden die Ergebnisse dieses Tests dargestellt. In dieser Tabelle wird gezeigt in welchem Teil des Archivs wie viele Cuts durchgeführt wurden. Die Spalte 0 − 25% gibt an, wie viele Cuts in den oberen 25% der Ebenen im Archiv durchgeführt wurden, in der Spalte 25 − 50% für die nächsten 25%, usw.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Tests mit fixer Laufzeit</head><p>Tabelle 2: Anzahl der Cuts in den unterschiedlichen Bereichen des Archivs</p><p>Gosh-Archiv Pop-Archiv Instanz 0-25%25-50%50-75%75-100% 0-25%25-50%50-75%75-100% kroa150 0 Hier ist zu sehen, dass im Gosh-Archiv in den ersten 50% keine Bound gefunden wird, die schlechter ist als die beste bisher gefunden Lösung, und somit auch kein Cut gemacht werden kann. Da in den ersten 50% keine Cuts gemacht werden, ist es auch nicht nötig die Bound in diesem Bereich zu berechnen, da das nur unnötig Laufzeit verbraucht. De- shalb wurde der Parameter skip_bound eingeführt, mit dem angegeben werden kann, in wie viel Prozent der oberen Ebenen die Bound nicht berechnet werden soll. Aufgrund der erhaltenen Ergebnisse, wurde für die folgenden Tests der Parameter skip_bound für das Gosh-Archiv auf 0, 5 gesetzt. Das bedeutet, dass für die oberen 50% des Archivs wird die Bound nicht berechnet.</p><p>Im Pop-Archiv sieht es hingegen anders aus. Hier kommt es auch in den oberen Ebenen zu Cuts. Die Frage, die sich jetzt stellt, ist: Wieso werden im Pop-Archiv in den oberen Ebenen Cuts gemacht aber im Gosh-Archiv nicht? Die Antwort auf die Frage findet sich in den unterschiedlichen Kodierungen der Lösung, die in den Archiven verwendet werden. Bei der Gosh-Kodierung wird für jeden Cluster gespeichert, welcher Knoten in dem Cluster ausgewählt wird. Wird ein Eintrag für einen Cluster geändert, d.h. ein anderer Knoten in dem Cluster ausgewählt, werden die Kosten der Gesamtlösung nicht stark ansteigen, da die Knoten innerhalb eines Clusters relativ nahe zusammen liegen. Bei der Pop-Kodierung wird für jeden Cluster der Vorgänger im Spannbaum des glob-alen Graphen gespeichert. Kommt es hier zu einer Änderung für einen Cluster, können die Kosten der Gesamtlösung stark ansteigen, falls die Cluster im Graphen weit au- seinander liegen. D.h. wenn in den oberen Ebenen schon ein Vorgänger für einen Clus- ter ausgewählt wird, der weiter entfernt liegt, kann das schon zu einer schlechten Bound führen. Die unterschiedliche Kodierung ist auch der Grund, warum im Pop-Archiv mehr Cuts gemacht werden als im Gosh-Archiv.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Gosh-Archiv</head><p>In den nächsten Tests wurde untersucht, wie sich die Bounding-Strategie auf das Gosh- Archiv auswirkt. Dabei wurden drei Varianten betrachtet: Bounding-Strategie innerhalb der Einfüge-Methode, Bounding-Strategie innerhalb der Konvertierungs-Methode und die Variante, in der sie in beiden Methoden gleichzeitig verwendet wird. Dabei wurde der Parameter skip_bound auf 0, 5 gesetzt. Für den Parameter branch_and_bound_prob wurden Tests gemacht, bei denen der Wert dieses Parameters variiert wurde, um fest- zustellen, welcher Wert die besten Ergebnisse liefert. Dabei hat sich heraus gestellt, dass bei branch_and_bound_prob &gt; 0, 1 die Anzahl der erzeugten Generationen zu stark abnimmt und somit schlechtere Ergebnisse geliefert werden. Auf die Ergebnisse der Tests mit den Werten 0, 1 und 0, 05 wurde ein Wilcoxon-Rangsummenstatistik- Test durchgeführt mit dem Resultat, dass beide Werte ähnliche Ergebnisse liefern, die sich statistisch nicht signifikant unterscheiden. Da mit einem Wert von 0, 05 aber in mehr Fällen bessere Resultate erzielt wurden, wurde für die folgenden Tests dieser Wert genommen.</p><p>Die Ergebnisse dieses Tests sind in Tabelle 3 zu sehen. In der Tabelle werden in der Spalte T rie die Ergebnisse des "normalen" Gosh-Archivs ohne Bounding-Strategie, unter T rie+insert−Bound die Variante mit Bounding-Strategie innerhalb der Einfüge- Methode, im Bereich T rie + convert − Bound die Bounding-Strategie innerhalb der Konvertierungs-Methode und unter T rie + ins&amp;conv − Bound bei der die Bounding- Strategie in beiden Methoden gleichzeitig verwendet wird dargestellt. C avg entspricht dem durchschnittlichen Lösungswert über alle Runs, darunter in Klammern steht die Standardabweichung und Gen ist die durchschnittliche Anzahl der erzeugten Genera- tionen.</p><p>In den Ergebnissen ist zu sehen, dass alle drei Bounding Varianten gegenüber des "nor- malen" Archivs bessere Ergebnisse liefern. Die Variante, in der die Bounding Strate- gie in beiden Methoden verwendet wurde, liefert jedoch gegenüber der beiden anderen Varianten schlechtere Ergebnisse. Dieses Resultat ist auf die geringere Anzahl von erzeugten Generationen zurück zu führen. In einigen Instanzen wurden nur halb so viele Generationen erzeugt als in den anderen Varianten.</p><p>Tabelle 3: Vergleich der verschiedenen Bounding-Varianten im Gosh-Archiv Tabelle 5 zeigt die Ergebnisse für diesen Test. Hier ist zu sehen, dass die Varianten mit den Bounding-Strategien meistens besser sind als die Variante mit "normalem" Archiv. Außer für die Instanzen kroa150, pr226, pr264 und f l417 für die auch mit dem Archiv ohne Bounding-Strategie das Optimum erreicht wurde.</p><formula xml:id="formula_11">Trie Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound Instanz C avg (T ) Gen C avg (T ) Gen C avg (T ) Gen C avg (T ) Gen</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.5">Beide Archive</head><p>In <ref type="bibr" target="#b12">[13]</ref> wurde eine Variante getestet, bei der beide Archive gleichzeitig verwendet wur- den. In dieser Arbeit soll auch getestet werden, wie sich die Bounding-Strategie in den verschiedenen Varianten auswirkt, wenn beide Archive gleichzeitig verwendet werden. Der Parameter skip_bound wird auf 0, 5 gesetzt. Dieser hat aber nur Auswirkungen auf das Gosh-Archiv, d.h. im Pop-Archiv werden in allen Ebenen Bounds berechnet. Der Parameter branch_and_bound_prob wurde, genau wie bei den vorherigen beiden Tests, auf 0, 05 gesetzt.</p><p>In Tabelle 6 sind die Ergebnisse dieses Tests zu sehen. Dabei wurden wieder 4 Varianten miteinander verglichen: "normalen" Gosh und Pop Archive ohne Bounding-Strategie (T rie), die Variante mit Bounding-Strategie innerhalb der Einfüge-Methode (T rie + insert−Bound), die Bounding-Strategie innerhalb der Konvertierungs-Methode (T rie+ convert−Bound) und die Bounding-Strategie in beiden Methoden gleichzeitig (T rie+ ins&amp;conv − Bound). Hier ist zu sehen, dass bessere Ergebnisse bei den Varianten mit Bounding-Strategie erzielt werden, außer bei den Instanzen bei denen das Optimum schon mit den "normalen" Archiven erreicht wird. Außerdem ist zu sehen, dass in der Variante, in der in beiden Methoden die Bounding-Strategie verwendet wird, schlechtere Ergebnisse erreicht werden, als in den Varianten, wo die Bounding-Strategie nur bei der Einfüge-oder Konvertierungs-Methode verwendet wird. Das ist auf die geringere An- zahl von Generationen zurück zu führen, die oft nur halb so groß ist als bei den beiden anderen Varianten.  Bei der Bounding-Strategie in der Konvertierungs-Methode ist der Grund für den er- höhten Speicherverbrauch ähnlich wie bei der Einfüge-Methode. Wenn bei der Konver- tierungs-Methode in einem zufällig ausgewählten Startknoten der Lösung keine null- Pointer gefunden werden, wird versucht, entlang der Lösung im Trie eine Ebene nach unten zu gehen. Wenn das nicht möglich ist, wird versucht bei einem anderen nicht complete-Pointer eine Ebene nach unten zu gehen. Wenn jetzt aufgrund von Bounds, die schlechter als die beste bisher gefunden Lösung sind, in diesem neuen Knoten alle Pointer complete werden, wird die Konvertierung abgebrochen und an einer anderen Stelle nochmal versucht. Da der Pointer der Lösung in dem Startknoten in diesem Fall auf complete gesetzt wurde, wird beim nächsten Konvertierungsversuch der Startknoten aus den darüber liegenden Ebenen ausgewählt. D.h. bei der Verwendung der Bounding- Strategie ist die Wahrscheinlichkeit höher, dass in den oberen Ebenen die Konvertierung durchgeführt wird. Das führt dazu, dass beim anschließenden Einfügen einer Lösung der neu einzufügende Subtrie größer ist. Deshalb werden mehr Trie-Knoten mit der Bounding-Strategie erzeugt und somit kommt es auch zu einem erhöhten Speicherver- brauch.</p><p>Tabelle 7: Vergleich von Gosh-Trie mit 10000 Generationen </p><formula xml:id="formula_12">Trie Trie+insert-Bound Trie+convert-Bound Instanz C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B]<label>kroa150</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">State of the Art</head><p>In Tabelle 10 wurden die Ergebnisse dieser Arbeit mit den Ergebnissen anderer Arbeiten verglichen, um zu sehen, wie der EA Ansatz mit Lösungsarchiv und Bounding-Strategie im Vergleich abschneidet. Die Ergebnisse wurden aus der Arbeit <ref type="bibr" target="#b4">[5]</ref> übernommen. In Tabelle 10 werden vier Verfahren miteinander verglichen: ein Tabu Search Verfahren (TS) von <ref type="bibr" target="#b1">[2]</ref>, ein Variable Neighborhood Search Verfahren (VNS) von <ref type="bibr" target="#b3">[4]</ref>, ein Ver- fahren basierend auf Dynamic Candidates Sets (DCS) von <ref type="bibr" target="#b5">[6]</ref> und einem EA mit einem Archiv in Kombination mit einer Bounding-Strategie. Bei dem Verfahren mit Boundig- Strategie wurden die Ergebnisse genommen, bei denen beide Archive kombiniert wur- den und die Bound nur in der Konvertierungs-Methode verwendet wurde. Hier ist zu sehen, dass das Verfahren mit Bounding-Strategie durchaus mit den anderen Verfahren mithalten kann und in einigen Instanzen auch bessere Ergebnisse liefert. Diese Varianten wurden in den beiden Archiven getestet und verglichen. Im Gosh- Archiv haben die Bounding Varianten in allen Instanzen bessere Ergebnisse erzielt, als bei der "normalen" Variante. Die Variante, in der in beiden Methoden die Bounding- Strategie verwendet wird, hat jedoch schlechtere Ergebnisse gebracht als in den anderen beiden Bounding-Varianten. Das ist auf die geringere Anzahl von erzeugten Gener- ationen zurück zu führen. Im Pop-Archiv waren die Ergebnisse der Bounding Vari- anten ebenfalls besser als die der "normalen" Variante. Bei der Variante, in der beide Archive gemeinsam verwendet wurden, haben die Bounding-Varianten ebenfalls eine Verbesserung erzielt. Beim Vergleich zwischen den Archiven kann man sagen, dass die Pop-Variante bessere Ergebnisse liefert als die Gosh-Variante. Die Variante, in der beide Archive gleichzeitig verwendet werden, ist wiederum besser als die anderen bei- den Varianten.</p><p>Die Tests haben ebenfalls ergeben, dass der Speicherverbrauch der Archive durch die Verwendung der Bounds erhöht wird. Das ist darauf zurück zu führen, dass wenn beim Einfügen einer Lösung eine Bound gefunden wird, die schlechter ist als die beste bisher gefundene Lösung, diese Lösung teilweise eingefügt wird und zusätzlich noch eine neue konvertierte Lösung.</p><p>Die Ergebnisse dieser Arbeit wurden auch mit den Ergebnissen anderer Arbeiten ver- glichen, um zu sehen wie das Verfahren im Vergleich zu anderen abschneidet. Dabei hat sich gezeigt dass die Bounding-Strategie mit anderen Verfahren mithalten kann und in einigen Instanzen bessere Ergebnisse liefert.</p><p>Die Ergebnisse dieser Arbeit haben gezeigt, dass die Bounding-Strategie eine Verbesserung gegenüber dem Lösungsarchiv ohne Bounding-Strategie bringt. Ein wichtiger Punkt bei der Bounding-Strategie ist es, eine effiziente Methode für die Boundberechung zu finden, damit die Anzahl der erzeugten Generationen nicht zu stark abnimmt. Für an- dere Problemstellungen könnte dieses Verfahren auch Verbesserungen bringen, wenn eine effiziente Methode zur Boundberechnung gefunden wird.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Abb. 1: Lösung für ein GMST-Problem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Abb. 2: Pop-Kodierung mit V 1 als Wurzelknoten</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>37 3. 2 .</head><label>372</label><figDesc>Tests mit fixer Laufzeit Tabelle 6: Vergleich der verschiedenen Bounding-Varianten bei der Kombination von Gosh-und Pop Archiv Trie Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Zusammenfassung In dieser Arbeit wurde ein Evolutionärer Algorithmus mit zwei verschiedenen Varianten von Lösungsarchiven (Gosh-Archiv und Pop-Archiv) durch eine Bounding-Strategie basierend auf dem Branch and Bound Verfahren erweitert. Zusätzlich wurde auch ein Nearest Neighbour Ansatz angewendet, bei dem beim Anhängen eines Clusters an den Spannbaum die n nächsten Nachbarcluster bevorzugt werden. Bei der Bounding-Strategie werden in den einzelnen Trie-Knoten geeignete Bounds berechnet, die eine Aussage darüber machen können, wie gut die Lösungen im darunter liegenden Subtrie bestenfalls sein können. Mit diesen Bounds können viele Lösungen von vornherein als schlecht markiert werden. Die Boundberechnung erfolgt in 3 ver- schiedenen Varianten: Boundberechnung in der Einfüge-Methode des Archivs, in der Konvertierungs-Methode und in beiden Methoden gleichzeitig.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>ii</head><label></label><figDesc></figDesc><table>Kurzfassung 
iii 

Abstract 
iv 

Inhaltsverzeichnis 
v 

1 Einleitung 
1 
1.1 Generalized Minimum Spanning Tree-Problem . . . . . . . . . . . . . 
1 
1.2 Evolutionäre Algorithmen . . . . . . . . . . . . . . . . . . . . . . . . . 
2 
1.3 Lösungsarchive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
3 
1.4 Lösungsrepräsentationen . . . . . . . . . . . . . . . . . . . . . . . . . 
4 
1.4.1 Gosh-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . . 
5 
1.4.2 Pop-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . . . 
5 
1.5 Branch and Bound . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
6 
1.6 Bisherige Ansätze . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
7 
1.6.1 EA mit Gosh-Lösungsarchiv . . . . . . . . . . . . . . . . . . . 
8 
1.6.2 EA mit Pop-Lösungsarchiv . . . . . . . . . . . . . . . . . . . . 10 

2 Algorithmus 
12 
2.1 Boundberechnung im Gosh-Archiv . . . . . . . . . . . . . . . . . . . . 13 
2.1.1 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 15 
2.1.2 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 17 
2.2 Boundberechnung im Pop-Archiv . . . . . . . . . . . . . . . . . . . . . 19 
2.2.1 Inkrementelle Boundberechnung . . . . . . . . . . . . . . . . . 23 
2.2.2 Pop mit Nearest Neighbours Reduktion . . . . . . . . . . . . . 24 
2.2.3 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 26 
2.2.4 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 27 

3 Ergebnisse 
30 
3.1 Vorgehensweise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 

v 3.2 Tests mit fixer Laufzeit . . . . . . . . . . . . . . . . . . . . . . . . . . 31 
3.2.1 Analyse der Cuts . . . . . . . . . . . . . . . . . . . . . . . . . 31 
3.2.2 Gosh-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 
3.2.3 Nearest Neighbours . . . . . . . . . . . . . . . . . . . . . . . . 34 
3.2.4 Pop-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 
3.2.5 Beide Archive . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 
3.3 Fixe Anzahl von Generationen . . . . . . . . . . . . . . . . . . . . . . 39 
3.4 State of the Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 

4 Zusammenfassung 
45 

Literaturverzeichnis 
47 

vi Einleitung 

1.1 Generalized Minimum Spanning Tree-Problem 

Das Generalized Minimum Spanning Tree-Problem (GMST) ist ein kombinatorisches 
Optimierungsproblem, das eine Verallgemeinerung des Minimum Spanning Tree Prob-
lems (MST) ist. Für das MST-Problem ist ein vollständiger Graph G gegeben, bei 
dem jeder Kante Kosten zugeordnet sind. Eine Lösung des MST-Problems entspricht 
einer Teilmenge von Kanten, die einen minimalen Spannbaum bilden. Ein minimaler 
Spannbaum ist ein kreisfreier Teilgraph von G, der mit allen Knoten des Graphen ver-
bunden ist und dessen Summe der Kantenkosten minimal ist. Beim GMST-Problem 
werden zusätzlich noch die Knoten des MST-Problems durch Cluster partitioniert. 
Die formale Definition des GMST-Problems sieht wie folgt aus [4]: 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head></head><label></label><figDesc>. Wenn nun Knoten in den Clustern ausgewählt werden, bleiben die Kosten des Spannbaums gleich oder werden größer aber sie werden sicher nicht kleiner. Das führt dazu, dass alle Lösungen in diesem Subtrie mindestens so groß sind als die berechnete Bound und somit in diesem Fall auch größer sind als die beste bisher gefundene Lösung.gabewert zurück gegeben. Das hat zur Folge, dass die Lösung so behandelt wird als wäre sie schon einmal einge- fügt worden und es wird eine neue Lösung generiert. Wenn das Einfügen erfolgreich war, wird von unten nach oben entlang von sol untersucht, ob bei einem Trie-Knoten alle Pointer complete sind. Ist das der Fall kann dieser gelöscht werden und der Pointer im Eltern Knoten auf complete gesetzt werden.</figDesc><table>). Die Berechnung 
des Spannbaums erfolgt mit einem Kruskal Algorithmus mit Union-Find. Die Laufzeit 
dieses Algorithmus wird durch das Sortieren der Kanten bestimmt. Da der Graph G 
ein 
vollständiger Graph ist, entspricht die Anzahl der Kanten |E| = m  *  (m − 1). Dadurch 
ergibt sich eine Laufzeit von O(m 
2 log(m 
2 )) für die Berechnung der Bound. Abb. 5: Boundberechnung im Cluster V 3 beim Einfügen der Lösung &lt;321112&gt; 

In Abb. 5 wird illustriert wie eine Boundberechnung im Gosh-Lösungsarchiv funk-
tioniert. In diesem Beispiel wird im Trie-Knoten des Cluster V 3 die Bound berechnet. 
An dieser Position wurden die Cluster V 1 , V 2 und V 3 schon in den oberen Ebenen einge-
fügt und somit eine Knotenauswahl für die Cluster getroffen. In den darunter liegenden 
Clustern (V 4 , V 5 und V 6 ) wurde noch keine Auswahl getroffen. Für die Boundberech-
nung bedeutet das, dass hier zwischen den Clustern V 1 , V 2 und V 3 als Kantenkosten 
der Abstand der ausgewählten Knoten genommen wird. Zwischen dem Cluster V 3 und 
V 4 wird als Kosten der Distanzen zwischen dem ausgewählten Knoten 1 (V 3 ) und dem 
Knoten 3 (V 4 ) genommen, da dieser die geringste Distanz zum Knoten 1 (V 3 ) hat. Zwi-
schen den Clustern V 4 , V 5 und V 6 werden die minimalen Distanzen zwischen den Clus-
tern verwendet. D.h. zwischen Cluster V 6 und V 4 wird die Kante zwischen Knoten 2 
(V 6 ) und Knoten 1 (V 4 ) genommen und zwischen V 5 und V 4 wird die Kante zwischen 
Knoten 1 (V 5 ) und Knoten 4 (V 4 ) genommen. 

Ist die berechnete Bound schlechter als die beste bisher gefundene Lösung, kann der 
Pointer 1 des Clusters V 3 als complete markiert werden. Das kann gemacht werden, 
da zwischen den Clustern V 4 , V 5 und V 6 immer der minimale Abstand genommen 
wurdeWie vorhin schon erwähnt, ist eine Möglichkeit, wann die Boundberechnung durchge-
führt werden kann, die Einfüge-Operation des Lösungsarchivs. Beim Einfügen einer 
Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt, 
der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Bei einer erfolg-
reichen Einfüge-Operation werden also m Trie-Knoten durchlaufen. Eine Möglichkeit 
wäre, in jedem dieser m Trie-Knoten für den jeweiligen Pointer, der dem ausgewählten 
Knoten dieses Clusters in der Lösung entspricht, die Bound zu berechnen. 

Das führt aber zu einem Problem. Die Berechnung der Bound hat eine Laufzeit von 
O(m 
2 log(m 
2 )). Wenn in jedem Trieknoten die Bound berechnet wird, müsste die 
Bound m-mal ermittelt werden. Das würde zu einer Laufzeit von O(m 
3 log(m 
2 )) 
führen, was eine erhebliche Verschlechterung gegenüber der normalen Einfüge-Operation 
ohne Boundberechnung, mit einer Laufzeit von O(m), wäre. 

Eine Möglichkeit dieses Problem abzuschwächen ist es, die Bound nicht in jedem der 
m Trie-Knoten zu berechnen, sondern nur in einer bestimmten Auswahl von Knoten. 
Dazu wurde der Parameter branch_and_bound_prob eingeführt, mit dem angegeben 
werden kann, mit welcher Wahrscheinlichkeit eine Boundberechnung für einen Trie-
Knoten durchgeführt wird. Als ein guter Wert für diesen Parameter hat sich 0, 05 her-
ausgestellt. Das bedeutet, es wird für 5% der Trie-Knoten die Bound berechnet. Die 
Auswahl erfolgt dabei zufällig. 

In Algorithmus 2 ist der Pseudocode für die Einfüge-Operation mit Boundberechnung 
dargestellt. Diese beruht auf der Einfüge-Operation von Wolf [15], nur dass diese durch 
die Bounding Strategie erweitert wurde. Zunächst wird der Vektor V 
0 , in der alle Clus-
ter gespeichert sind, die noch nicht in das Archiv eingefügt worden sind, initialisiert. 
Ausgehend vom Wurzelknoten wird nun immer dem Pointer des Trie-Knoten gefolgt, 
der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Der Cluster wird 
dabei immer aus dem Vektor V 
0 entfernt und dem Vektor V 
1 hinzugefügt, indem alle 
Cluster gespeichert sind die schon eingefügt worden sind. Diese beiden Vektoren wer-
den dann für die spätere Boundberechnung benötigt. Ist der Pointer gleich null, muss 
ein neuer Trie-Knoten angelegt werden. Dazu wird zufällig ein Cluster aus dem Vektor 
V 
0 ausgewählt. Danach wird, mithilfe des Parameters branch_and_bound_prob, er-
mittelt ob für diesen Trie-Knoten eine Bound berechnet werden soll. Wird eine Bound 
berechnet und ist sie schlechter als die beste bisher gefundene Lösung, werden alle 
Trie-Knoten in den darunterliegenden Sub-Trie gelöscht und der Pointer als complete 
markiert. Anschließend wird die Einfüge-Operation abgebrochen und f alse als Rück-Algorithmus 2 GoshTrie insert with Bound 
Eingabe: sol -solution to insert; best solution bestsol 
Ausgabe: insertion successfull (true/false) 
Variablen: m=number of clusters; root=root from archiv 

1: V 
0 ← list with all numbers from 0 to m − 1 
2: curr ← root 
3: for i = 0...m − 1 do 

4: 

pos ← sol[curr.cluster] 

5: 

move cluster curr from V 
0 to V 

1 

6: 

if curr.next[pos] == complete then 

7: 

return false 

8: 

end if 

9: 

if curr.next[pos] == null then 

10: 

if i == m − 1 then 

11: 

curr.next[pos] ← complete 

12: 

end if 

13: 

rand ← random cluster from V 

0 

14: 

V 
0 ← list with all numbers from 0 to m − 1 

15: 

curr.next[pos] ← new node with cluster rand 

16: 

end if 

17: 

random choice if bound has to be calculated 

18: 

if bound has to be calculated then 

19: 

if bestsol &lt; calculateBound(V 
1 , V 
0 ) then 

20: 

delete curr.next[pos] 

21: 

curr.next[pos] ← complete 

22: 

return f alse 

23: 

end if 

24: 

end if 

25: 

curr ← curr.next[pos] 
26: end for 
27: check if there are complete subtrees along sol 
28: return true 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>2 Boundberechnung im Pop-Archiv Die Boundberechnung erfolgt, genauso wie beim Gosh-Archiv auch,</head><label></label><figDesc></figDesc><table>6: 

sol[curr.cluster] ← random null-pointer of curr 

7: 

if bestsol &lt; calculateBound(V 
1 , V 
0 ) then 

8: 

curr.next[sol[curr.cluster]] ← complete 

9: 

undo changes of sol 

10: 

else 

11: 

return true 

12: 

end if 

13: 

end if 

14: 

if curr.next[sol[curr.cluster]]! = complete] then 

15: 

move curr.next[sol[curr.cluster]].cluster from V 
0 to V 

1 

16: 

if bestsol &lt; calculateBound(V 
1 , V 
0 ) then 

17: 

delete curr.next[sol[curr.cluster]] 

18: 

curr.next[sol[curr.cluster]] ← complete 

19: 

else 

20: 

curr ← curr.next[sol[curr.cluster]] 

21: 

end if 

22: 

else 

23: 

sol[curr.cluster] ← a random not-complete-pointer, of curr 

24: 

move curr.next[sol[curr.cluster]].cluster from V 
0 to V 

1 

25: 

if bestsol &lt; calculateBound(V 
1 , V 
0 ) then 

26: 

delete curr.next[sol[curr.cluster]] 

27: 

curr.next[sol[curr.cluster]] ← complete 

28: 

undo changes of sol 

29: 

else 

30: 

curr ← curr.next[sol[cur.cluster]] 

31: 

end if 

32: 

end if 
33: end while 
34: return f alse 2.</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head></head><label></label><figDesc>Abb. 6 wird illustriert, wie so ein Wald aussehen kann. Die Abbildung zeigt einen Graph G bei einer Boundberechnung im Trie-Knoten von Cluster 6. Die Berechnung der Bound erfolgt nun in mehreren Schritten. In Algorithmus 4 wird in dem Pseudocode gezeigt, wie die Boundberechnung funktioniert. Zunächst wird ein Vektor data erzeugt, indem am Ende der Funktion die ausgewählten Knoten in den Clustern gespeichert werden. Die Elemente von data werden mit -1 initialisiert. Danach wird mit den Methoden calcClusters und generateList durch dynamische Programmierung für die einzelnen Bäume von G ermittelt, welche Knoten innerhalb</figDesc><table>Abb. 6: Boundberechnung im Cluster V 6 Algorithmus 4 calcBoundByDynProg 
Eingabe: root-node cN r; solution sol; current level of the trie aktP os 
Ausgabe: bound 
Variablen: data = list of the selected nodes of the clusters 

1: init data with −1 
2: nextcN r ← cN r 
3: repeat 

4: 

calcClusters (nextcN r, sol, data, aktP os) 

5: 

generateList (nextcN r, data[nextcN r], sol, aktP os) 

6: 

nextinnerN ode ← next cluster with data[nextinnerN ode] = −1 and 
nextinnerN ode &lt;= aktP os 

7: 

if it exists a nextinnerN ode then 

8: 

nextcN r ← getRootNode(sol, nextinnerN ode, aktP os) 

9: 

end if 
10: until it exists a nextinnerN ode 
11: bound ← calculateBound(sol, data, aktP os) 
12: return bound 

der Cluster ausgewählt werden sollen. Die Knoten werden so ausgewählt, dass die 
Kosten der daraus entstehenden Lösung minimal sind. Begonnen wird dabei mit dem 
Baum der vom Wurzelknoten des Lösungsarchivs ausgeht. Danach wird geprüft, ob es 
noch ein Cluster in C ∈ V 
1 gibt, für den noch kein Knoten ausgewählt wurde, d.h. 
dessen Eintrag in data noch -1 ist. Falls es so einen Cluster gibt, wird für diesen Cluster 
C der Wurzelknoten des Baums, in dem er sich in G 
befindet, ermittelt. Von diesem 
Wurzelknoten wird nun wieder mit calcClusters und generateList eine Auswahl der 
Knoten für die Cluster des Baums getroffen. Das wird solange wiederholt bis für alle 
Cluster in V 
1 eine Auswahl getroffen wurde. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>5 :2.2 Pop mit Nearest Neighbours Reduktion In [10] wurde ein Ansatz verfolgt, indem für die Berechnung eines GTSP sogenannte</head><label>5</label><figDesc>Zur Umsetzung der inkrementellen Boundberechnung wurde ein Vektor valid verwen- det, indem für jeden Cluster angegeben wird, ob sich die Knotenkosten in den Cluster ändern. Die einzige Änderung die, gegenüber der "normalen" Boundberechnung zu machen ist, ist in der Methode calcCluster vorzunehmen. In Algorithmus 8 ist zu se- hen, wie die geänderte Methode aussieht. In der Methode wird der Vektor valid dazu verwendet, um festzustellen, ob die Bound berechnet werden soll oder nicht."candidate lists" verwendet wurden, um den Suchraum einzuschränken. Dabei wurden für jeden Knoten die n nächsten Nachbarn in einer Liste gespeichert und nur diese als mögliche Nachfolger in der Tour betrachtet. Der Ansatz wird auch in dieser Arbeit ver- folgt. Dazu wird die Rekombinations-und Mutations-Methode des EAs entsprechend angepasst. Außerdem wird in der Konvertierungs-Methode des Pop-Lösungsarchivs die Nearest Neighbour Reduktion auch angewendet. Darauf wird später in Kapitel 2.2.4 genauer eingegangen werden.</figDesc><table>value= nodes[childN ode].weight + distance(parentN ode, childN ode) 

6: 

if value &lt; minV alue then 

7: 

minV alue=value 

8: 

minChildN odeN r=childN ode 

9: 

end if 

10: 

end for 

11: 

nodes[parentN ode].addF olower(child, minChildN odeN r, minV alue) 

12: 

end for 

13: 

if nodes[parentN ode].weight &lt; minWeight then 

14: 

minW eight = nodes[parentN ode].weight 

15: 

data[cN r] = parentN ode 

16: 

end if 
17: end for 

Algorithmus 7 generateList 
Eingabe: current cluster cN r; node -selected node of cluster cN r node; solution sol; 
data; current level of the trie aktP os 

1: data[cN r] = node 
2: for i=0 . . . aktP os do 

3: 

if sol[i] == cN r then 

4: 

generateList(i, nodes[node].getF ollower(i), data, sol, aktP os) 

5: 

end if 
6: end for 

Die Laufzeit der Boundberechnung wird durch die Berechnung der Kosten für die einzel-
nen Knoten bestimmt. Im schlimmsten Fall müssen für alle Knoten des Graphen die 
Kosten berechnet werden. Deshalb kommt es zu einer Laufzeit von O(n 
2 ). 

22 

2.2. Boundberechnung im Pop-Archiv 

2.2.1 Inkrementelle Boundberechnung 

In [4] wurde eine Nachbarschaft verwendet, in der die neuen Lösungen inkrementell 
berechnet wurden. Derselbe Ansatz soll auch in dieser Arbeit verwendet werden. Beim 
Einfügen einer Lösung wird an verschiedenen Stellen entlang der Lösung im Trie die 
Bound berechnet. Dabei werden aber für manche Teile der Lösung Berechnungen 
mehrfach durchgeführt. Dasselbe gilt auch für das Berechnen von Bounds bei der Kon-
vertierung von Lösungen. 

Die Idee der inkrementellen Berechnung ist es, dass bei der ersten Berechnung der 
Bound innerhalb einer Einfüge-bzw. Konvertierungs-Methode die Bound, wie vorhin 
beschrieben, "normal" berechnet wird. Bei den nächsten Berechnungen der Bound 
müssen nicht mehr für alle Teile des Baums die Kosten der Knoten berechnet werden. 
Die Knotenkosten innerhalb eines Clusters V i können sich nur ändern, wenn V i einen 
neuen Nachfolgecluster im Graphen G 
bekommt oder die Kosten eines Nachfolgers 
von V i sich geändert haben. 

Algorithmus 8 calcClustersImprove 

Eingabe: root-node cN r; solution sol; data; current level of the trie aktP os 

1: if !valid[cNr] then 

2: 

for i=0. . . aktP os do 

3: 

if sol[i]==cN r then 

4: 

calcClusters (i, sol, data, aktP os) 

5: 

end if 

6: 

end for 

7: 

calcCluster (cN r, sol, data) 
8: end if 2.</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>2. Boundberechnung im Pop-Archiv • Beide Vorgänger sind nicht in der Menge der Nearest Neighbours von C i : Hier wird ebenfalls einer der beiden zufällig ausgewählt.sol[mutate] ← pred new Genau wie beim Gosh-Archiv wird auch beim Pop-Archiv die Bounding StrategieInsert-Methode wird in Algorithmus 10 gezeigt. Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Ist ein solcher Pointer noch null, wird ein Trie-Knoten erzeugt und an dieser Stelle in den Trie einge- fügt. Beim ersten Aufruf der Methode calcBoundByDynP rog wird die Bound mithilfe der "normalen" dynamischen Programmierung ermittelt. Für alle weiteren Aufrufewie bei der Insert-Methode in Kapitel 2.2.3, wird in dieser Methode beim er- sten Aufruf von calcBoundByDynP rog die Bound mittels "normalen" dynamischen Programmierung ermittelt. Bei allen weiteren Boundberechnungen innerhalb dersel</head><label></label><figDesc>der Methode calcBoundByDynP rog innerhalb derselben Einfügeoperation wird die inkrementelle Boundberechnung, die in Kapitel 2.2.1 beschrieben wird, verwendet. Dazu müssen vorher alle Cluster, für die sich die Kosten der Knoten ändern, markiert werden. Deshalb wird vor der Boundberechnung die Methode invalidate aufgerufen. In dieser Methode werden alle Cluster, vom aktuellen Cluster bis hin zur Wurzel im Spannbaum der Lösung, markiert. 2.2.4 Konvertierungs-Methode In der Konvertierungs-Methode des Pop-Archivs wird die Bounding Strategie ebenfalls angewendet. Die Konvertierungs-Methode mit Bounds funktioniert dabei ähnlich wie die des Gosh-Archivs. Bei jeder Änderung der Lösung wird die Bound berechnet und überprüft, ob diese besser als die beste bisher gefundene Lösung ist. Ist das nicht der Fall, wird die Änderung rückgängig gemacht und eine andere Lösung gesucht. Zusät- zlich zur Bounding Strategie wurde die Konvertierungs-Methode durch den Nearest Neighbour Ansatz erweitert. In Algorithmus 11 wird der Ablauf der Konvertierungs-Methode gezeigt. Dabei wird zunächst zufällig ein Trie-Knoten curr aus den möglichen Startknoten entlang der Lö- sung ausgewählt. Im nächsten Schritt wird zuerst zufällig aus den Nearest Neighbours von curr ein null-Pointer ausgewählt. Ist keiner vorhanden wird aus den restlichen Pointern zufällig ein null-Pointer ausgewählt. Wurde ein null-Pointer gefunden, kann eine neue Lösung generiert werden. Bei dieser neuen Lösung erfolgt dann eine Bound- überprüfung. Die Boundberechnung wird mit Methode calcBoundByDynP rog durch- geführt. Ist die Bound schlechter als die beste bisher gefundene Lösung, wird die Än- derung der Lösung wieder rückgängig gemacht, der vorher ausgewählte Pointer auf complete gesetzt und mit der Suche fortgesetzt. Ist die Bound nicht schlechter, kann abgebrochen werden. Wurde kein null-Pointer gefunden, wird zunächst versucht, ent- lang der Lösung im Archiv eine Ebene nach unten zu gehen. Hierbei wird wieder eine Boundüberprüfung durchgeführt. Kann entlang der Lösung nicht weiter nach unten gegangen werden, wird im aktuellen Trie-Knoten zufällig ein Pointer aus den Nearest Neighbours von curr ausgewählt, der nicht complete ist. Wird so ein Pointer nicht gefunden, wird aus den restlichen Pointern zufällig ein Pointer ausgewählt, der nicht complete ist. Die Lösung wird dementsprechend geändert und es erfolgt wieder eine Boundüberprüfung.</figDesc><table>Beide Vorgänger sind in der Menge der Nearest Neighbours von C i : Hier wird 
zufällig einer der beiden ausgewählt. 

Abb. 7: Rekombination von zwei Lösungen 

24 

2.Beim Einfügen eines Clusters wird mittels Union Find überprüft, ob durch das Hinzufü-
gen des Clusters ein Zyklus entsteht. Ist das der Fall, so wird der Vorgänger der anderen 
Lösung übernommen, d.h. der Cluster an dieser Stelle eingefügt. Führt das auch zu 
einem Zyklus, wird dieser Cluster als nicht eingefügt markiert. Diese markierten Clus-
ter werden zum Schluss in den Baum hinzugefügt, indem zufällig ein Knoten aus der 
Nearest Neighbours Liste des jeweiligen Clusters ausgewählt wird und er dann an dieser 
Stelle eingefügt wird. Ist es nicht möglich den Cluster an einem Nearest Neighbour 
anzuhängen, ohne einen Zyklus zu erzeugen, wird er zufällig an einer Stelle im Baum 
angehängt. In Abb. 7 ist ein Beispiel für eine solche Rekombination illustriert. 

Mutation 

Wie vorhin schon erwähnt, wurde in der Mutation-Methode der Nearest Neighbours 
Ansatz auch umgesetzt. Dazu wurde die in [13] verwendete Methode als Grundlage 
genommen und durch den Nearest Neighbour Ansatz erweitert. 

In der Mutations-Methode wird an einer zufällig ausgewählten Stelle in der Lösung eine 
Änderung vorgenommen. Der Ablauf der Mutations-Methode ist wie folgt: Zuerst wird 
zufällig ein Cluster C i in der Lösung ausgewählt, dessen Vorgänger geändert werden 
soll. Danach werden alle Nearest Neighbours ermittelt, deren direkten oder indirekten 
Vorgänger nicht C i ist. Im nächsten Schritt wird aus dieser Liste zufällig ein neuer 
Vorgänger ermittelt und in die neue Lösung gespeichert. Gibt es keinen solchen Nearest 
Neighbour, werden mit Hilfe eines Tiefensuche-Algorithmus alle möglichen Cluster, 
deren direkten oder indirekten Vorgänger nicht C i ist, ermittelt. Danach wird aus diesen 
Clustern einer zufällig ausgewählt und als neuer Vorgänger für C i genommen. In Algo-
rithmus 9 wird gezeigt wie die Mutations-Methode funktioniert. 

Algorithmus 9 mutatePredecessor 
Eingabe: Lösung sol 

1: mutate ← random cluster 
2: cand ← nearest neighbours from mutate where mutate is not the direct or indirect 
predeccessor in sol 
3: if cand.size()! = 0 then 

4: 

cand ←all cluster where mutate is not the direct or indirect predeccessor in sol 
5: end if 
6: pred new ← random element from cand 
7: in 
die Einfüge-Methode integriert. Bei der Pop-Einfüge-Methode wird, wie auch in Kapi-
tel 2.1.1, die Bound nicht in jedem Einfügeschritt berechnet, sondern nur für einen 
Teil der Trie-Knoten der einzufügenden Lösung. Dazu wird wieder der Parameter 
branch_and_bound_prob verwendet, der angibt mit welcher Wahrscheinlichkeit die 
Bound für einen Trie-Knoten berechnet wird. 

Algorithmus 10 PopTrie insert with Bound 
Eingabe: solution to insert sol; best solution bestsol 
Ausgabe: insertion successfull (true/false) 
Variablen: m=number of clusters; root=root from archiv 

1: curr ← root 
2: for i=0...m − 1 do 

3: 

pos ← sol[curr.cluster] 

4: 

if curr.next[pos] = complete then 

5: 

return false 

6: 

end if 

7: 

if curr.next[pos] == null then 

8: 

if i == m − 1 then 

9: 

curr.next[pos] ← complete 

10: 

end if 

11: 

curr.next[pos] ← new trie-node 

12: 

calculate forbidden pointers 

13: 

end if 

14: 

invalidate(i, sol) 

15: 

if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, i) then 

16: 

delete curr.next[pos] 

17: 

curr.next[pos] ← complete 

18: 

check if trie-nodes are complete 

19: 

return false 

20: 

end if 

21: 

curr ← curr.next[pos] 
22: end for 
23: check if trie-nodes are complete 
24: return true 

Der Ablauf der Genauso -
ben Konvertierungsoperation, wird die inkrementelle dynamische Programmierungs-
Methode verwendet. Dazu wird vor jeder Boundberechnung die Methode invalidate 
aufgerufen, die alle Cluster markiert, für die die Kosten neu berechnet werden müssen. 2.2. Boundberechnung im Pop-Archiv 

Algorithmus 11 PopTrie convert with Bound 
Eingabe: solution to convert sol; best solution bestsol 
Ausgabe: convertion successfull (true/false) 
Variablen: nn[i]... Nearest Neighbours of Cluster i 

1: curr ← random trie-node of the possible startpoints from sol 
2: while curr! = null &amp;&amp; curr! = complete do 

3: 

p null ← random null-pointer from nn[curr], if none exist, random null-pointern 
from all pointer in curr 

4: 

if p null exists then 

5: 

change solution and check if cycle exist 

6: 

invalidate(curr.cluster, sol) 

7: 

if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then 

8: 

curr.next[sol[curr.cluster]] ← complete 

9: 

undo changes of sol 

10: 

else 

11: 

return true 

12: 

end if 

13: 

else 

14: 

if curr.next[sol[curr.cluster]]! = complete] then 

15: 

invalidate(curr.cluster, sol) 

16: 

if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then 

17: 

delete curr.next[sol[curr.cluster]] and set it complete 

18: 

else 

19: 

curr ← curr.next[sol[curr.cluster]] 

20: 

end if 

21: 

else 

22: 

sol[curr.cluster] ← random not-complete-pointer from nn[curr], if none 
exist, random not-complete-pointer from all pointer in curr 

23: 

invalidate(curr.cluster, sol) 

24: 

if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then 

25: 

delete curr.next[sol[curr.cluster]] and set it complete 

26: 

undo changes of sol 

27: 

else 

28: 

curr ← curr.next[sol[cur.cluster]] 

29: 

end if 

30: 

end if 

31: 

end if 
32: end while 

29 

KAPITEL 3 

Ergebnisse 

3.1 Vorgehensweise 

Die folgenden Tests wurden mit 14 TSPLib-Instanzen 
1 durchgeführt. Diese Instanzen 
sind ursprünglich für das Traveling Salesman Problem erzeugt worden und wurden für 
das GMST-Problem angepasst. Dazu wurden Cluster der Instanz hinzugefügt und die 
einzelnen Knoten mittels geografischem Clustering zugeordnet. Die verwendeten In-
stanzen bestehen aus 150-442 Knoten und 30-89 Clustern. Im Schnitt hat also jedes 
Cluster 5 Knoten. Die erweiterten TSPLib-Instanzen wurden auch von Wolf [15] und 
Sonnleitner [13] verwendet, was einen Vergleich der Ergebnisse erleichtert. 

Da der EA ein randomisierter Algorithmus ist, wurden für alle Tests 30 Runs gemacht 
und für die Auswertung der Mittelwert C avg </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Tabelle 1 : Testinstanzen und die verwendete Laufzeit</head><label>1</label><figDesc></figDesc><table>Instanz Knoten Cluster Laufzeit[s] 
kroa150 
150 
30 
150 
rat195 
195 
39 
150 
d198 
198 
40 
150 
krob200 
200 
40 
150 
ts225 
225 
45 
200 
pr226 
226 
46 
200 
gil262 
262 
53 
300 
pr264 
264 
54 
300 
pr299 
299 
60 
300 
lin318 
318 
64 
400 
rd400 
400 
80 
450 
fl417 
417 
84 
450 
pr439 
439 
88 
600 
pcb442 
442 
89 
600 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head></head><label></label><figDesc>Um zu belegen, dass das der Grund für den erhöhten Speicherverbrauch ist, wurden weitere Tests durchgeführt. Bei diesen Tests wurden Lösungen, bei denen eine Bound gefunden wurde, die schlechter ist als die beste bisher gefundene Lösung, trotzdem in der neuen Generation akzeptiert. D.h. wenn beim Einfügen einer Lösung eine schlechte Bound gefunden wird, wird der jeweilige Pointer als complete markiert und dann true zurück gegeben. Das hat zur Folge, dass der EA die Lösung als neu akzeptiert. Die Ergebnisse dieser Variante werden in Tabelle 9 gezeigt. Hier ist zu sehen, dass für die meisten Instanzen bei dieser Variante weniger Speicher für das Archiv gebraucht wurde.</figDesc><table>522,916.954 18.515,9 8.576 18.517,7 8.670 18.519,5 
5.218 
(9,2) 
(12,4) 
(8,7) 
(8,3) 
rd400 5.940,3 14.236 5.937,7 6.692 5.938,9 8.545 
5.939,9 
5.184 
(6,4) 
(5,8) 
(7,6) 
(5,6) 
fl417 7.982,0 1.486 7.982,0 875 
7.982,0 
585 
7.982,0 
418 
(0,0) 
(0,0) 
(0,0) 
(0,0) 
pr439 51.791,012.837 51.792,2 6.101 51.791,0 9.331 51.791,0 
4.716 
(0,0) 
(6,4) 
(0,0) 
(0,0) 
pcb442 19.625,817.457 19.623,6 8.198 19.620,5 10.872 19.622,8 
6.961 
(19,1) 
(17,4) 
(18,7) 
(18,3) In den bisherigen Tests ist zu sehen, dass durch die Verwendung der Bounding-Strategie 
die Anzahl der erzeugten Generationen geringer sind. Dadurch ist ein Vergleich des 
Speicherverbrauchs der beiden Varianten nicht möglich, da bei dem Archiv ohne Bound-
ing mehr Lösungen in das Archiv eingefügt werden als beim Archiv mit Bounding. 
Um jetzt den Speicherverbrauch der unterschiedlichen Varianten miteinander zu ver-
gleichen, wird als Abbruchbedingung für den EA eine fixe Anzahl von Generationen 
genommen. So werden bei allen Varianten gleich viele Generationen erzeugt. 

Für diese Tests wurde die Abbruchbedingung des EAs auf 10.000 Generationen gesetzt. 
In den Tabellen 7 und 8 sind die Ergebnisse für diese Tests zu sehen. In der Tabelle 
7 wurde das Gosh-Archiv untersucht, während in Tabelle 8 die Ergebnisse für das 
Pop-Archiv zu sehen sind. Es wurden jeweils das "normale" Archiv ohne Bounding-
Strategie, das mit Bounding-Strategie in der Einfüge-Methode und das mit Bounding-
Strategie in der Konvertierungs-Methode miteinander verglichen. Die Spalte C avg ent-
spricht dabei wieder dem Durchschnitt der Lösungswerte über alle Runs, unter diesem 
Wert steht in Klammern die Standardabweichung, Zeit entspricht der durchschnittlich 
benötigten Zeit und M em den benötigten Speicher für das Archiv. 

In diesen Ergebnissen ist zu sehen, dass die Varianten mit Bound immer mehr Spei-
cher benötigen als die ohne Bound. Das kommt zunächst überraschend, da man zuerst 
annehmen würde, dass durch die Bounding-Strategie auch weniger Speicher verbraucht 
würde. Der Grund für den erhöhten Speicherverbrauch bei der Einfüge-Methode ist 
in Abb. 8 zu sehen. In diesem Beispiel wird zunächst versucht, im Gosh-Archiv die 
Lösung &lt;321112&gt; (in der Grafik rot dargestellt) einzufügen. In Knoten V 5 wird eine 
Bound festgestellt, die schlechter ist als die beste bisher gefundene Lösung, und somit 
der Pointer 1 als complete markiert. Danach wird die Einfügeoperation abgebrochen 
und f alse zurück geben. Für den EA sieht es daher so aus, als wäre die Lösung im 
Archiv schon enthalten. Im nächsten Schritt wird mit der Konvertierungsmethode eine 
neue Lösung &lt;341112&gt; erzeugt. Diese wird nun erfolgreich in das Archiv eingefügt. 
Würde die Bounding-Strategie nicht verwendet werden, wäre die Lösung &lt;321112&gt; 
beim ersten Mal eingefügt worden. Da die Bounding-Strategie verwendet wurde, ist nun 
die Lösung &lt;321112&gt; bis zum Knoten V 5 und die Lösung &lt;341112&gt; ganz eingefügt 
worden. D.h. beim Erzeugen einer neuen Lösung für die neue Generation wurden die 
drei Knoten V 3, V 4 und V 5 des ersten Einfügeversuchs zusätzlich eingefügt. Deshalb 
kommt es bei der Verwendung der Bounding-Strategie zu einem höheren Speicherver-
brauch. 

</table></figure>

			<note place="foot" n="1"> http://elib.zib.de/pub/Packages/mp-testdata/tsp/tsplib/tsp/index.html</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Generalized Spanning Trees and Extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feremans</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>Universite Libre de Bruxelles, Diss.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Solving medium to large sized Euclidean generalized minimum spanning tree problems / Indian Institute of Management, Research and Publication Department</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghosh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Computing Generalized Minimum Spanning Trees with Variable Neighborhood Search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">;</forename><surname>Leitner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">;</forename><surname>Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th Mini Euro Conference on Variable Neighborhood Search. Teneriffa, Spanien</title>
		<editor>HANSEN, P. (Hrsg.)</editor>
		<editor>MLADENOVI´NOVI´ C, N. (Hrsg.)</editor>
		<editor>PÉREZ, J. A. M. (Hrsg.)</editor>
		<editor>BATISTA, B. M. (Hrsg.)</editor>
		<editor>MORENOVEGA, J. M.</editor>
		<meeting>the 18th Mini Euro Conference on Variable Neighborhood Search. Teneriffa, Spanien<address><addrLine>Hrsg.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Combining Variable Neighborhood Search with Integer Linear Programming for the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">;</forename><surname>Leitner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">;</forename><surname>Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Heuristics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="473" to="499" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Evolutionary Algorithm with Solution Archive for the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">;</forename><surname>Raidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EUROCAST 2011-13th International Conference on Computer Aided Systems Theory</title>
		<editor>QUESADA-ARENCIBIA, A.</editor>
		<meeting>EUROCAST 2011-13th International Conference on Computer Aided Systems Theory<address><addrLine>Las Palmas de Gran Canaria, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="256" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An efficient algorithm for generalized minimum spanning tree problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
		<idno>978-1-4503-0072-8</idno>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;10: Proceedings of the 12th annual conference on Genetic and evolutionary computation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Solving Two Generalized Network Design Problems with Exact and Heuristic Methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leitner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<editor>G. Raidl and B. Hu</editor>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien, Diplomarbeit</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Myung</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Tcha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="231" to="241" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Einführung in Evolutionäre Algorithmen.: Optimierung nach dem Vorbild der Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nissen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Vieweg</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A hybrid heuristic approach for solving the generalized traveling salesman problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pop</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Iordache</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO, ACM</title>
		<editor>KRASNOGOR, Natalio (Hrsg.)</editor>
		<editor>LANZI, Pier L.</editor>
		<meeting><address><addrLine>Hrsg.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="481" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Generalized Minimum Spanning Tree Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pop</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<pubPlace>Diss</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Twente</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Enhancing Genetic Algorithms by a Trie-Based Complete Solution Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raidl</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolutionary Computation in Combinatorial Optimisation-EvoCOP</title>
		<imprint>
			<biblScope unit="page" from="239" to="251" />
			<date type="published" when="2010" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Ein neues Lösungsarchiv für das Generalized Minimum Spanning Tree-Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sonnleitner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Enhancing a Genetic Algorithm by a Complete Solution Archive Based on a Trie Data Structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Šramko</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Ein Lösungsarchiv-unterstützter evolutionärer Algorithmus für das Generalized Minimum Spanning Tree-Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolf</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A Complete Archive Genetic Algorithm for the Multidimensional Knapsack Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zaubzer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<pubPlace>Diplomarbeit</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technische Universität Wien</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
